//----- AN FGD FIT FOR A LORD -----//
//      VERSION 7
//		Last updated 19th January 2024


//----- USER SETTINGS -----//

// To make it easy for mappers to fine-tune their Hammer experience, a number of options have been made simpler to customize. Changing a setting is done by "commenting" or "uncommenting" a line of FGD code, usually the line directly beneath the setting's name. "Commenting" a line means adding two forward-slashes to the front of its line (//), while "uncommenting" a line is removing these forward-slashes from a line.
// Any changes to these settings will not appear in Hammer until Hammer is restarted.
// NOTE: DO NOT UNCOMMENT ANY LINES OF DOCUMENTATION (any line which describes features of this FGD or how to use it, like this one). This will cause errors when Hammer attempts to load the file.

// This isn't a setting, don't touch this, it just needs to be here for cool technical reasons that you don't need to care about.
@include "spudlord-settings/default.fgd"



	// SETTING: PROPPER SUPPORT //
	
@include "spudlord-settings/propper.fgd"

// This FGD supports the TF2 version of Propper by default. If you don't want the Propper entities to appear in your entity browser, simply comment out the line above. You still need the actual propper.exe compiler. More info: tf2maps.net/threads/guide-getting-propper-working-nowdays.38589/


	// SETTING: LINE DIVIDERS //
	
//@include "spudlord-settings/linediv.fgd"
@include "spudlord-settings/linediv-blank.fgd"

//If you do not want dividers between various key value groups in your entity settings, comment out the second line above. If you want dividers with lines in them, comment out the second line and uncomment the first one. Otherwise leave as-is.


	// SETTING: PITCH KEYVALUE IN LIGHTS //
	
//@BaseClass base(SPitchInv) = SPitchInvTest []

// If the previous line is commented, then orientable light entities (such as light_spot) will NOT have a separate pitch keyvalue and will use the pitch from the Pitch Yaw Roll keyvalue. Uncommenting the previous line will display the Pitch Override keyvalue in entity properties and cause it to override the pitch in Pitch Yaw Roll. This will make the first value in the Pitch Yaw Roll property redundant.


	// SETTING: CUSTOM PLAYWERMODEL PREVIEW //

//@BaseClass base(STeamSpawnDefault)	= STeamSpawnAppearance []	//DEFAULT GREEN GORDON
@BaseClass base(STeamSpawnABS)		= STeamSpawnAppearance []		//ABS' ENGINEER
//@BaseClass base(STeamSpawnPuddy)		= STeamSpawnAppearance []	//PUDDY'S ENGINEER

// By default, this FGD will use the Engineer retexture by A Boojum Snark as spawnpoint models. Comment out the middle line and uncommend any of the others to use that spawn point appearance. This is a hammer-only visual change and does not affect your map in-game.






//----- FGD CODE BEGINS BELOW -----//
//DO NOT EDIT THE FILE BEYOND THIS POINT UNLESS YOU KNOW WHAT YOU'RE DOING (or really hate yourself)!







@mapsize(-16384, 16384)



//----- ENTITY COLORS -----//

	// DYNAMIC //
// color(255 100 0)		(red-orange)	for Breakable and Physics
// color(150 50 50)		(deep red)		for SBaseConstraint
// color(200 200 200)	(light gray)	for SBaseItem and item_teamflag

	// LOGIC //
// color(100 150 255)	(light blue)	for SBaseLogical
// color(100 255 100)	(green)			for Storage/Mathematical
// color(255 50 50)		(red)			for info_null
// color(150 0 200)		(purple)		for SBaseBoss, SBaseNPC, and Bot/NPC-related

	// TOOLS //
// color(255 255 255)	(white)			for Lights
// color(50 50 200)		(dark blue)		for Optimization
// color(200 200 0)		(dark yellow)	for Instances

	// TRIGGERS //
// color(255 150 50) 	(orange)		for SBaseTrigger
// color(255 100 150)	(pink)			for SBaseFilter

	// WORLD //
// color(0 175 0)		(dark green)	for func_detail
// color(255 255 0)		(yellow)		for Static Props
// color(255 200 100)	(light orange)	for Overlays and Decals



//----- MATERIAL DIRECTORY EXCLUSIONS -----//
	// Names of the sub-directories we don't want to load materials from

@MaterialExclusion [
	"ambulance"
	"backpack"
//	"cable"
	"console"
	"customcubemaps"
	"cubemaps"
	"debug"
	"detail"
	//"editor" // I'M A DAMNED FOOL
	"editor-abs" //
	"editor-ficool2" //
	"editor-abs"
	"engine"
	"matsys_regressiontest"
	"hlmv"
//	"hud"	// Kinda useful sometimes. If this stuff annoys you in the materials browser, revert this comment (or the others that are commented out) -Brokk
//	"logo"
	"maps"
	"overviews"
	"models" //Apparently Hammer never loads this folder anyway? Might wanna do some research into that. -Brokk
	"perftest"
	"scripted"
	"shadertest"
//	"sprites"
	"voice"
	"vr"
//	"vgui"
] // end MaterialExclusion


//----- AUTO VISGROUPS -----//
// TODO: These could probably use a refresher...

@AutoVisGroup = "World Geometry" [
	"Water" [
		"func_water"
		"func_water_analog"
	] // end Water
] // end World Geometry

@AutoVisGroup = "World Details" [
	"Decals / Overlays" [
		"info_overlay"
		"info_overlay_transition"
		"info_projecteddecal"
		"infodecal"
	] // end Overlays
] // end World Details

@AutoVisGroup = "Tool Brushes" [
	//"Clips" [
	//	"VPhysics" [ // Won't let me specify triple-nested auto visgroups :'(
	//		"func_clip_vphysics"
	//	] // end VPhysics
	//] // end Clips
	"NoBuild" [
		"func_nobuild"
	] // end Nobuild
	"Visclusters" [
		"func_viscluster"
	] // end Visclusters
] // end Tool Brushes

@AutoVisGroup = "Entities" [
	"Logic" [
	    "commentary_auto"
		"env_debughistory"
		"env_particle_performance_monitor"
        "env_player_surface_trigger"
        "filter_activator_class"
        "filter_activator_mass_greater"
        "filter_activator_name"
        "filter_activator_team"
        "filter_activator_tfteam"
        "filter_base"
        "filter_damage_type"
        "filter_enemy"
        "filter_multi"
        "filter_tf_bot_has_tag"
        "filter_tf_class"
        "filter_tf_condition"
        "filter_tf_damaged_by_weapon_in_slot"
        "filter_tf_player_can_cap"
		"func_flag_alert"
		"func_flagdetectionzone"
        "game_end"
        "game_forcerespawn"
        "game_gib_manager"
        "game_intro_viewpoint"
        "game_player_equip"
        "game_player_team"
        "game_ragdoll_manager"
        "game_round_win"
        "game_score"
        "game_ui"
        "game_weapon_manager"
        "game_zone_player"
        "logic_active_autosave"
        "logic_auto"
        "logic_autosave"
        "logic_branch"
        "logic_branch_listener"
        "logic_case"
        "logic_choreographed_scene"
        "logic_collision_pair"
        "logic_compare"
        "logic_lineto"
        "logic_measure_movement"
        "logic_multicompare"
        "logic_navigation"
        "logic_proximity"
        "logic_relay"
        "logic_scene_list_manager"
        "logic_timer"
        "math_colorblend"
        "math_counter"
        "math_remap"
        "multisource"
        "passtime_logic"
		"player_loadsaved"
        "player_manager"
        "player_speedmod"
        "player_weaponstrip"
        "point_anglesensor"
        "point_angularvelocitysensor"
        "point_bonusmaps_accessor"
        "point_clientcommand"
        "point_gamestats_counter"
        "point_intermission"
        "point_playermoveconstraint"
        "point_populator_interface"
        "point_posecontroller"
        "point_proximity_sensor"
        "point_servercommand"
        "point_teleport"
        "point_template"
        "point_velocitysensor"
        "tanktrain_ai"
        "tanktrain_aitarget"
        "team_control_point"
        "team_control_point_master"
        "team_control_point_round"
        "team_round_timer"
        "team_train_watcher"
		"tf_gamerules"
        "tf_halloween_minigame"
        "tf_halloween_minigame_falling_platforms"
        "tf_logic_arena"
        "tf_logic_bonusround"
        "tf_logic_competitive"
        "tf_logic_cp_timer"
        "tf_logic_holiday"
        "tf_logic_hybrid_ctf_cp"
        "tf_logic_koth"
        "tf_logic_mann_vs_machine"
        "tf_logic_mannpower"
        "tf_logic_medieval"
        "tf_logic_minigames"
        "tf_logic_multiple_escort"
        "tf_logic_on_holiday"
        "tf_logic_player_destruction"
        "tf_logic_robot_destruction"
        "tf_logic_training_mode"
        "trigger"
        "trigger_add_or_remove_tf_player_attributes"
        "trigger_add_tf_player_condition"
        "trigger_apply_impulse"
        "trigger_autosave"
        "trigger_bot_tag"
        "trigger_brush"
        "trigger_capture_area"
        "trigger_catapult"
        "trigger_cdaudio"
        "trigger_changelevel"
        "trigger_gravity"
        "trigger_hurt"
        "trigger_ignite"
        "trigger_impact"
        "trigger_look"
        "trigger_multiple"
        "trigger_once"
        "trigger_particle"
        "trigger_passtime_ball"
        "trigger_player_respawn_override"
        "trigger_playermovement"
        "trigger_proximity"
        "trigger_push"
        "trigger_rd_vault_trigger"
        "trigger_remove"
        "trigger_remove_tf_player_condition"
        "trigger_serverragdoll"
        "trigger_soundscape"
        "trigger_stun"
        "trigger_teleport"
        "trigger_teleport_relative"
        "trigger_timer_door"
        "trigger_togglesave"
        "trigger_transition"
        "trigger_vphysics_motion"
        "trigger_wind"
    ] // end Logic
	"Lights" [
		"light"
		"light_directional"
		"light_dynamic"
		"light_environment"
		"light_glspot"
		"light_spot"
	] // end Lights
] // end Entities

@AutoVisGroup = "Custom" [
	"Bots" [
        "archer_proxy"
        "base_boss"
        "bot_action_point"
        "bot_controller"
        "bot_generator"
        "bot_hint_engineer_nest"
        "bot_hint_sentrygun"
        "bot_hint_teleporter_exit"
        "bot_npc_archer"
        "bot_npc_decoy"
        "bot_proxy"
        "bot_roster"
		"eyeball_boss"
        "filter_tf_bot_has_tag"
		"func_nav_avoid"
        "func_nav_avoidance_obstacle"
        "func_nav_blocker"
        "func_nav_prefer"
        "func_nav_prerequisite"
		"func_suggested_build"
		"func_tfbot_hint"
        "ghost"
        "headless_hatman"
		"merasmus"
		"point_populator_interface"
		"populator_internal_spawn_point"
		"simple_bot"
		"tank_boss"
		"tf_bot"
		"tf_point_nav_interface"
		"tf_robot_destruction_robot"
		"tf_robot_destruction_robot_spawn"
		"tf_robot_destruction_spawn_group"
		"tf_zombie"
		"tf_zombie_spawner"
		"trigger_bot_tag"
	] // end Bots
	"Performance" [
	    "env_detail_controller"
		"env_fog_controller"
	    "env_particle_performance_monitor"
		"func_areaportal"
		"func_areaportalwindow"
		"func_lod"
		"func_occluder"
		"func_viscluster"
		"game_gib_manager"
		"game_ragdoll_manager"
		"game_weapon_manager"
	] // end Performance
	"Physics" [
        "func_clip_vphysics"
        "func_physbox"
        "func_physbox_multiplayer"
        "func_proprrespawnzone"
        "func_pushable"
        "func_vehicleclip"
        "func_weight_button"
        "info_constraint_anchor"
        "info_mass_center"
        "info_radial_link_controller"
        "passtime_ball"
        "phys_ballsocket"
        "phys_bone_follower"
        "phys_constraint"
        "phys_constraintsystem"
        "phys_convert"
        "phys_hinge"
        "phys_keepupright"
        "phys_lengthconstraint"
        "phys_magnet"
        "phys_motor"
        "phys_pulleyconstraint"
        "phys_ragdollconstraint"
        "phys_ragdollmagnet"
        "phys_slideconstraint"
        "phys_spring"
        "phys_thruster"
        "phys_torque"
        "physics_cannister"
        "physics_entity_solver"
        "physics_npc_solver"
        "physics_prop"
        "physics_prop_ragdoll"
        "point_enable_motion_fixup"
        "prop_physics"
        "prop_physics_multiplayer"
        "prop_physics_override"
        "prop_physics_respawnable"
        "prop_ragdoll"
        "prop_ragdoll_attached"
        "prop_soccer_ball"
        "prop_sphere"
        "prop_vehicle"
        "prop_vehicle_driveable"
        "simple_physics_brush"
        "simple_physics_prop"
        "tf_ammo_pack"
        "tf_dropped_weapon"
        "tf_ragdoll"
    ] // end Physics
	"Sound" [
     	"ai_sound"
     	"ambient_generic"
		"env_microphone"
		"env_soundscape"
        "env_soundscape_proxy"
        "env_soundscape_triggerable"
		"point_commentary_node"
		//"point_tesla"
		"soundent"
		"target_cdaudio"
		"trigger_cdaudio"
		"trigger_soundscape"
	] // end Sound
] // end Custom



//----- BASE CLASSES -----//
// NOTE: I refactored all the baseclass names in V3b, so they all have an "S" in front of them, using the Replace function. I fixed all the hammer errors that popped up but there might still be a few artifacts of that change lying around



	// BASEENTITY PARTS //
// The uppermost section of each entity's keyvalues will be made of whatever combination of these keyvalues that entity uses, in this order, for consistency. These will always be separated from the rest of an entity's keyvalues by a divider (not necessarily the SBaseDiv divider). Some preset BaseClass arrangements of these keyvalues are provided for the most common configurations, listed under BaseEntity Sections.
//Translation: The following classes may apply to any and all entities. -Brokk

@BaseClass = SDoesNotFunction [
	does_not_function(string) readonly : "NOTE: THIS ENTITY DOES NOT FUNCTION." :  : "Most or all of this entity's functionality does not exist in-game, or the entity crashes the game when spawned/used, even though the game may claim to support this entity or the entity exists in code. This entity is kept in the FGD for legacy compatibility and completeness' sake."
] // end SDoesNotFunction
@BaseClass = SDoesNotFunctionPartial [
	does_not_function(string) : "NOTE: THE FOLLOWING FEATURES DO NOT FUNCTION." :  : "Many of this entity's keyvalues are broken or nonfunctional in-game. These keyvalues are kept in the FGD for legacy compatibility and completeness' sake and should not be used. They are moved below this banner to prevent confusion with functional features."
] // end SDoesNotFunctionPartial
@BaseClass = SDoNotPlace [
	does_not_function(string) readonly : "NOTE: DO NOT MANUALLY PLACE THIS ENTITY." :  : "This entity is ONLY meant to be spawned dynamically and automatically by the game. If placed by the mapper in Hammer or otherwise spawned manually, it may break the map/game. This is only intended to serve as a demonstration of this entity's keyvalues/inputs/outputs. Keyvalues should be changed at runtime using AddOutput."
] // end SDoNotPlace
@BaseClass = SPreservedEntity [
	preserved_entity(string) readonly : "NOTE: THIS IS A PRESERVED ENTITY." :  : "This entity is part of TF2's s_PreserveEnts whitelist and will not automatically be reset to its original state on a new round. This means that, if killed, it will be need to be respawned manually via a point_template or similar. developer.valvesoftware.com/wiki/S_PreserveEnts"
] // end SPreservedEntity

@BaseClass = SScript
[
	vscripts(scriptlist) : "Entity Scripts" : : "Name(s) of script files that are executed after all entities have spawned."
	thinkfunction(string) : "Script think function" : : "Name of a function in this entity's script scope which will be called automatically."

	input RunScriptFile(string) : "Execute a game script file from disk."
	input RunScriptCode(script) : "Execute a string of script source code. Backtick ( ` ) characters will be converted to quotes in-game for strings."
	input CallScriptFunction(string) : "Execute the given function name."
	input TerminateScriptScope(void) : "Terminates the script scope of the entity."
] // end SScript

@BaseClass = SModel [
	model(studio) : "Model" :  : "The model this entity should appear as. 128 character limit."
] // end SModel
@BaseClass = SPowerupModel [
	powerup_model(studio) : "Model Override" :  : "Change the model to something other than the default model. Cannot be previewed in Hammer."
] // end SPowerupModel
@BaseClass = SFlagModel [
	flag_model(studio) : "Model Override" :  : "Change the model to something other than the default model. Cannot be previewed in Hammer."
] // end SFlagModel

@BaseClass = SHelperModel [
	model(choices) : "Helper Model (Hammer Only)" : "" : "Model this entity should appear as in Hammer, to assist with placement or identification. Any model can be specified, not just ones listed here. This will NOT affect how the entity appears in-game. If the Empty option causes this entity to disappear from the 3D view, you can still find it via the 2D view or Map -> Entity Report." = [
		"" : "None (Default Cube)" //This will actually place a cube instead, completely covering the iconsprite (if there is one). Use "No Model" if you just want to see the iconsprite.
		"models/empty.mdl" : "Empty (Check 2D view!)"
		"models/editor-puddy/hngineer.mdl" : "Dev Engineer by Puddy"
		"models/editor-abs/dev_engy.mdl" : "Dev Engineer by ABS"
		"models/editor/playerstart.mdl" : "Dev Gordon"
		"models/editor/cone_helper.mdl" : "Blue Cone Helper"
		"models/editor-ficool2/cone_helper_gray.mdl" : "Gray Cone Helper"
		"models/editor/axis_helper_thick.mdl" : "Thick Axis Helper"
		"models/editor/camera.mdl" : "Camera Helper"
	] // end model
] // end SHelperModel
@BaseClass base(STeamSpawnAppearance) = SPlayerHelper [ //this is now defined in the settings
	//model(choices) : "Helper Model (Hammer Only)" : "models/editor-abs/dev_engy.mdl" : "Model this entity should appear as in Hammer, to assist with placement or identification. Any model can be specified, not just ones listed here. This will NOT affect how the entity appears in-game. If the Empty option causes this entity to disappear from the 3D view, you can still find it via the 2D view or Map -> Entity Report." = [
	//	"" : "None"
	//	"models/empty.mdl" : "Empty (Check 2D view!)"
	//	"models/editor-puddy/hngineer.mdl" : "Dev Engineer by Puddy"
	//	"models/editor-abs/dev_engy.mdl" : "Dev Engineer by ABS"
	//	"models/editor/playerstart.mdl" : "Dev Gordon"
	//	"models/editor/cone_helper.mdl" : "Blue Cone Helper"
	//	"models/editor-ficool2/cone_helper_gray.mdl" : "Gray Cone Helper"
	//	"models/editor/axis_helper_thick.mdl" : "Thick Axis Helper"
	//	"models/editor/camera.mdl" : "Camera Helper"
	] // end model
//] // end SPlayerHelper

@BaseClass base(SScript) = STargetname [
	targetname(target_source) : "Name" :  : "The name that other entities refer to this entity by."
] // end STargetname

@BaseClass = SParentname [
	parentname(target_destination) : "Parent" :  : "Specifies a movement parent. An entity will mimic the movements of its parent, maintaining its initial offset from the parent. An attachment point can optionally be added to the end of the name, separated by a comma. Most entities can be parented, although some entities which aren't intended to be parented (ie physics objects) may not function correctly. logic_measure_movement or phys_constraint can sometimes be used as a workaround to parenting. Parent loops (where two or more entities are parented to each other) will cause silent crashes. Do not do that."

	input ClearParent(void) : "Removes this entity from the the movement hierarchy, leaving it free to move independently."
	input SetParent(target_destination) : "Changes the entity's parent in the movement hierarchy."
	input SetParentAttachment(string) : "Change this entity to attach to a specific attachment point on its parent. Entities must be parented before being sent this input. The parameter passed in should be the name of the attachment."
	input SetParentAttachmentMaintainOffset(string) : "Change this entity to attach to a specific attachment point on it's parent. Entities must be parented before being sent this input. The parameter passed in should be the name of the attachment. The entity will maintain it's position relative to the parent at the time it is attached."
] // end SParentname

@BaseClass = SOrigin [
	origin(origin) : "Origin (X Y Z)" :  : "The position of this entity's center in the world. Entities typically rotate around their origin. This point must be inside the map to prevent a leak."
] // end SOrigin

@BaseClass = SAngles [
	angles(angle) : "Pitch Yaw Roll (Y Z X)" : "0 0 0" : "This entity's orientation in the world. Pitch is rotation around the Y axis (side view), Yaw is rotation around the Z axis (top view), and Roll is rotation around the X axis (front view). For brush entities, the rotation set in this keyvalue won't be shown in Hammer and the entity will be lit as though it is unrotated."
] // end SAngles
// For entities with inverted pitch and a separate pitch keyvalue
@BaseClass = SAnglesPitchInv [
	angles(angle_negative_pitch) : "Pitch Yaw Roll (Y Z X)" : "0 0 0" : "This entity's orientation in the world, with the pitch being inverted. Pitch is rotation around the Y axis (side view), Yaw is rotation around the Z axis (top view), and Roll is rotation around the X axis (front view). Contrary to popular belief, specifying the pitch in a separate keyvalue is unnecessary."
	// Leaving the pitch keyvalue out doesn't break anything. Game just uses the pitch value from angles if this keyvalue is not included. I'VE BEEN LIED TO MY ENTIRE LIFE
	// If you want to have the pitch keyvalue in your lights, see the User Settings. Note that the pitch keyvalue will ALWAYS override the Pitch Yaw Roll if it is included; you can't really switch back and forth on a whim.
	// Pitch keyvalue moved to PitchInv baseclass and inherited by SBaseAnglesLight
] // end SAnglesPitchInv

// No unique keyvalues in here, just the basic inputs and outputs that all entities with I/O capabilities have
@BaseClass = SBaseIO [
	targetname(target_source) : "Name" :  : "The name that other entities refer to this entity by. This can be changed at runtime with AddOutput to change which entities can reference me."

	input AddOutput(string) : "AddOutput has two separate functions: Changing an entity's keyvalues at runtime, or adding an I/O output to an entity at runtime. The parameter should be formatted in one of the following ways, depending on which function you intend to achive (do not include the brackets):\n" +
	"-To change an entity's keyvalues: '<key name> <new value>'\n" +
	"-To add an I/O output: '<output name> <target entity>:<input name>:<parameter override>:<delay>:<max times to fire>'\n" +
	"A key's name is the name displayed while SmartEdit is disabled. Not all keyvalues support being changed at runtime. For <max times to fire>, -1 = infinite."
	input DispatchEffect(string) : "Dispatch an effect from the entity's origin. See developer.valvesoftware.com/wiki/List_of_Client_Effects for a list of effects. Not all of those work."
	// God this engine is fucking baffling sometimes
	input FireUser1(string) : "Causes this entity's OnUser1 output to be fired immediately.\n" +
	"BUG: Strangely, the FireUser* inputs are set to accept strings as parameters, despite not using the parameter (the value is NOT passed to the corresponding OnUser* output). As a result, any output that passes a numerical value to these inputs, such as a math_counter's OutValue, will cause a 'bad input/output link' error and the input won't be received. This can be fixed by specifying any dummy value as a parameter override."
	input FireUser2(string) : "Causes this entity's OnUser2 output to be fired immediately."
	input FireUser3(string) : "Causes this entity's OnUser3 output to be fired immediately."
	input FireUser4(string) : "Causes this entity's OnUser4 output to be fired immediately."
	input Kill(void) : "Removes this entity and all its children from the world."
	input KillHierarchy(void) : "Immediately removes this entity and all its children from the world. Slightly faster than sending the Kill input on entities with children, as the children are removed in the same frame as the parent." //y tho
	input Use(void) : "Similar to a player invoking +use on this entity; may not do anything. Can also be invoked by creating an output that does not specify an input."

	output OnUser1(void) : "Fired in response to the FireUser1 input."
	output OnUser2(void) : "Fired in response to the FireUser2 input."
	output OnUser3(void) : "Fired in response to the FireUser3 input."
	output OnUser4(void) : "Fired in response to the FireUser4 input."
] // end SBaseIO

// Divider sometimes used to separate the BaseEntity parts from the rest of an entity's keyvalues. This should be reserved for use by individual entities and extremely entity-specific BaseClasses; general BaseClasses and keyvalue sections should create their own dividers.
// SBaseDiv moved to tf2_spud/linediv.fgd



	// BASEENTITY SECTIONS //
// Complete sections of BaseEntity parts. These do not include any sort of divider, as keyvalue sections are expected to have dividers at the top, and these keyvalues are usually the first in an entity's list of properties. The only things that might go above these are any of the model BaseClasses.

// Entities whose position and orientation matter (ie props, targets).
@BaseClass base(STargetname, SParentname, SAngles, SBaseIO) = SBaseEntity [
] // end SBaseEntity

// Entities whose origin should be defined explicitly (most brush entities).
@BaseClass base(STargetname, SParentname, SOrigin, SAngles, SBaseIO) = SBaseEntityOrigin [
] // end SBaseEntityOrigin

// Entities whose position doesn't matter (ie logic entities). These can sometimes still be parented and have angles, but there's rarely any reason to, so we usually leave that stuff out.
@BaseClass base(STargetname, SBaseIO) color(100 150 255) = SBaseLogical [
] // end SBaseLogical

// Light entities that have angles and (optionally) a separate pitch keyvalue.
@BaseClass base(STargetname, SAnglesPitchInv, SPitchInvTest, SBaseIO) = SBaseAnglesLight [
target(target_destination) : "Entity to point at. Will overwrite the entity's angles keyvalue and point in that direction instead."
] // end SBaseAnglesLight



	// LONE KEYVALUES //
// Stuff that doesn't really warrant its own section of keyvalues but which are duplicated enough times that they warrant their own BaseClass.

@BaseClass = SActivateDeactivate [
	StartActive(choices) : "Start Active?" : 1 : "Whether this entity should stay dormant until activated with the Activate input." = [
		0 : "No"
		1 : "Yes"
	] // end StartActive

	input Activate(void) : "Activate this entity."
	input Deactivate(void) : "Deactivate this entity."
] // end SActivateDeactivate

@BaseClass = SCollisions [
	solid(choices) : "Collisions" : 6 : "Method of collision for this entity. Players can sometimes get stuck on Oriented Bounding Box." = [
		0 : "Non-solid" // prop_static, prop_dynamic: Nonsolid (expected)
		//1 : "BSP (QPhysics)" // prop_static, prop_dynamic: Nonsolid
		6 : "VPhysics (collision mesh)" // prop_static, prop_dynamic: Collide with collision mesh
		2 : "Bounding Box (grid-aligned)" // prop_static: Collide with grid-aligned bounding box (expected); prop_dynamic: Collide with unrotated bounding box
		3 : "Oriented Bounding Box" // prop_static: Nonsolid; prop_dynamic: Collide with oriented bounding box, sometimes gets stuck
		//4 : "Oriented Bounding Box, constrained to Yaw only"// prop_static, prop_dynamic: Nonsolid
		//5 : "Custom (defined per-entity, if not defined the entity will have bizarre collision behavior)" // prop_static, prop_dynamic: Nonsolid
	] // end solid
] // end SCollisions

@BaseClass = SControlPoint [
	controlpoint(target_destination) : "Associated Control Point" :  : "Optionally, the team_control_point associated with this entity. When the round starts, this entity will match its team to the team of the control point. This will not automatically update if the control point changes team mid-round."
] // end SControlPoint

@BaseClass = SDamageFilter [
	damagefilter(filterclass) : "Damage Filter" :  : "When this entity receives damage, it will filter by this entity. Only damage events that pass this filter will affect the entity."

	input SetSDamageFilter(target_destination) : "Set the filter that this entity uses to filter damage events. Leave blank for no damage filter."
] // end SDamageFilter

@BaseClass = SDamageTypes [
	damagetype(choices) : "Damage Type" : 0 : "The damage type to use. Not all types have a noticeable effect. Can be combined by adding the desired damage type numbers together, such as 2 + 64 = 66. developer.valvesoftware.com/wiki/Damage_types" = [
		0 : "0: Generic - No sounds/indicators/flinching/blood (DMG_GENERIC)"
		1 : "1: Crush - red flash (DMG_CRUSH)"
		2 : "2: Bullet/Underworld - impact sounds (DMG_BULLET)"
		4 : "4: Double Blood (DMG_SLASH)"
		8 : "8: Burn - no sounds/indicators, no burn (DMG_BURN)"
		16 : "16: Train - train kill icon!!! (DMG_VEHICLE)"
		32 : "32: Fall - dramatic screams, crunch on death (DMG_FALL)"
		64 : "64: Blast - gib if health <= -10 (DMG_BLAST)"
		128 : "128: Club - critical death scream (DMG_CLUB)"
		256 : "256: Shock - smoke and sparks (DMG_SHOCK)"
		16384 : "16,384: Drown - blue flash and gurgles (DMG_DROWN)"
		65536 : "65,536: Sawblade - saw kill icon (DMG_NERVEGAS)"
		1048576 : "1,048,576: Critical - triple dmg, crit sounds (DMG_CRITICAL)"

		1024 : "1,024: No Falloff (DMG_RADIUS_MAX)"
		2048 : "2,048: No Push (DMG_PREVENT_PHYSICS_FORCE)"
		131072 : "131,072: Reduce Ramp-Up (DMG_NOCLOSEDISTANCEMOD)"
		262144 : "262,144: Half Falloff - gib if health <= -10 (DMG_HALF_FALLOFF)"
		2097152 : "2,097,152: Use Ramp-Up/Falloff - from center of brush (DMG_USEDISTANCEMOD)"
		2228224 : "2,228,224: Falloff and Reduced Ramp-Up (2,097,152 + 131,072)"

		512 : "512: DMG_SONIC"
		4096 : "4,096: DMG_NEVERGIB - doesn't prevent gibs"
		8192 : "8,192: DMG_ALWAYSGIB - doesn't gib"
		32768 : "32,768: DMG_PARALYZE"
		524288 : "524,288: DMG_DROWNRECOVER"
		4194304 : "4,194,304: DMG_REMOVENORAGDOLL - leaves a temp. floating player model and a ragdoll"
		8388608 : "8,388,608: DMG_PHYSGUN"
		16777216 : "16,777,216: DMG_IGNITE - Does not actually ignite"
		33554432 : "33,554,432: DMG_USE_HITLOCATIONS"
		67108864 : "67,108,864: DMG_DONT_COUNT_DAMAGE_TOWARDS_CRIT_RATE" // Is also DMG_DISSOLVE in HL2. Code indicates this behaves differently when combined with DMG_SHOCK?
		134217728 : "134,217,728: DMG_MELEE"
		268435456 : "268,435,456: DMG_DIRECT"
		536870912 : "536,870,912: DMG_BUCKSHOT"
	] // end damagetype
] // end SDamageTypes

@BaseClass = SDispenserTrigger [
	touch_trigger(target_destination) : "Custom Touch Trigger" :  : "dispenser_touch_trigger entity to use instead as the healing/dispensing zone, optionally. On player-built dispensers, this keyvalue binds when the dispenser finishes its level 1 building/redeploying animation. If this dispenser has an owner or is assigned one, this trigger will be teleported to the dispenser and downscaled (but cannot be upscaled!) to the dispenser's default range. By default, the dispenser's healing zone is a cube with 128HU-long sides, but player attributes can change this."

	spawnflags(flags) = [
		4 : "Ignore line of sight check" : 1
		//8 : "Don't heal disguised/stealthed spies - Doesn't work" : 1
	] // end spawnflags
] // end SDispenserTrigger
@BaseClass = SDispenserTriggerDefault [
	helper_trigger_mins(vector) readonly : "Default Trigger (Display Only)" : "-64 -64 -64" : "DO NOT CHANGE. Keyvalue to display the size of the default touch trigger for map-placed dispensers. Note that due to coding errors, the position of the default trigger for player-placed dispensers is actually 27.5HU higher than for map-placed dispensers. If a player-placed dispenser is moved, its dispenser trigger position will line up with that of a map-placed dispenser."
	helper_trigger_maxs(vector) readonly : "Default Trigger (Display Only)" : "64 64 64" : "DO NOT CHANGE. Keyvalue to display the size of the default touch trigger for map-placed dispensers. Note that due to coding errors, the position of the default trigger for player-placed dispensers is actually 27.5HU higher than for map-placed dispensers. If a player-placed dispenser is moved, its dispenser trigger position will line up with that of a map-placed dispenser."
] // end SDispenserTriggerDefault

@BaseClass = SEnableDisable [
	StartDisabled(choices) : "Start Disabled?" : 0 : "Stay dormant until activated with the Enable input." = [
		0 : "No"
		1 : "Yes"
	] // end StartDisabled

	input Disable(void) : "Disable this entity."
	input Enable(void) : "Enable this entity."
] // end SEnableDisable

@BaseClass = SGlobalStates [
	// Only is_console, is_pc, and skill.cfg exist in tf2 code (determined with console command dump_globals)
	globalstate(choices) : "Global State" : "" : "The global state this entity is linked to. Some or all states may not function. Custom states may also be typed." = [
		"" : "None"
		//"gordon_precriminal" : "Gordon pre-criminal"
		//"antlion_allied" : "Antlions are player allies"
		//"player_stealth" : "Player in APC is disguised as combine (unused)"
		//"suit_no_sprint" : "Suit sprint function not yet enabled"
		//"super_phys_gun" : "Super phys gun is enabled"
		//"friendly_encounter" : "Friendly encounter sequence (lower weapons, etc.)"
		//"citizens_passive" : "Citizens are *not* player allies (cannot be commanded)"
		//"gordon_invulnerable" : "Gordon is invulnerable"
		//"no_seagulls_on_jeep" : "Don't spawn seagulls on the jeep"
		//"ep2_alyx_injured" : "Episode 2: Alyx injured"
		//"ep_alyx_darknessmode" : "Episodic: Alyx darkness mode"
		//"hunters_to_run_over" : "Episode 2 Counter: Hunters to run over before they dodge"
		"is_console" : "is_console - Game is running on console?"
		"is_pc" : "is_pc - Game is running on PC?"
		"skill.cfg" : "skill.cfg - Does nothing."
	] // end globalstate
] // end SGlobalStates

@BaseClass = SHealth [
	health(integer) : "Health" : 100 : "Amount of damage this entity can take before dying, breaking, or opening."

	input SetHealth(integer) : "Sets the entity's health by dealing damage to it. The amount of damage dealt is the difference between the entity's former health and the parameter passed to this input. The damage amount may be modified by damage resistances and/or vulnerabilities on the target."
] // end SHealth
@BaseClass = SHealthMax [
	max_health(integer) : "Max Health" : 100 : "Maximum health of this entity. This entity's health cannot exceed this value."
] // end SHealthMax

// Some entities that inherit dynamic model stuff override the skin/bodygroup/etc keyvalues on spawn, so inherit those separately. Generally these can be left out on any entity that has a hardcoded model with no override
@BaseClass = SModelBodyGroup [
	body(integer) : "Body Group" : 0 : "Sets the body group index for the model, starting with 0, if available."
	hitboxset(string) : "Hitbox Set" :  : "Sets the $hboxset to use for collision testing."
	texframeindex(integer) : "ToggleTexture Frame" :  : "The starting frame number for any ToggleTexture materials on this entity. This keyvalue can be changed with AddOutput as an alternative to using env_texturetoggle, but there will be a slight delay before the texture changes. Does not work with materials lacking the ToggleTexture proxy."
] // end SModelBodyGroup
@BaseClass = SModelSkin [
	skin(integer) : "Skin" : 0 : "Some models have multiple skins. This value selects the index of the skin to use on the model, starting with 0." // TODO: No such keyvalue is defined in CBaseAnimating, but the identically-named input is defined. ...Can inputs be used as keyvalues which end up being "fired" on map load? Is that what happens whenever this keyvalue is used? ........Can we do that with other inputs?
] // end SModelSkin

// Some things (such as item_teamflag) inherit prop_dynamic's inputs and outputs, but not its keyvalues (or if it does inherit the keyvalues, they dont work, so same difference :shrug:)
@BaseClass = SPropDynamicIO [
	input SetAnimation(string) : "Force the prop to play an animation. The parameter should be the name of the animation."
	input SetDefaultAnimation(string) : "Set the Default Animation to the one specified in the parameter."
	input SetPlaybackRate(float) : "Set the playback rate for the animation."
	output OnAnimationBegun(void) : "Fired whenever a new animation has begun playing."
	output OnAnimationDone(void) : "Fired whenever an animation is complete."

	input TurnOff(void) : "Make the prop invisible."
	input TurnOn(void) : "Make the prop visible."
	input DisableCollision(void) : "Disable collision on the prop."
	input EnableCollision(void) : "Enable collision on the prop."
] // end SPropDynamicIO

@BaseClass = SResetDelay [
	wait(integer) : "Delay Before Reset" : -1 : "Amount of time, in seconds, after the entity has reached its open/pressed position before it begins returning to the closed/unpressed position. Once it has closed, it can be opened/pressed again. If the value is set to -1, the entity never closes itself."
] // end SResetDelay

@BaseClass = SRotateDistance [
	distance(integer) : "Distance" : 90 : "The distance, in degrees, that the entity should rotate."
] // end SRotateDistance

@BaseClass = SSolidBSP [
	solidbsp(choices) : "Solid Type" : 0 : "How to calculate collisions. BSP is more rudimentarty but allows more stable collision with players." = [
		0 : "VPhysics"
		1 : "BSP"
	] // end solidbsp
] // end SSolidBSP

// Up to date as of 12/28/2020 - TODO-BROKK: Update dis
@BaseClass = SSoundscapes [
	soundscape(choices) : "Soundscape" : "tf2.general_ambient" : "The name of the soundscape to use. Corresponds to an entry in a soundscapes*.txt file in the scripts directory. A list of official soundscapes is provided; custom soundscapes can also be typed, but must first be specified in a /tf/scripts/soundscapes_<mapname>.txt file. developer.valvesoftware.com/wiki/Team_Fortress_2/Soundscapes" = [
		"2fort.Indoor" : "2fort.Indoor"
		"2fort.OutdoorFort" : "2fort.OutdoorFort"
		"2fort.OutdoorPond" : "2fort.OutdoorPond"
		"2fort.Underground" : "2fort.Underground"
		"2fort.Underground2" : "2fort.Underground2"
		"Badlands.Inside" : "Badlands.Inside"
		"Badlands.Outside" : "Badlands.Outside"
		"Badlands.OutsideInterior" : "Badlands.OutsideInterior"
		"barnblitz.inside" : "barnblitz.inside"
		"barnblitz.outside" : "barnblitz.outside"
		"CactusV.Inside" : "CactusV.Inside (Decoy/Bigrock)"
		"CactusV.Outside" : "CactusV.Outside (Decoy/Bigrock)"
		"CactusV.RespawnA" : "CactusV.RespawnA (Decoy)"
		"CactusV.RespawnB" : "CactusV.RespawnB (Decoy/Bigrock)"
		"Chariots.Inside" : "Chariots.Inside (Pipeline)"
		"Chariots.Outside" : "Chariots.Outside (Pipeline)"
		"Deathpit.Inside" : "Deathpit.Inside (Coaltown)"
		"Deathpit.Outside" : "Deathpit.Outside (Coaltown)"
		"Deathpit.RespawnA" : "Deathpit.RespawnA (Coaltown)"
		"Deathpit.RespawnB" : "Deathpit.RespawnB (Coaltown)"
		"DoubleCross.Inside" : "DoubleCross.Inside"
		"DoubleCross.Outside" : "DoubleCross.Outside"
		"Dustbowl.Indoors" : "Dustbowl.Indoors"
		"Dustbowl.Outdoors" : "Dustbowl.Outdoors"
		"Egypt.Indoor" : "Egypt.Indoor"
		"Egypt.Outdoor" : "Egypt.Outdoor"
		"Goldrush.DeepInside" : "Goldrush.DeepInside"
		"Goldrush.Inside" : "Goldrush.Inside"
		"Goldrush.Outside" : "Goldrush.Outside"
		"Gorge.Inside" : "Gorge.Inside"
		"Gorge.Outside" : "Gorge.Outside"
		"Granary.Inside" : "Granary.Inside"
		"Granary.Outside" : "Granary.Outside"
		"GravelPit.Inside" : "GravelPit.Inside"
		"GravelPit.Outside" : "GravelPit.Outside"
		"Halloween.hell" : "Halloween.hell (Helltower)"
		"Halloween.Inside" : "Halloween.Inside (Mann Manor/Helltower)"
		"Halloween.Outside" : "Halloween.Outside (Mann Manor/Helltower)"
		"Halloween.Underworld" : "Halloween.Underworld (Eyeaduct)"
		"Halloween_sf14.Inside" : "Halloween_sf14.Inside (Carnival of Carnage)"
		"Halloween_sf14.Outside" : "Halloween_sf14.Outside (Carnival of Carnage)"
		"harbor.indoor_blue_fuel" : "harbor.indoor_blue_fuel (Foundry)"
		"harbor.indoor_red_fuel" : "harbor.indoor_red_fuel (Foundry)"
		"harbor.inside_blue_ex_01" : "harbor.inside_blue_ex_01 (Foundry)"
		"harbor.inside_blue_ex_02" : "harbor.inside_blue_ex_02 (Foundry)"
		"harbor.inside_blue_ex_03" : "harbor.inside_blue_ex_03 (Foundry)"
		"harbor.inside_blue_hq" : "harbor.inside_blue_hq (Foundry)"
		"harbor.inside_blue_spawn_01" : "harbor.inside_blue_spawn_01 (Foundry)"
		"harbor.inside_blue_spawn_02" : "harbor.inside_blue_spawn_02 (Foundry)"
		"harbor.inside_blue_spawn_03" : "harbor.inside_blue_spawn_03 (Foundry)"
		"harbor.inside_red_ex_01" : "harbor.inside_red_ex_01 (Foundry)"
		"harbor.inside_red_ex_02" : "harbor.inside_red_ex_02 (Foundry)"
		"harbor.inside_red_ex_03" : "harbor.inside_red_ex_03 (Foundry)"
		"harbor.inside_red_hq" : "harbor.inside_red_hq (Foundry)"
		"harbor.inside_red_spawn_01" : "harbor.inside_red_spawn_01 (Foundry)"
		"harbor.inside_red_spawn_02" : "harbor.inside_red_spawn_02 (Foundry)"
		"harbor.inside_red_spawn_03" : "harbor.inside_red_spawn_03 (Foundry)"
		"harbor.outdoor_blue" : "harbor.outdoor_blue (Foundry)"
		"harbor.outdoor_central" : "harbor.outdoor_central (Foundry)"
		"harbor.outdoor_red" : "harbor.outdoor_red (Foundry)"
		"Hellfire.Inside" : "Hellfire.Inside"
		"Hellfire.Outside" : "Hellfire.Outside"
		"Hellfire.OutsideCovered" : "Hellfire.OutsideCovered"
		"HighTower.Inside" : "HighTower.Inside"
		"HighTower.Outside" : "HighTower.Outside"
		"Hydro.Inside" : "Hydro.Inside"
		"Hydro.Outside" : "Hydro.Outside"
		"Lair.Cap1" : "Lair.Cap1 (Mercenary Park)"
		"Lair.Cap1Cap2Transition" : "Lair.Cap1Cap2Transition (Mercenary Park)"
		"Lair.Cap1SpawnBlue" : "Lair.Cap1SpawnBlue (Mercenary Park)"
		"Lair.Cap1Underground" : "Lair.Cap1Underground (Mercenary Park)"
		"Lair.Cap2" : "Lair.Cap2 (Mercenary Park)"
		"Lair.Cap2SpawnBlue" : "Lair.Cap2SpawnBlue (Mercenary Park)"
		"Lair.Cap2SpawnRed" : "Lair.Cap2SpawnRed (Mercenary Park)"
		"Lair.Cap3" : "Lair.Cap3 (Mercenary Park)"
		"Lair.Cap3Duct" : "Lair.Cap3Duct (Mercenary Park)"
		"Lair.Cap3Inside" : "Lair.Cap3Inside (Mercenary Park)"
		"Lair.Cap3SpawnRed" : "Lair.Cap3SpawnRed (Mercenary Park)"
		"Lair.Cap3Vista" : "Lair.Cap3Vista (Mercenary Park)"
		"Lair.Jungle" : "Lair.Jungle (Mercenary Park)"
		"Lair.JungleCap1InteriorTransition" : "Lair.JungleCap1InteriorTransition (Mercenary Park)"
		"Lair.JungleLight" : "Lair.JungleLight (Mercenary Park)"
		"Lair.JungleUnderGround" : "Lair.JungleUnderGround (Mercenary Park)"
		"Lair.JungleUndergroundLightJungle" : "Lair.JungleUndergroundLightJungle (Mercenary Park)"
		"Lair.VisitorsCenterSpawnBlue" : "Lair.VisitorsCenterSpawnBlue (Mercenary Park)"
		"Lair.VisitorsCenterSpawnBlueLightJungle" : "Lair.VisitorsCenterSpawnBlueLightJungle (Mercenary Park)"
		"Lakeside.Cave" : "Lakeside.Cave"
		"Lakeside.Inside" : "Lakeside.Inside"
		"Lakeside.Inside_blu" : "Lakeside.Inside_blu"
		"Lakeside.Lake" : "Lakeside.Lake"
		"Lakeside.Outside" : "Lakeside.Outside"
		"Lakeside.Temple" : "Lakeside.Temple"
		"Lakeside.Wood" : "Lakeside.Wood"
		"Lumberyard.Inside" : "Lumberyard.Inside"
		"Lumberyard.Outside" : "Lumberyard.Outside"
		"Mannworks.InsideCellars" : "Mannworks.InsideCellars"
		"Mannworks.InsideWood" : "Mannworks.InsideWood"
		"Mannworks.Outside" : "Mannworks.Outside"
		"Mannworks.Respawn" : "Mannworks.Respawn"
		"Medieval.Inside" : "Medieval.Inside (Degroot Keep)"
		"Medieval.Outside" : "Medieval.Outside (Degroot Keep)"
		"Moonbase.Outerspace" : "Moonbase.Outerspace (Asteroid)"
		"Moonbase.Underground" : "Moonbase.Underground (Asteroid)"
		"mountainlab.Bluspawn" : "mountainlab.Bluspawn"
		"mountainlab.Cpoint" : "mountainlab.Cpoint"
		"mountainlab.entrance" : "mountainlab.entrance"
		"mountainlab.Inside" : "mountainlab.Inside"
		"mountainlab.Outside1" : "mountainlab.Outside1"
		"mountainlab.Outside2" : "mountainlab.Outside2"
		"mountainlab.Outside3" : "mountainlab.Outside3"
		"Nightfall.Cavern" : "Nightfall.Cavern"
		"Nightfall.Indoors" : "Nightfall.Indoors"
		"Nightfall.Outdoors" : "Nightfall.Outdoors"
		"Nucleus.Inside" : "Nucleus.Inside"
		"Nucleus.Outside" : "Nucleus.Outside"
		"Powerhouse.Inside" : "Powerhouse.Inside"
		"Powerhouse.InsideBlue" : "Powerhouse.InsideBlue"
		"Powerhouse.InsideRed" : "Powerhouse.InsideRed"
		"Powerhouse.Outside" : "Powerhouse.Outside"
		"Powerhouse.Transition" : "Powerhouse.Transition"
		"Ravine.Inside" : "Ravine.Inside"
		"Ravine.Outside" : "Ravine.Outside"
		"Rottenburg.Alcove" : "Rottenburg.Alcove"
		"Rottenburg.Clearing" : "Rottenburg.Clearing"
		"Rottenburg.Spawn" : "Rottenburg.Spawn"
		"Rottenburg.Town" : "Rottenburg.Town"
		"Sawmill.DeepInside" : "Sawmill.DeepInside"
		"Sawmill.Inside" : "Sawmill.Inside"
		"Sawmill.InsideNoLights" : "Sawmill.InsideNoLights"
		"Sawmill.InsideWaterfall" : "Sawmill.InsideWaterfall"
		"Sawmill.Outside" : "Sawmill.Outside"
		"soho_generic" : "soho_generic (Kong King)"
		"soho_indoor" : "soho_indoor (Kong King)"
		"soho_square" : "soho_square (Kong King)"
		"stormfront.Outside" : "stormfront.Outside (Coldfront)"
		"stormfront.Underground" : "stormfront.Underground (Coldfront)"
		"tf2.general_ambient" : "tf2.general_ambient"
		"tf2.respawn_room" : "tf2.respawn_room"
		"ThunderMountain.Inside" : "ThunderMountain.Inside"
		"ThunderMountain.Outside" : "ThunderMountain.Outside"
		"underground_soho" : "underground_soho (Kong King)"
		"Upward.Inside" : "Upward.Inside"
		"Upward.Outside" : "Upward.Outside"
		"viaduct.Inside" : "viaduct.Inside"
		"Viaduct.Outside" : "Viaduct.Outside"
		"warehouse.inside_boilers" : "warehouse.inside_boilers (Mannhattan)"
		"warehouse.inside_mainhall" : "warehouse.inside_mainhall (Mannhattan)"
		"warehouse.inside_spawn_foyer" : "warehouse.inside_spawn_foyer (Mannhattan)"
		"warehouse.inside_spawn_int" : "warehouse.inside_spawn_int (Mannhattan)"
		"warehouse.outside" : "warehouse.outside (Mannhattan)"
		"Well.DeepInside" : "Well.DeepInside"
		"Well.Inside" : "Well.Inside"
		"Well.Outside" : "Well.Outside"
	] // end soundscape
	radius(integer) : "Radius" : 128 : "Defines the entity's sphere of influence. Players must also be able to see the entity for it to trigger. -1 means infinite range."
	position0(target_destination) : "Sound Position 0" :  : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position1(target_destination) : "Sound Position 1" :  : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position2(target_destination) : "Sound Position 2" :  : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position3(target_destination) : "Sound Position 3" :  : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position4(target_destination) : "Sound Position 4" :  : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position5(target_destination) : "Sound Position 5" :  : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position6(target_destination) : "Sound Position 6" :  : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position7(target_destination) : "Sound Position 7" :  : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."

	input Enable(void) : "Enable the soundscape."
	input Disabled(void) : "Disable the soundscape."
	input ToggleEnabled(void) : "Toggle the soundscape enabled state."

	output OnPlay(void) : "Fired when this soundscape becomes the active one."
] // end SSoundscapes

@BaseClass = SSpeed [
	speed(float) : "Speed" : 100 : "The speed at which this entity moves, either in HU/sec or degrees/sec."
] // end SSpeed

@BaseClass = SStartStopSounds [
	noise1(sound) : "Start Sound" :  : "Sound to play when the entity moves."
	noise2(sound) : "Stop Sound" :  : "Sound to play when the entity stops moving."
] // end SStartStopSounds

@BaseClass = STFConditions [
	condition(choices) : "Condition" : -1 : "The player condition to use. See wiki.teamfortress.com/wiki/Cheats#addcond for a list and description of each." = [
		-1 : "-1 - TF_COND_INVALID"
		0 : "0 - TF_COND_AIMING"
		1 : "1 - TF_COND_ZOOMED"
		2 : "2 - TF_COND_DISGUISING"
		3 : "3 - TF_COND_DISGUISED"
		4 : "4 - TF_COND_STEALTHED"
		5 : "5 - TF_COND_INVULNERABLE"
		6 : "6 - TF_COND_TELEPORTED"
		7 : "7 - TF_COND_TAUNTING"
		8 : "8 - TF_COND_INVULNERABLE_WEARINGOFF"
		9 : "9 - TF_COND_STEALTHED_BLINK"
		10 : "10 - TF_COND_SELECTED_TO_TELEPORT"
		11 : "11 - TF_COND_CRITBOOSTED"
		12 : "12 - TF_COND_TMPDAMAGEBONUS"
		13 : "13 - TF_COND_FEIGN_DEATH"
		14 : "14 - TF_COND_PHASE"
		15 : "15 - TF_COND_STUNNED"
		16 : "16 - TF_COND_OFFENSEBUFF"
		17 : "17 - TF_COND_SHIELD_CHARGE"
		18 : "18 - TF_COND_DEMO_BUFF"
		19 : "19 - TF_COND_ENERGY_BUFF"
		20 : "20 - TF_COND_RADIUSHEAL"
		21 : "21 - TF_COND_HEALTH_BUFF"
		22 : "22 - TF_COND_BURNING"
		23 : "23 - TF_COND_HEALTH_OVERHEALED"
		24 : "24 - TF_COND_URINE"
		25 : "25 - TF_COND_BLEEDING"
		26 : "26 - TF_COND_DEFENSEBUFF"
		27 : "27 - TF_COND_MAD_MILK"
		28 : "28 - TF_COND_MEGAHEAL"
		29 : "29 - TF_COND_REGENONDAMAGEBUFF"
		30 : "30 - TF_COND_MARKEDFORDEATH"
		31 : "31 - TF_COND_NOHEALINGDAMAGEBUFF"
		32 : "32 - TF_COND_SPEED_BOOST"
		33 : "33 - TF_COND_CRITBOOSTED_PUMPKIN"
		34 : "34 - TF_COND_CRITBOOSTED_USER_BUFF"
		35 : "35 - TF_COND_CRITBOOSTED_DEMO_CHARGE"
		36 : "36 - TF_COND_SODAPOPPER_HYPE"
		37 : "37 - TF_COND_CRITBOOSTED_FIRST_BLOOD"
		38 : "38 - TF_COND_CRITBOOSTED_BONUS_TIME"
		39 : "39 - TF_COND_CRITBOOSTED_CTF_CAPTURE"
		40 : "40 - TF_COND_CRITBOOSTED_ON_KILL"
		41 : "41 - TF_COND_CANNOT_SWITCH_FROM_MELEE"
		42 : "42 - TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK"
		43 : "43 - TF_COND_REPROGRAMMED"
		44 : "44 - TF_COND_CRITBOOSTED_RAGE_BUFF"
		45 : "45 - TF_COND_DEFENSEBUFF_HIGH"
		46 : "46 - TF_COND_SNIPERCHARGE_RAGE_BUFF"
		47 : "47 - TF_COND_DISGUISE_WEARINGOFF"
		48 : "48 - TF_COND_MARKEDFORDEATH_SILENT"
		49 : "49 - TF_COND_DISGUISED_AS_DISPENSER"
		50 : "50 - TF_COND_SAPPED"
		51 : "51 - TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED"
		52 : "52 - TF_COND_INVULNERABLE_USER_BUFF"
		53 : "53 - TF_COND_HALLOWEEN_BOMB_HEAD"
		54 : "54 - TF_COND_HALLOWEEN_THRILLER"
		55 : "55 - TF_COND_RADIUSHEAL_ON_DAMAGE"
		56 : "56 - TF_COND_CRITBOOSTED_CARD_EFFECT"
		57 : "57 - TF_COND_INVULNERABLE_CARD_EFFECT"
		58 : "58 - TF_COND_MEDIGUN_UBER_BULLET_RESIST"
		59 : "59 - TF_COND_MEDIGUN_UBER_BLAST_RESIST"
		60 : "60 - TF_COND_MEDIGUN_UBER_FIRE_RESIST"
		61 : "61 - TF_COND_MEDIGUN_SMALL_BULLET_RESIST"
		62 : "62 - TF_COND_MEDIGUN_SMALL_BLAST_RESIST"
		63 : "63 - TF_COND_MEDIGUN_SMALL_FIRE_RESIST"
		64 : "64 - TF_COND_STEALTHED_USER_BUFF"
		65 : "65 - TF_COND_MEDIGUN_DEBUFF"
		66 : "66 - TF_COND_STEALTHED_USER_BUFF_FADING"
		67 : "67 - TF_COND_BULLET_IMMUNE"
		68 : "68 - TF_COND_BLAST_IMMUNE"
		69 : "69 - TF_COND_FIRE_IMMUNE"
		70 : "70 - TF_COND_PREVENT_DEATH"
		71 : "71 - TF_COND_MVM_BOT_STUN_RADIOWAVE"
		72 : "72 - TF_COND_HALLOWEEN_SPEED_BOOST"
		73 : "73 - TF_COND_HALLOWEEN_QUICK_HEAL"
		74 : "74 - TF_COND_HALLOWEEN_GIANT"
		75 : "75 - TF_COND_HALLOWEEN_TINY"
		76 : "76 - TF_COND_HALLOWEEN_IN_HELL"
		77 : "77 - TF_COND_HALLOWEEN_GHOST_MODE"
		78 : "78 - TF_COND_MINICRITBOOSTED_ON_KILL"
		79 : "79 - TF_COND_OBSCURED_SMOKE"
		80 : "80 - TF_COND_PARACHUTE_ACTIVE"
		81 : "81 - TF_COND_BLASTJUMPING"
		82 : "82 - TF_COND_HALLOWEEN_KART"
		83 : "83 - TF_COND_HALLOWEEN_KART_DASH"
		84 : "84 - TF_COND_BALLOON_HEAD"
		85 : "85 - TF_COND_MELEE_ONLY"
		86 : "86 - TF_COND_SWIMMING_CURSE"
		87 : "87 - TF_COND_FREEZE_INPUT"
		88 : "88 - TF_COND_HALLOWEEN_KART_CAGE"
		89 : "89 - TF_COND_DONOTUSE_0"
		90 : "90 - TF_COND_RUNE_STRENGTH"
		91 : "91 - TF_COND_RUNE_HASTE"
		92 : "92 - TF_COND_RUNE_REGEN"
		93 : "93 - TF_COND_RUNE_RESIST"
		94 : "94 - TF_COND_RUNE_VAMPIRE"
		95 : "95 - TF_COND_RUNE_REFLECT"
		96 : "96 - TF_COND_RUNE_PRECISION"
		97 : "97 - TF_COND_RUNE_AGILITY"
		98 : "98 - TF_COND_GRAPPLINGHOOK"
		99 : "99 - TF_COND_GRAPPLINGHOOK_SAFEFALL"
		100 : "100 - TF_COND_GRAPPLINGHOOK_LATCHED"
		101 : "101 - TF_COND_GRAPPLINGHOOK_BLEEDING"
		102 : "102 - TF_COND_AFTERBURN_IMMUNE"
		103 : "103 - TF_COND_RUNE_KNOCKOUT"
		104 : "104 - TF_COND_RUNE_IMBALANCE"
		105 : "105 - TF_COND_CRITBOOSTED_RUNE_TEMP"
		106 : "106 - TF_COND_PASSTIME_INTERACTION"
		107 : "107 - TF_COND_SWIMMING_NO_EFFECTS"
		108 : "108 - TF_COND_PURGATORY"
		109 : "109 - TF_COND_RUNE_KING"
		110 : "110 - TF_COND_RUNE_PLAGUE"
		111 : "111 - TF_COND_RUNE_SUPERNOVA"
		112 : "112 - TF_COND_PLAGUE"
		113 : "113 - TF_COND_KING_BUFFED"
		114 : "114 - TF_COND_TEAM_GLOWS"
		115 : "115 - TF_COND_KNOCKED_INTO_AIR"
		116 : "116 - TF_COND_COMPETITIVE_WINNER"
		117 : "117 - TF_COND_COMPETITIVE_LOSER"
		118 : "118 - TF_COND_HEALING_DEBUFF"
		119 : "119 - TF_COND_PASSTIME_PENALTY_DEBUFF"
		120 : "120 - TF_COND_GRAPPLED_TO_PLAYER"
		121 : "121 - TF_COND_GRAPPLED_BY_PLAYER"
		122 : "122 - TF_COND_PARACHUTE_DEPLOYED"
		123 : "123 - TF_COND_GAS"
		124 : "124 - TF_COND_BURNING_PYRO"
		125 : "125 - TF_COND_ROCKETPACK"
		126 : "126 - TF_COND_LOST_FOOTING"
		127 : "127 - TF_COND_AIR_CURRENT"
		128 : "128 - TF_COND_HALLOWEEN_HELL_HEAL"
	] // end condition
] // end STFConditions

@BaseClass = STFTeam [
	// TODO: Are 1 and 5 any use at all?
	TeamNum(choices) : "Team" : 0 : "Team of the entity. May or may not change the entity's appearance." = [
		0 : "0 - Any/Unassigned"
		1 : "1 - Spectator"
		2 : "2 - RED"
		3 : "3 - BLU"
		5 : "5 - Neutral/Boss"
	] // end TeamNum

	input SetTeam(integer) : "Changes the entity's team. Does not change the entity's appearance!"
	input TeamNum(integer) : "Changes the entity's team, identical to SetTeam. Does not change the entity's appearance!"
] // end STFTeam

// Hey, if Valve can create a base entity class in code exclusively for the toggle input, then so can I dammit!
// Beautiful. -Brokk
@BaseClass = SToggle [
	input Toggle(void) : "Toggle this entity's state."
] // end SToggle



	// INCOMPLETE PARTS //
// Collections of related keyvalues that don't form a full "section" of related keyvalues (doesn't have a divider)

@BaseClass base(SHealth, SSpeed, STFTeam) = SBoss [
	health(integer) : "Health" : 10000 : "Amount of damage this entity can take before dying, breaking, or opening. This value cannot exceed the entity's Max Health keyvalue, if it has such."

	input AddHealth(integer) : "Add health to this entity."
	input RemoveHealth(integer) : "Remove health from this entity."
	input SetMaxHealth(integer) : "Set this entity's maximum health."
	input SetSpeed(float) : "Change the speed of the entity."

	output OnHealthBelow10Percent(void) : "Sent when the entity's health drops below 10 percent."
	output OnHealthBelow20Percent(void) : "Sent when the entity's health drops below 20 percent."
	output OnHealthBelow30Percent(void) : "Sent when the entity's health drops below 30 percent."
	output OnHealthBelow40Percent(void) : "Sent when the entity's health drops below 40 percent."
	output OnHealthBelow50Percent(void) : "Sent when the entity's health drops below 50 percent."
	output OnHealthBelow60Percent(void) : "Sent when the entity's health drops below 60 percent."
	output OnHealthBelow70Percent(void) : "Sent when the entity's health drops below 70 percent."
	output OnHealthBelow80Percent(void) : "Sent when the entity's health drops below 80 percent."
	output OnHealthBelow90Percent(void) : "Sent when the entity's health drops below 90 percent."
	output OnKilled(void) : "Sent when the entity is killed."
] // end SBoss

// Door health does not function in TF2
@BaseClass base(SSpeed) = SDoor [
	spawnpos(choices) : "Spawn Position" : 0 : "Set which position the door will spawn in. The door's position in Hammer will always be considered the closed position; if set as 'Open' here, the door will teleport to that position when the map loads." = [
		0 : "Closed"
		1 : "Open"
	] // end spawnpos
	dmg(integer) : "Blocking Damage" :  : "Amount of damage done to entities that block the movement of this entity, per frame. May be buggy."
	forceclosed(choices) : "Force Closed?" : 0 : "If set, this door will ignore any attempts to block it while it is closing. Useful for doors that have to close even if the player tries to block them with objects." = [
		0 : "No"
		1 : "Yes"
	] // end forceclosed

	input Close(void) : "Close the door, if it is not fully closed."
	input Lock(void) : "Lock the door. While locked, the door cannot be opened by any means (but can be closed)."
	input Open(void) : "Open the door, if it is not fully open."
	input SetSpeed(float) : "Set the door speed."
	input Toggle(void) : "Toggle the door between open and closed."
	input Unlock(void) : "Unlock the door."

	output OnBlockedClosing(void) : "Fired when the door is blocked while closing."
	output OnBlockedOpening(void) : "Fired when the door is blocked while opening."
	output OnClose(void) : "Fired when the door is told to close."
	output OnFullyClosed(void) : "Fired when the door reaches the fully closed position."
	output OnFullyOpen(void) : "Fired when the door reaches the fully open position."
	output OnLockedUse(void) : "Fired when the player uses the door, but it is locked."
	output OnOpen(void) : "Fired when the door is told to open."
	output OnUnblockedClosing(void) : "Fired when the door is unblocked while closing."
	output OnUnblockedOpening(void) : "Fired when the door is unblocked while opening."
] // end SDoor

@BaseClass base(STFTeam) = SEngieBuilding [
	parentname(target_destination) : "Parent" :  : "Specifies a movement parent. An entity will mimic the movements of its parent, maintaining its initial offset from the parent. An attachment point can optionally be added to the end of the name, separated by a comma. BUG: If an engineer building is the child of a moving entity using VPhysics collisions (ie func_movelinear), the moving entity may move slower than usual."

	defaultupgrade(choices) : "Starting Upgrade Level" : 0 : "Starting upgrade level of the object. With higher levels, the object gains more health/damage/recharge speed. Dispenser levels beyond 3 will not dispense health or ammunition (but will generate and dispense metal at increasing rates). Engineers cannot upgrade the object past level 3, but any level up to 91 can be forced." = [
		0 : "Level 1"
		1 : "Level 2"
		2 : "Level 3"
		3 : "Level 4"
		4 : "Level 5"
		5 : "Level 6"
		6 : "Level 7"
		7 : "Level 8"
		8 : "Level 9"
		9 : "Level 10"
		10 : "Level 11"
		11 : "Level 12"
		12 : "Level 13"
		13 : "Level 14"
		14 : "Level 15"
		15 : "Level 16"
		16 : "Level 17"
		17 : "Level 18"
		18 : "Level 19"
		19 : "Level 20"
		20 : "Level 21"
		21 : "Level 22"
		22 : "Level 23"
		23 : "Level 24"
		24 : "Level 25"
		25 : "Level 26"
		26 : "Level 27"
		27 : "Level 28"
		28 : "Level 29"
		29 : "Level 30"
		30 : "Level 31"
		31 : "Level 32"
		32 : "Level 33"
		33 : "Level 34"
		34 : "Level 35"
		35 : "Level 36"
		36 : "Level 37"
		37 : "Level 38"
		38 : "Level 39"
		39 : "Level 40"
		40 : "Level 41"
		41 : "Level 42"
		42 : "Level 43"
		43 : "Level 44"
		44 : "Level 45"
		45 : "Level 46"
		46 : "Level 47"
		47 : "Level 48"
		48 : "Level 49"
		49 : "Level 50"
		50 : "Level 51"
		51 : "Level 52"
		52 : "Level 53"
		53 : "Level 54"
		54 : "Level 55"
		55 : "Level 56"
		56 : "Level 57"
		57 : "Level 58"
		58 : "Level 59"
		59 : "Level 60"
		60 : "Level 61"
		61 : "Level 62"
		62 : "Level 63"
		63 : "Level 64"
		64 : "Level 65"
		65 : "Level 66"
		66 : "Level 67"
		67 : "Level 68"
		68 : "Level 69"
		69 : "Level 70"
		70 : "Level 71"
		71 : "Level 72"
		72 : "Level 73"
		73 : "Level 74"
		74 : "Level 75"
		75 : "Level 76"
		76 : "Level 77"
		77 : "Level 78"
		78 : "Level 79"
		79 : "Level 80"
		80 : "Level 81"
		81 : "Level 82"
		82 : "Level 83"
		83 : "Level 84"
		84 : "Level 85"
		85 : "Level 86"
		86 : "Level 87"
		87 : "Level 88"
		88 : "Level 89"
		89 : "Level 90"
		90 : "Level 91"
	] // end defaultupgrade

	spawnflags(flags) = [
		2 : "Invulnerable (Can still be sapped)" : 0 // Doesn't work on dispensers, luckily due to how hammer treats spawnflag inheritance this is hidden by SDispenserTrigger baseclass
	] // end spawnflags

	input AddHealth(integer) : "Increase the current health of the object. Cannot surpass maximum health. Does not destroy the object if set at 0."
	input Disable(void) : "Disables the object."
	input Enable(void) : "Enables the object."
	input Hide(void) : "Makes the object invisible and disables it."
	input SetBuilder(target_destination) : "Sets the builder of this object, if this object does not already have a builder. Works with !activator. The object will function exactly as if the builder had constructed the object themselves with their build PDA. If the builder is an engineer, the builder will be able to pick up, move, and destroy the object, and the object's status will appear on the builder's HUD (unless the builder already has an object of this type). The object will be updated to match the team of the builder (although its appearance will not change). A player can be a builder of multiple objects of the same type, although they all must be destroyed before the player can build another using their build PDA."
	input SetHealth(integer) : "Sets the current and maximum health."
	input SetSolidToPlayer(bool) : "Sets whether the object to be solid or non-solid to allies. 0 = non-solid, 1 = solid."
	input Show(void) : "Makes the object visible and re-enables it."
	input RemoveHealth(integer) : "Decrease current health of the object. Destroys the object if the health hits 0."

	output OnDamaged(void) : "Sent when hurt."
	output OnDestroyed(void) : "Sent when object dies."
	output OnDisabled(void) : "Sent when disabled."
	output OnObjectHealthChanged(integer) : "Sends current health as a parameter whenever a change occurs."
	output OnReenabled (void) : "Sent when enabled."
	output OnRepaired(void) : "Sent when repaired."
] // end SEngieBuilding

// Not all entities that inherit from SModelDynamic use these (ie item_teamflag); when inherited, merge this section below SModelDynamic
@BaseClass = SModelLighting [
	disableshadows(choices) : "Disable Shadows?" : 0 : "Prevent the entity from casting cheap render-to-texture shadows." = [
		0 : "No"
		1 : "Yes"
	] // end disableshadows
	shadowcastdist(integer) : "Shadow Cast Distance" :  : "Sets how far the entity casts dynamic shadows, in units. 0 means default distance in the shadow_control entity."
	LightingOrigin(target_destination) : "Lighting Origin" :  : "If specified, lighting will be sampled from the specified entity's origin instead of this model's origin, and constantly re-updated if the target ever moves. This does not disable vertex lighting on the model."
	//LightingOriginHack(target_destination) : "Lighting Origin Offset" :  : "The info_lighting_relative from which to sample lighting instead of the entity's origin." // Literally does not work in tf2
] // SModelLighting

@BaseClass = SVelocity [
	velocity(vector) : "Local Velocity" :  : "Velocity generated by the entity, can cause strange behavior if changed with AddOutput."
	basevelocity(vector) : "Base Velocity" :  : "Velocity to start with on spawn. Can be changed with AddOutput, where it will be immediately added (not overwritten)."
	avelocity(vector) : "Angular Velocity" :  : "Angular velocity to start with on spawn. Can be changed with AddOutput, where it will be immediately added."
] // end SVelocity



	// COMPLETE SECTIONS //
// Complete "sections" of related keyvalues, with a line divider at the top to separate them from other sections. For consistency, sections should always list their line dividers above their other keyvalues. Line dividers should be defined in tf2_spud/default.fgd AND tf2_spud/linediv.fgd and inherited as base classes.

@BaseClass base(SBreakableDiv, SDamageFilter) color(255 100 0) = SBreakable [
	// health keyvalue doesn't work on models at all unless they're _override models, inherit separately
	//health(integer) : "Health" : 0 : "Number of points of damage to take before breaking. 0 means don't break."
	physdamagescale(float) : "Physics Impact Damage Scale" : "1.0" : "Scales damage energy when this object is hit by a physics object. Set to 1.0 for materials as strong as flesh, smaller numbers indicate stronger materials."
	minhealthdmg(integer) : "Minimum Damage to Hurt" :  : "The entity will ignore any damage events if the damage is less than this amount."
	// These don't actually seem to do anything...
	//ExplodeDamage(float) : "Explosion Damage" : 0 : "If non-zero, when this entity breaks it will create an explosion that causes the specified amount of damage. See also 'Explosion Radius'."
	//ExplodeRadius(float) : "Explosion Radius" : 0 : "If non-zero, when this entity breaks it will create an explosion with a radius of the specified amount. See also 'Explosion Damage'."
	pressuredelay(float) : "Pressure Delay" :  : "Delay, in seconds, after 'broken' by pressure before breaking apart (allows for sound to play before breaking apart)."
	PerformanceMode(choices) : "Performance Mode" : 0 : "Used to limit the amount of gibs produced when this entity breaks, for performance reasons." = [
		0 : "Normal"
		1 : "No Gibs"
		2 : "Full Gibs on All Platforms"
		3 : "Reduced gibs"
	] // end PerformanceMode

	input AddHealth(integer) : "Adds health to the breakable. If the breakable's health reaches zero it will break."
	input Break(void) : "Breaks the breakable."
	input PhysDamageScale(float) : "Sets the value that scales damage energy when this entity is hit by a physics object."
	input RemoveHealth(integer) : "Removes health from the breakable. If the breakable's health reaches zero it will break."
	input SetHealth(integer) : "Sets the breakable's health."

	output OnBreak(void) : "Fired when this breakable breaks."
	output OnHealthChanged(float) : "Fired when the health of this breakable changes, passing the new value of health as a percentage of max health, from [0..1]."
] // end SBreakable

// Settings used by static and dynamic models
// solid keyvalue used to be here, but does nothing on prop_physics and some other entities that inherit from SBaseDynamicModel, so instead entities inherit that separately
@BaseClass base(SModelSettingsDiv) sphere(fademindist) sphere(fademaxdist) = SModelSettings [
	fademindist(float) : "Start Fade Distance/Pixels" : -1 : "Distance at which the prop starts to fade (<0 = use End Fade Dist). If 'Screen Space Fade' is enabled, this represents the number of pixels wide covered by the prop when it starts to fade. The value will scale appropriately if the entity is in a 3D Skybox."
	fademaxdist(float) : "End Fade Distance/Pixels" : 0 : "Maximum distance at which the prop is visible (0 = don't fade out). If 'Screen Space Fade' is selected, this represents the *minimum* number of pixels wide covered by the prop when it fades. The value will scale appropriately if the entity is in a 3D Skybox."
	screenspacefade(choices) : "Screen Space Fade?" : 0 : "The method by which the fading distance should be determined. If 'No', the fade distances are the distance from the player's view to the object, in HU. If 'Yes', the fade distances are the size of the object onscreen, in pixels." = [
		0 : "No"
		1 : "Yes"
	] // end screenspacefade
	fadescale(float) : "Fade Scale" : "1.0" : "If specified in the worldspawn, or if the engine is running below DirectX 8, entities will fade out even if the fade distances above aren't specified. This value gives more control over when this happens: numbers smaller than 1 cause the entity to fade out at further distances, and greater than 1 cause it to fade out at closer distances. Using 0 turns off the forced fade altogether."
] // end SModelSettings

// Some settings specific to dynamic models
@BaseClass base(SModelDynamicDiv) = SModelDynamic [
	modelscale(float) : "Model Scale" : "1.0" : "A multiplier for the size of the model. Does not alter the physics collisions in most cases, however."

	input BecomeRagdoll(void) : "Kills the entity and creates a client-side ragdoll from the model. Input is only passed if the model contains ragdolling, for other models phys_convert can be used instead."
	input DisableShadow(void) : "Allows the entity to draw a render target (dynamic) shadow."
	input EnableShadow(void) : "Prevents the entity from drawing a render target (dynamic) shadow."
	input FadeMinDist(float) : "Sets distance at which the entity starts fading. If <0, the entity will disappear instantly when end fade is hit. The value will scale appropriately if the entity is in a 3D Skybox."
	input FadeMaxDist(float) : "Sets distance at which the entity ends fading. If <0, the entity won't disappear at all. The value will scale appropriately if the entity is in a 3D Skybox."
	input Ignite(void) : "Makes the entity catch on fire indefinitely. Does not work in Team Fortress 2."
	input IgniteHitboxFireScale(float) : "Makes the entity catch on fire with a given scale for hitbox fire particles."
	input IgniteLifetime(float) : "Makes the entity catch on fire for a given amount of time."
	input IgniteNumHitboxFires(integer) : "Makes the entity catch on fire with a given number of hitbox fire particles."
	input SetBodyGroup(integer) : "Change the model's bodygroup to the specified index number."
	input SetLightingOrigin(target_destination) : "Sets the entity to use as the entity's lighting origin. Any entity can be used."
	//input SetLightingOriginHack(target_destination) : "Offsets the entity's lighting origin by their distance from an info_lighting_relative."
	input SetModel(string) : "Changes the model to the specified path. Form of models/ammo/ammo_us.mdl."
	input SetModelScale(vector) : "Multiplies the size of the model. Does not alter the physics collisions in most cases, however. Negative values are accepted, although can cause crashes. Takes two values separated by a space. The first is the target model scale. The second value is the number of seconds the change in scale will be spread over."
	input Skin(integer) : "Changes the model's skin to the specified index number."
	input SetCycle(float) : "Skip to a specific point in the CURRENT animation. Needs to be set AFTER setting the animation and starting playback."
	input SetPlayBackRate(float) : "Change the animation speed multiplier (default: 1). Needs to be set AFTER setting the animation, starting playback, and setting the animation point (if needed)."

	//output OnIgnite(void) : "Fired when the entity catches fire, such as from an env_entity_igniter or the Ignite inputs."
] // end SModelDynamic

// Settings used by physics stuff (should also inherit SBreakable)
@BaseClass base(SPhysicsDiv) color(255 100 0) = SPhysics [
	massScale(float) : "Mass Scale" : "1.0" : "A scale multiplier for the object's mass. Use the convar 'sv_massreport 1' to see the actual mass of the object ingame."
	nodamageforces(choices) : "Can Damage Push This Object?" : 0 : "Used to determine whether or not damage should cause this entity to move." = [
		0 : "Allow Damage Forces"
		1 : "No Push Force From Damage"
	] // end nodamageforces
	damagetoenablemotion(integer) : "Health to Enable Motion" :  : "If specified, this object will start motion disabled. Once its health has dropped below this specified amount, it will enable motion."
	forcetoenablemotion(float) : "Impact Force to Enable Motion" :  : "If specified, this object will start motion disabled. Any impact on this entity that imparts a physics force greater than this value will enable motion."
	Damagetype(choices) : "Impact Damage Type" : 0 : "Sets the 'sharpness' of the brush. Sharp objects are far more damaging." = [
		0 : "Blunt"
		1 : "Sharp"
	] // end DamageType
	overridescript(string) : "Override Parameters" :  : "A list of physics key/value pairs that are usually in a physics prop .qc file. Format is 'key,value,key,value,etc'. See developer.valvesoftware.com/wiki/Prop_data#Options for a list of keys."

	input DisableDamageForces(void) : "Damaging the entity does *not* apply physics forces to it."
	input DisableFloating(void) : "Disables the object from floating."
	input DisableMotion(void) : "Disable physics motion/collision response."
	input EnableDamageForces(void) : "Damaging the entity applies physics forces to it."
	input EnableMotion(void) : "Enable physics motion/collision response."
	input Sleep(void) : "Put this physics object to sleep. It will wake if given the Wake input, or if force is applied to it. Note that physics objects go to sleep automatically after coming to rest for a while, so you don't usually need to use this."
	input Wake(void) : "Wake up this physics object, if it is sleeping."

	output OnAwakened(void) : "Fired when this entity becomes awake after being asleep (collision/force is applied)."
	output OnMotionEnabled(void) : "Fired when motion is enabled due to damage/physcannon/force."
	//output OnPhysGunDrop(void) : "Fired when a player drops this object."
	//output OnPhysGunOnlyPickup(void) : "Fired when a player picks this object up WITH THE PHYSGUN. +USE pickups do not fire this output."
	//output OnPhysGunPickup(void) : "Fired when a player picks this object up, either with the physgun or +use."
	//output OnPhysGunPunt(void) : "Fired when a player punts this object with the physgun."
	output OnPlayerUse(void) : "Fired when the player tries to +use the entity. This output will fire only if the Generate output on +USE spawnflag is set."
] // end SPhysics

// Render mode stuff used by most visible entities
@BaseClass base(SRenderModesDiv) = SRenderModes [
	effects(choices) : "Effect Flags" : 0 : "For configuring visual effects. If you want to combine effects, add the effect numbers together, i.e. 64 + 8 = 72. These can be changed at runtime with AddOutput, although changes have a slight delay before they take effect." = [
		0 : "0 - None"
		1 : "1 - Bonemerge w/ parent (expensive) (EF_BONEMERGE)"
		2 : "2 - Bright dynamic light @ origin (EF_BRIGHTLIGHT)"
		4 : "4 - Dim dynamic light @ origin (EF_DIMLIGHT)"
		8 : "8 - No movement interpolation (EF_NOINTERP)"
		16 : "16 - Don't cast dynamic shadows (EF_NOSHADOW)"
		32 : "32 - Don't transmit to client (EF_NODRAW)"
		64 : "64 - Don't receive dynamic shadows (EF_NORECEIVESHADOW)"
		129 : "129 - Bonemerge only while parent in PVS (EF_BONEMERGE + EF_BONEMERGE_FASTCULL)"
		256 : "256 - Flashing glow (EF_ITEM_BLINK)"
		512 : "512 - Parent always animating, realign each frame (EF_PARENT_ANIMATES)"
	] // end effects
	// TODO-BROKK: Describe these
	rendermode(choices) : "Render Mode" : 0 : "Set a non-standard rendering mode on this entity. Some/most of these are intended for sprites, and may or may not work on other entities. See developer.valvesoftware.com/wiki/Render_Modes for more info." = [ // Declared in const.h
		0 : "Normal"
		1 : "Color (May fix render order issues)"
		2 : "Texture"
		3 : "Glow"
		4 : "Solid/Alphatest"
		5 : "Additive"
		6 : "Environmental (Not drawn)"
		7 : "Additive Fractional Frame"
		8 : "Alpha Add"
		9 : "World Space Glow"
		10 : "Don't Render (EF_NODRAW)"
	] // end rendermode
	rendercolor(color255) : "Color (R G B)" : "255 255 255" : "Controls a color tint for the entity. Use white (255 255 255) for no modification to color. Black (0 0 0) completely hides the entity's textures."
	renderamt(integer) : "Transparency" : 255 : "Transparency amount: 0 is invisible, 255 is fully visible. Requires a Render Mode other than Normal."
	renderfx(choices) : "Render FX" : 0 : "Preset pattern of appearance effects." = [ // Declared in const.h
		0 : "Normal"
		1 : "Slow Pulse"
		2 : "Fast Pulse"
		3 : "Slow Wide Pulse"
		4 : "Fast Wide Pulse"
		5 : "Slow Fade Away"
		6 : "Fast Fade Away"
		7 : "Slow Become Solid"
		8 : "Fast Become Solid"
		9 : "Slow Strobe"
		10 : "Fast Strobe"
		11 : "Faster Strobe"
		12 : "Slow Flicker"
		13 : "Fast Flicker"
		14 : "No Dissipation"
		15 : "Distort"
		16 : "Hologram (Distort + fade)"
		17 : "Scale Up"
		18 : "Glow Shell"
		19 : "Clamp Minimum Scale (sprites only)"
		20 : "Environmental Rain"
		21 : "Environmental Snow"
		22 : "Spotlight FX"
		23 : "Ragdoll (ragdolls the entity but does NOT kill it)"
		24 : "Fade Wider Pulse"
	] // end renderfx

	input Alpha(integer) : "Sets the entity's transparency to a number from 0 (invisible) to 255 (fully visible)."
	input AlternativeSorting(bool) : "Swaps the rendering order of the entity. Used to attempt to fix sorting problems when rendering, for example an object rendering in front of translucent materials."
	input Color(color255) : "Sets an RGB color for the entity."
] // end SRenderModes

// Stuff that all triggers have (CBaseTrigger and CBaseVPhysicsTrigger)
@BaseClass base(STriggerDiv, SEnableDisable, SToggle) color(255 150 50) = STrigger [
	filtername(filterclass) : "Filter Name" :  : "Optionally a filter entity to test potential activators against. Only entities that pass this filter and the selected spawnflags will affect/be affected by this trigger. Spawnflags also provide some basic filtering abilities. The filter keyvalue cannot be changed with AddOutput, but spawnflags can."

	// SO. Spawnflags are only inherited from the last class in an entity's base() tag, which are always listed BELOW any flags specified in the entity itself. Additionally, if an entity overrides a baseclass' flags, any flags BELOW the overriden flag are ignored, for some fuckin reason...
	// Also also, if an entity has its own spawnflag block, all inherited flags are default unchecked, regardless of their actual setting, all of which which only goes to reinforce my theory that the people responsible for doing the coding at valve are 1024% braindead.
	spawnflags(flags) = [
		1 : "Clients/Players/Bots" : 1
		//32 : "Only clients in vehicles" : 0
		//512 : "Only clients NOT in vehicles" : 0
		2 : "NPCs" : 0
		16 : "Only player ally NPCs" : 0
		//2048 : "Only NPCs in vehicles (respects player ally flag)" : 0
		4 : "Pushables": 0
		8 : "Physics Objects (not including physics debris)" : 0
		1024 : "Physics Debris" : 0
		64 : "Everything (not including physics debris)" : 0
		4096 : "Disallow TFBots and Puppet Bots" : 0
	] // end spawnflags
] // end STrigger



	// INCOMPLETE BASE TYPES //
// Basic arrangements of various sections of keyvalues that comprise general entity types. These do not include any BaseEntity parts.

// Also inherit SBaseDynamicBrush with this
@BaseClass base(SBreakable, SHealth, SBreakBrushDiv) color(255 100 0) = SBaseBreakableBrush [
	propdata(choices) : "Prop Data" : 0 : "Set to the best approximation of the size and material of this entity's brushes. If set, it will override this entity's health and damage taken from various weapons. See the propdata.txt file in the scripts directory of your MOD to get a detailed list of what each entry specifies." = [
		0 : "None"
		1 : "Wooden.Tiny"
		2 : "Wooden.Small"
		3 : "Wooden.Medium"
		4 : "Wooden.Large"
		5 : "Wooden.Huge"
		6 : "Metal.Small"
		7 : "Metal.Medium"
		8 : "Metal.Large"
		9 : "Cardboard.Small"
		10 : "Cardboard.Medium"
		11 : "Cardboard.Large"
		12 : "Stone.Small"
		13 : "Stone.Medium"
		14 : "Stone.Large"
		15 : "Stone.Huge"
		16 : "Glass.Small"
		17 : "Plastic.Small"
		18 : "Plastic.Medium"
		19 : "Plastic.Large"
		20 : "Pottery.Small"
		21 : "Pottery.Medium"
		22 : "Pottery.Large"
		23 : "Pottery.Huge"
		24 : "Glass.Window"
	] // end propdata
	material(choices) :"Material Type" : 0 : "Set to the material type of the brush. Used to decide what sounds to make when damaged, and what gibs to produce when broken." = [
		0 : "Glass"
		1 : "Wood"
		2 : "Metal"
		3 : "Flesh"
		4 : "CinderBlock"
		5 : "Ceiling Tile"
		6 : "Computer"
		7 : "Unbreakable Glass"
		8 : "Rocks"
	    9 : "Web"
		10 : "None"
	] // end material
	explosion(choices) : "Gib Direction" : 0 : "Used to decide which direction to throw gibs when broken." = [
		0 : "Random"
		1 : "Relative to Attack"
		2 : "Use Precise Gib Dir"
	] // end explosion
	gibdir(angle) : "Precise Gib Direction" : "0 0 0" : "Specifies the direction to throw gibs when this breakable breaks. Be sure to select Use Precise Gib Dir in the Gibs Direction field!"
	gibmodel(studio) : "Gib Model" :  : "Specify a custom gib model to break into, overriding the 'Material Type'."
	// spawnobject(choices) : "Spawn On Break" :  : "When broken, an entity of the selected type will be created. Hardcoded values. None of these entities exist in TF2." = [
		// "" : "None"
		// 1 : "item_battery"
		// 2 : "item_healthkit"
		// 3 : "item_ammo_pistol"
		// 4 : "item_ammo_pistol_large"
		// 5 : "item_ammo_smg1"
		// 6 : "item_ammo_smg1_large"
		// 7 : "item_ammo_ar2"
		// 8 : "item_ammo_ar2_large"
		// 9 : "item_box_buckshot"6
		// 13 : "item_smg1_grenade"
		// 16 : "weapon_stunstick"
		// 18 : "weapon_ar2"
		// 21 : "weapon_smg1"
		// 23 : "weapon_slam"
		// 24 : "weapon_shotgun"
        // 26 : "item_dynamic_resupply"
	// ] // end spawnobject
	//explodemagnitude(integer) : "Explode Magnitude" : 0 : "If non-zero, when this entity breaks it will create an explosion that causes the specified amount of damage. Does not work in TF2."

	spawnflags(flags) = [
		1 : "Only Break via 'Break' input" : 0
		2 : "Break on Touch" : 0
		4 : "Break on Pressure" : 0
		512 : "Break immediately upon taking physics damage" : 0
		1024 : "Don't take physics damage" : 0
		2048 : "Don't allow bullet penetration": 0
	] // end spawnflags

	//input SetMass(float) : "Set the mass of this object." // Technically breakables also have this input, but these aren't physics objects, so what would this even do?
] // end SBaseBreakableBrush

// Also inherit SBaseDynamicModel with this
@BaseClass base(SBreakable) color(255 100 0) = SBaseBreakableModel [
	spawnflags(flags) = [
		16 : "Break on Touch" : 0
		32 : "Break on Pressure" : 0
	] // end spawnflags

	output OnTakeDamage(void) : "Fired each time this breakable takes any damage."
] // end SBaseBreakableModel

@BaseClass base(SRenderModes, SDynamicBrushDiv) = SBaseDynamicBrush [
	// These don't work, even with solid 2. Tested both collisions and ent_bbox on func_brush and trigger_multiple with custom mins and maxs using all 7 solid options. The solid keyvalue also just doesn't work on its own (not too surprising, since most brush entities use their own method of modifying their collisions). Maybe I did something wrong, idk, if anyone else gets different results feel free to let me know.
	//mins(vector) : "Minimum Bounding Box Size" :  : "Coordinate of the minimum bounding box corner, relative to entity origin. The bounding box is drawn from this corner to the other one. Requires Bounding Box collisions (solid 2) to be used. Can be used to overwrite the collision shape of a brush, although it can only be a cuboid. Can be AddOutputed to change shape at runtime."
	//maxs(vector) : "Maximum Bounding Box Size" :  : "Coordinate of the maximum bounding box corner, relative to entity origin. The bounding box is drawn from this corner to the other one. Requires Bounding Box collisions (solid 2) to be used. Can be used to overwrite the collision shape of a brush, although it can only be a cuboid. Can be AddOutputed to change shape at runtime."
	vrad_brush_cast_shadows(choices) : "VRAD Shadows?" : 0 : "Determines if VRAD will consider these brushes to cast static lightmap shadows. The shadow will be cast from the brushes' position in Hammer." = [
		0 : "Do not cast shadows"
		1 : "Cast lightmap shadows"
	] // end vrad_brush_cast_shadows
	disablereceiveshadows(choices) : "Disable Receiving Shadows?" : 0 : "Whether this entity should allow other entities to cast cheap render-to-texture shadows onto it." = [
		0 : "No"
		1 : "Yes"
	] // end disablereceiveshadows
	_minlight(float) : "Minimum Light Level" :  : "The minimum level of ambient light that hits these brushes."
	texframeindex(integer) : "ToggleTexture Frame" :  : "The starting frame number for any ToggleTexture materials on this entity. This keyvalue can be changed with AddOutput as an alternative to using env_texturetoggle, but there will be a slight delay before the texture changes. Does not work with materials lacking the ToggleTexture proxy."
] // end SBaseDynamicBrush

// NOTE: This does not include the skin, bodygroup, hitboxset, and texframeindex keyvalues, as some entities override these values on spawn.
// TODO: Test and document some missing keyvalues from http://src-ents.shoutwiki.com/wiki/CBaseAnimating
@BaseClass base(SModelDynamic, SModelLighting, SModelSettings, SRenderModes) = SBaseDynamicModel [
] // end SBaseDynamicModel

// NO DIVIDER AT TOP
@BaseClass base(SDoor, SResetDelay, SBaseBrushDoorDiv, SStartStopSounds) = SBaseBrushDoor [
	startclosesound(sound) : "Start Close Sound" :  : "Sound to play when the door starts closing."
	closesound(sound) : "Stop Close Sound" :  : "Sound to play when the door stops closing."
	locked_sound(sound) : "Locked Sound" :  : "Sound played when the player tries to use the door, and fails because it's locked."
	unlocked_sound(sound) : "Unlocked Sound" :  : "Sound played when the door is unlocked and used."
	loopmovesound(choices) : "Loop Moving Sound?" : 0 : "If set to true, the door's 'Start Sound' will be continually looped until the door finishes moving." = [
		0 : "No"
		1 : "Yes"
	] // end loopmovesound
	ignoredebris(choices) : "Ignore Debris?" : 0 : "If set this will change the door's collision group to one that ignore collisions with debris objects (note that this is not compatible with the non-solid-to-player spawnflag)." = [
		0 : "No"
		1 : "Yes"
	] // end ignoredebris
	chainstodoor(target_destination) : "Linked Door" :  : "Passes the door's +use inputs and touch events onto another door. I/O inputs are not shared, and the doors will not necessarily respond to +use or touch events in the same way unless they are configured identically. This connection is one-way unless both doors specify each other as their Linked Door."

	spawnflags(flags) = [
		1024 : "Touch Opens" : 0
		256 : "+USE Opens" : 0
		65536 : "New +USE Rules - Allow +use to re-open door while closing (if not locked)" : 0
		512 : "NPCs can't open this door" : 0
		2048 : "Starts Locked - Door cannot be opened by any means while locked (but can be closed)" : 0
        1 : "Starts Open - Door spawns in open position (Obsolete but functional, OnFullyOpen and OnFullyClosed outputs are swapped)" : 0
	    32 : "Toggleable - Touch/+use events will Toggle the door (instead of only opening)" : 0
		4 : "Non-Solid to Player (Incompatible with Ignore Debris)" : 0
		8 : "Passable - Door is solid to nothing" : 0
		4096 : "Silent Door - Door makes no sound" : 0
	] // end spawnflags

	input SetToggleState(bool) : "Set the toggle state of the door to currently open or closed."
] // end SBaseBrushDoor

@BaseClass base(SBaseItemDiv, SEnableDisable, STFTeam) = SBaseItem [
	TeamNum(choices) : "Team" : 0 : "Team of the item. If a team is assigned, only players on the matching team may pick up this item." = [
		0 : "0 - Any/Unassigned"
		1 : "1 - Spectator"
		2 : "2 - RED"
		3 : "3 - BLU"
		5 : "5 - Neutral/Boss"
	] // end TeamNum

	AutoMaterialize(choices) : "Auto-Materialize?" : 1 : "Whether the pickup should automatically materialize after being picked up. If set to 'No', the pickup will not respawn until it receives the 'Enable' input. For healthkits and ammopacks, this is hardcoded as 10 seconds." = [
		0 : "No"
		1 : "Yes"
	] // end AutoMaterialize

	output OnPlayerTouch(void) : "Fires when the player picks up this object."
	output OnCacheInteraction(void) : "Fires when a player touches this object (regardless of whether they actually picked it up or it was consumed)."
] // end SBaseItem

@BaseClass base(SNPCDiv1, SHealth, SVelocity, SNPCDiv2) = SBaseNPC [
	target(target_destination) : "Target Path Corner" :  : "If set, the name of a path_corner entity that this NPC will move to, after spawning. Must be within 576 units from the NPC."
	additionalequipment(string) : "Weapon Held" :  : "Gives the NPC a weapon. NPCs may attack oddly or not attack if they don't know how to use a particular weapon."
	ExpressionOverride(string) : "Enter a VCD file to override facial expressions on this NPC."
	sleepstate(choices) : "Sleep State" : 0 : "Holds the NPC in stasis until specified condition. See also 'Wake Radius' and 'Wake Squad'." = [
		0 : "None"
		1 : "Waiting for threat"
		2 : "Waiting for PVS"
		3 : "Waiting for input, ignore PVS"
		4 : "Auto PVS"
		5 : "Auto PVS after PVS"
	] // end sleepstate
	wakeradius(float) : "Wake Radius" : 0 : "Auto-wake if player is within this distance, in Hammer units."
	wakesquad(choices) : "Wake Squad" : 0 : "If yes, wake all of the NPCs squadmates if the NPC is woken." = [
		0 : "No"
		1 : "Yes"
	] // end wakesquad
	hintgroup(String) : "Hint Group" :  : "Hint groups are used by NPCs to restrict their hint-node searching to a subset of the map's hint nodes. Only hint nodes with matching hint group names will be considered by this NPC."
	hintlimiting(choices) : "Hint Limit Nav" : 0 : "Limits NPC to using specified hint group for navigation requests, but does not limit local navigation." = [
		0 : "No"
		1 : "Yes"
	] // end hintlimiting
	relationship(string) : "Relationship" :  : "Changes whether this NPC likes or dislikes certain others. Format is: <string|targetname or classname> <string|disposition> <integer|rank>. Values for disposition are: D_HT (Hate), D_FR (Fear), D_LI (Like), D_NU, (Neutral)."
	squadname(String) : "Squad Name" :  : "NPCs that are in the same squad will share information about enemies, and will take turns attacking and covering each other."
	enemyfilter(filterclass) : "Enemy Filter" :  : "Filter by which to filter potential enemies."
	ignoreunseenenemies(choices) : "Ignore Unseen Enemies?" : 0 : "Prefer visible enemies, regardless of distance or relationship priority." = [
		0 : "No"
		1 : "Yes"
	] // end ignoreunseenenemies
	DontUseSpeechSemaphore(choices) : "Don't Use Speech Semaphore?" : 0 : "Friendly NPCs are not allowed to speak if another friendly NPC is speaking. In some cases we don't want speaking NPCs to prevent other NPCs from speaking (for instance, if there is a friendly NPC speaking for a long time on a monitor). To make this NPC not prevent other NPCs from talking, make it not grab the semaphore when it speaks." = [
		0 : "No (Use speech semaphore)"
		1 : "Yes (Don't use speech semaphore)"
	] // end DontUseSpeechSemaphore

	spawnflags(Flags) = [
		1 : "Wait Till Seen" : 0
		2 : "Gag (No idle sounds until angry)" : 0
		4 : "Fall to ground (unchecked means teleport to ground)" : 1
		8 : "Drop Healthkit" : 0
		16 : "Efficient - Don't acquire enemies or avoid obstacles" : 0
		128 : "Wait For Script" : 0
		256 : "Long Visibility/Shoot" : 0
		512 : "Fade Corpse" : 1
		1024 : "Think outside PVS, bad for performance" : 0
		2048 : "Template NPC (used by npc_maker, will not spawn)" : 0
		4096 : "Do alternate collision for this NPC (player avoidance)" : 0
		8192 : "Don't drop weapons" : 0
		16384 : "Ignore player push (dont give way to player)" : 0
	] // end spawnflags

	input BeginRappel(void) : "Tells NPC to begin rappelling. May not do anything."
	input ForceInteractionWithNPC(string) : "Force the NPC to use a dynamic interaction with another NPC. Syntax is <targetname> <dynamic interaction>."
	input GagEnable(void) : "Prevents the NPC from making any vocalized sounds or speech, unless they are in a choreographed scene."
	input GagDisable(void) : "Allow the NPC to make vocalizations again."
	input HolsterAndDestroyWeapon(void) : "Identical to HolsterWeapon, except the weapon is destroyed once it has been holstered and concealed."
	input HolsterWeapon(void) : "Force the NPC to holster their weapon. Ignored if the NPC is scripting, if the NPC's weapon is already holstered, or if the NPC doesn't use weapons."
	input IgnoreDangerSounds(float) : "Ignore danger sounds for the specified number of seconds."
	input StartScripting(void) : "Puts the NPC into a 'scripted' state. It will ignore a variety of stimuli, such as +use, danger sounds, and idle speech."
	input StopScripting(void) : "Puts the NPC into their normal state again."
	input UnholsterWeapon(void) : "Force the NPC to draw their weapon. Ignored if the NPC is scripting, if the NPC's weapon is already drawn, or if the NPC doesn't use weapons."
	input Wake(void) : "Wakes up the NPC if it is sleeping."

	input Break(void) : "Makes the NPC die and disappear."
	input ForgetEntity(string) : "Clears out the NPC's knowledge of a named entity."
	input InsideTransition(void) : "Tells the NPC to stop any choreography (but not scripted speech) its a part of. Usually this is only done by a trigger_changelevel when a player steps inside it, and the NPC is inside an associated trigger_transition."
	input SetEnemyFilter(target_destination) : "Set a filter by which to filter potential enemies."
	input SetExpressionOverride(string) : "Set a VCD file to override facial expressions on this NPC."
	input SetRelationship(string) : "Changes this entity's relationship with another entity or class. Format: <entity name/classname> <D_HT/D_FR/D_LI/D_NU> <priority>"
	input SetSquad(string) : "Changes the name of this NPC's squad. Leaving the parameter blank will remove the NPC from any existing squad."
	input UpdateEnemyMemory(string) : "Update (or create) this NPC's memory of of the given entity."

	output OnDamaged(void) : "Fired when this NPC takes damage."
	output OnDamagedByPlayer(void) : "Fired when this NPC is hurt by a player."
	output OnDamagedByPlayerSquad(void) : "Fired when this NPC is hurt by a player OR by one of the player's squadmates."
	output OnDeath(void) : "Fired when this NPC is killed."
	output OnHalfHealth(void) : "Fired when this NPC reaches half of its maximum health."

	output OnDenyCommanderUse(void) : "Fired when this NPC has refused to join the player's squad."
	output OnForcedInteractionAborted(void) : "Fired when the NPC aborts a forced interaction for some reason (target NPC died, couldn't be pathed to, etc)."
	output OnForcedInteractionFinished(void) : "NPCs in actbusies can no longer perform dynamic interactions."
	output OnForcedInteractionStarted(void) : "Fired when the NPC starts a forced interaction."
	output OnFoundEnemy(string) : "Fired when this NPC establishes line of sight to its enemy (outputs entity)."
	output OnFoundPlayer(string) : "Fired when this NPC establishes line of sight to its enemy, and that enemy is a player (outputs player entity)."
	output OnHearCombat(void) : "Fired when this NPC hears combat sounds."
	output OnHearPlayer(void) : "Fired when this NPC hears the player."
	output OnHearWorld(void) : "Fired when this NPC hears a sound (other than combat or the player)."
	output OnLostEnemy(void) : "Fired when this NPC loses its enemy. Usually due to the enemy being killed/removed, or because this NPC has selected a newer, more dangerous enemy."
	output OnLostEnemyLOS(void) : "Fired when this NPC loses line of sight to its enemy."
	output OnLostPlayer(void) : "Fired when this NPC loses its enemy, and that enemy was a player. Usually due to the enemy being killed/removed, or because this NPC has selected a newer, more dangerous enemy."
	output OnLostPlayerLOS(void) : "Fired when this NPC loses line of sight to its enemy, and that enemy is a player."
	output OnSleep(void) : "Fired when this NPC enters a sleep state."
	output OnWake(void) : "Fired when this NPC comes out of a sleep state."
] // end SBaseNPC



	// BASE ENTITY TYPES //
// Basic arrangements of various sections of keyvalues that comprise common general entity types, including BaseEntity parts. Only bases with few keyvalues should be listed here as these intentionally go against my rule of "entity-specific keyvalues at the top". Most entities should be organizing their bases themselves to intermix them with their own keyvalues for easier mapper workflow.

@BaseClass base(SBaseEntity, SBaseDiv) color(150 50 50) = SBaseConstraint [
	attach1(target_destination) : "Entity 1" : ""
	attach2(target_destination) : "Entity 2" : ""
	constraintsystem(target_destination) : "Constraint System Manager" :  : "The name of a phys_constraintsystem that this constraint should be a part of. All constraints on a set of entities should be placed in the same system, or they will fight each other during simulation."
	forcelimit(float) : "Force Limit to Break (lbs)" : 0 : "The amount of force an impact must apply to the constraint to break it. A way of calculating this is to set it to the mass of an object that would break this constraint if it were resting on the constrainted objects."
	torquelimit(float) : "Torque Limit to Break (lbs * distance)" : 0 : "The amount of torque required to break the constraint. A way of calculating this is to multiply any reference mass by the resting distance (from the center of mass of the object) needed to break the constraint."
	breaksound(sound) : "Play Sound on Break" :  : "A sound played when the constraint is broken."
	teleportfollowdistance(float) : "Follow teleport distance" : 0 : "If one object teleports more than this many units away it will cause the other constrained object to teleport to an appropriate relative position."

	spawnflags(flags) = [
		1 : "No collision until break" : 0
		4 : "Start inactive" : 0
		8 : "Change mass to keep stable attachment to world" : 0 // TODO: For phys_hinge only?
		16 : "Do not connect entities until turned on" : 0
	] // end spawnflags

	input Break(void) : "Force the constraint to break."
	input TurnOff(void) : "Disable this constraint."
	input TurnOn(void) : "Enable the constraint. Do this when the objects don't exist when the constraint spawns - or when you have deactivated the constraint. Broken constraints can NOT be turned on. They have been deleted."

	output OnBreak(void) : "Fired when the constraint breaks."
] // end SBaseConstraint

@BaseClass base(SBaseLogical, SBaseDiv) color(255 100 150) = SBaseFilter [
	Negated(choices) : "Filter Mode" : 0 : "If set to Allow, only entities which match the criteria will pass the filter. If set to Disallow, the filter criteria is negated: only entities which do NOT match the criteria will pass the filter." = [
		0 : "Allow entities that match"
		1 : "Disallow entities that match"
	] // end Negated

	input TestActivator(void) : "Test the activator against the filter and fires OnPass or OnFail output. BUG: Crashes the server if the !activator is null or does not exist."
	output OnPass(void) : "Fired in response to the TestActivator input if the activator passes the filter."
	output OnFail(void) : "Fired in response to the TestActivator input if the activator fails to pass the filter."
] // end SBaseFilter

@BaseClass base(SBaseEntityOrigin, STrigger) color(255 150 50) = SBaseTrigger [
	input Disable(void) : "Disable this trigger. If the trigger was previously enabled, it will fire OnEndTouch for any touching entities. Entities which are not physically touching the trigger but which started touching this entity via the StartTouch input will not fire OnEndTouch."
	input DisableAndEndTouch(void) : "Disable this trigger and immediately fire OnEndTouch for any touching entities, including for entities which started touching via the StartTouch input. OnEndTouch fires marginally faster than with the Disable input."
	input Enable(void) : "Enable this trigger. If the trigger was previously disabled, it will fire OnStartTouch for any touching entities."
	input EndTouch(void) : "Behave as though the !caller entity just exited the trigger, firing OnEndTouch if the !caller was previously considered to be touching this trigger. The !caller of this input will become the !activator of the OnEndTouch output. OnEndTouch will be fired even if the trigger is disabled."
	input StartTouch(void) : "Behave as though the !caller entity just entered the trigger, firing OnStartTouch if the !caller passes this trigger's filters (even if the !caller is already considered to be touching this trigger). The !caller of this input will become the !activator of the OnStartTouch output. Any other effects associated with touching this trigger, such as a trigger_cataput's launch velocity, may also be applied to the !caller. OnStartTouch will be fired even if the trigger is disabled (AddOutput spawnflags can be used as a workaround)."
	input TouchTest(void) : "Test whether any valid entities are currently touching this trigger, firing OnTouching if this is true and OnNotTouching otherwise."

	// So I figured out the cause of this bug... When a trigger is EndTouched by an entity, it checks its entire list of touching entities for any entities which either don't exist, or are dead players. If any dead players are on the list, it removes that player without calling OnEndTouch. GG volvo. (Oddly enough, doesn't affect killed entities or disconnected players...)
	// Testing indicates that 0.02 secs or 2 server ticks is enough delay for two deaths to not be "simultaneous", seems awfully short though if this was a common problem in beto's map...
	output OnEndTouch(void) : "Fires when an entity stops touching this trigger. Only entities that passed this trigger's filters when they STARTED touching the trigger will cause this output to fire. If multiple entities leave the trigger simultaneously, this output fires once per entity. BUG: If multiple candidate players die simultaneously within the trigger, this will only fire once total, NOT once per player as expected."
	output OnEndTouchAll(void) : "Fires when an entity stops touching this trigger, and no other entities are touching it. Only entities that passed this trigger's filters when they started touching this trigger are considered."
	output OnNotTouching(void) : "Fires when the TouchTest input is called and no entities that pass the filter are touching this trigger. The trigger entity itself is the !activator (the previous !activator is not preserved)."
	output OnStartTouch(void) : "Fires when an entity starts touching this trigger. The touching entity must pass this trigger's filters to cause this output to fire. If multiple entities enter the trigger simultaneously, this output fires once per entity."
	output OnStartTouchAll(void) : "Fires when an entity starts touching this trigger, and no other entities are touching it. Only entities that passed this trigger's filters are considered."
	output OnTouching(void) : "Fires when the TouchTest input is called and at least one entity that passes the filter is touching this trigger. The trigger entity itself is the !activator (the previous !activator is not preserved)."
	// FICOOL ONLY SPECIFIC TRIGGERS HAVE THIS ONE NOT ALL OF THEM YOU DAFT FOOL
	// output OnTrigger(void) : "Fired whenever the trigger is activated."
] // end SBaseTrigger



//----- WORLDSPAWN -----//



@SolidClass base(SPreservedEntity, SBaseLogical, SBaseDiv) = worldspawn : "This is the world entity, representing all map geometry that is not tied to an entity. Each map must contain exactly one, and it's automatically created for you. Killing this entity or creating another instance of it will crash the game!" [ // color(100 150 255)
	//does_not_function(string) readonly : "NOTE: DO NOT MANUALLY CREATE THIS ENTITY." :  : "Only one instance of this entity may exist, and it's automatically created for you. Creating another instance will cause the game to crash on map load. To configure your map's worldspawn, go to 'Map' > 'Map Properties'."

	message(string) : "Map Title/Description" :  : "This doesn't affect anything in-game, but is a good spot to put some information about your map. Like all keyvalues, this will be stored in the BSP and visible in any decompile of the map."
	author(string) : "Map Author" :  : "Like the Map Title, this doesn't affect anything in-game, but is a good spot to put your name/pseudonym. Like all keyvalues, this will be stored in the BSP and visible in any decompile of the map."
	skyname(choices) : "2D Skybox Material" : "sky_tf2_04" : "Skybox material. A list of official skyboxes is provided, see developer.valvesoftware.com/wiki/Team_Fortress_2_Sky_List for pictures of each. Custom skyboxes can also be typed. This can be changed at runtime with AddOutput, although the player must re-connect to see the change." = [
		//"sky_day01_01"
		"sky_alpinestorm_01" : "sky_alpinestorm_01"
		"sky_badlands_01" : "sky_badlands_01"
		"sky_badlands_pyroland_01" : "sky_badlands_pyroland_01"
		"sky_dustbowl_01" : "sky_dustbowl_01"
		"sky_goldrush_01" : "sky_goldrush_01"
		"sky_granary_01" : "sky_granary_01"
		"sky_gravel_01" : "sky_gravel_01"
		"sky_halloween" : "sky_halloween"
		"sky_halloween_night_01" : "sky_halloween_night_01"
		"sky_halloween_night2014_01" : "sky_halloween_night2014_01"
		"sky_harvest_01" : "sky_harvest_01"
		"sky_harvest_night_01" : "sky_harvest_night_01"
		"sky_hydro_01" : "sky_hydro_01"
		"sky_island_01" : "sky_island_01"
		"sky_morningsnow_01" : "sky_morningsnow_01"
		"sky_night_01" : "sky_night_01"
		"sky_nightfall_01" : "sky_nightfall_01"
		"sky_pyroland_01" : "sky_pyroland_01"
		"sky_pyroland_02" : "sky_pyroland_02"
		"sky_pyroland_03" : "sky_pyroland_03"
		"sky_rainbow_01" : "sky_rainbow_01"
		"sky_stormfront_01" : "sky_stormfront_01"
		"sky_tf2_04" : "sky_tf2_04"
		"sky_trainyard_01" : "sky_trainyard_01"
		"sky_upward" : "sky_upward"
		"sky_well_01" : "sky_well_01"
	] // end skyname
	detailvbsp(choices) : "Detail .vbsp File" : "detail.vbsp" : "Detail.vbsp file to use for emitting detail props (found in the /tf directory). A list of official .vbsp files is provided; custom ones can also be typed. Those that don't have a material file with a matching name have their associated material file listed in parentheses. Further info: tf2maps.net/abs/detail_sprites_info.html" = [
		"detail.vbsp" : "detail.vbsp"
		"detail_2fort.vbsp" : "detail_2fort.vbsp"
		"detail_doomsday.vbsp" : "detail_doomsday.vbsp (sprites_dustbowl)"
		"detail_granary.vbsp" : "detail_granary.vbsp"
		"detail_island.vbsp" : "detail_island.vbsp"
		"detail_lakeside.vbsp" : "detail_lakeside.vbsp (sprites_2fort)"
		"detail_sawmill.vbsp" : "detail_sawmill.vbsp"
		"detail_trainyard.vbsp" : "detail_trainyard.vbsp"
	] // end detailvbsp
	detailmaterial(choices) : "Detail Material File" : "detailsprites" : "Material for detail sprites to use for drawing detail props (relative to /tf/materials). A list of official detail sprites is provided; custom ones can also be typed. Those that don't have a .vbsp file with a matching name have their associated .vbsp file listed in parentheses. Further info: tf2maps.net/abs/detail_sprites_info.html" = [
		"detail/detailsprites" : "detailsprites"
		"detail/detailsprites_2fort" : "detailsprites_2fort"
		"detail/detailsprites_dustbowl" : "detailsprites_dustbowl (doomsday.vbsp)"
		"detail/detailsprites_granary" : "detailsprites_granary"
		"detail/detailsprites_harvest" : "detailsprites_harvest (trainyard.vbsp)"
		"detail/detailsprites_island" : "detailsprites_island"
		"detail/detailsprites_sawmill" : "detailsprites_sawmill"
		"detail/detailsprites_trainyard" : "detailsprites_trainyard"
		"detail/detailsprites_viaduct_event" : "detailsprites_viaduct_event (trainyard.vbsp)"
	] // end detailmaterial

	maxpropscreenwidth(float) : "Start Fade Pixels" : -1 : "Number of pixels wide at which all props in the level start to fade (<0 = use End Fade Pixels). This number is ignored if the prop has a specific fade distance specified."
	minpropscreenwidth(float) : "End Fade Pixels" : 0 : "Minimum number of pixels wide at which the prop is visible (0 = don't fade out). This number is ignored if the prop has a specific fade distance specified."
	maxoccludeearea(float) : "Max Occludee Area" : "0.0" : "Prevents occlusion testing for models that take up more than X% of the screen."
	minoccluderarea(float) : "Min Occluder Area" : "0.0" : "Prevents occluders from functioning if they take up less than X% of the screen."

	_minlight(float) : "Map Geometry Minimum Light Level" : "0.0" : "Forces the minimum intensity of light part of the map geometry to be at least this. Expressed as a float from 0.0 to 2.0, with 0.0 being pitch black (default) and 2.0 being fullbright. Does not affect props or entities."
	// TODO-BROKK: Does this actually work?
	startdark(choices) : "Fade In World?" : "" : "If Yes, during the server welcome screen and class selection when the player first loads into the world, the world will slowly fade in from black. If the player quickly skips through these sections before the fade is complete, the fade ends abruptly." = [
		"" : "No"
		1 : "Yes"
	] // end startdark

	no_decomp(choices) : "Disallow Decompiling?" : "" : "If Yes, then VMEX will refuse to decompile the map. Newer third-party decompilers and tools ignore this, so this is effectively obsolete." = [
		"" : "No"
		1 : "Yes"
	] // end no_decomp
] // end worldspawn



//----- BRUSH ENTITIES -----//



	// COLOR ENTITIES //

@SolidClass base(SBaseTrigger, SBaseDiv) color(255 150 50) = color_correction_volume : "A color correction lookup table is faded in or out when a player enters or leaves its volume. Fade time is configurable." [
	filename(string) : "Lookup Table Filename" :  : "Path to the .raw file containing the lookup table."
	maxweight(float) : "Maximum Weight" : "1.0" : "This is the maximum weight for this lookup."
	fadeDuration(float) : "Lookup Fade Duration" : "10.0" : "How fast the effect fades in or out when the viewer enters or exits."
] // end color_correction_volume



	// DISPENSER ENTITIES //

@SolidClass base(SBaseTrigger) color(255 150 50) = dispenser_touch_trigger : "Trigger for a dispenser healing zone." [
] // end dispenser_touch_trigger



	// ENV ENTITIES //

// Origin keyvalue breaks the entity, don't inherit that
@BaseClass = env_bubbles_keys [
	density(integer) : "Bubble Density" : 2 : "Bubble count in volume."
	frequency(integer) : "Bubble Frequency" : 2 : "Bubble emission frequency, in bubbles per second."
	current(integer) : "Speed of Current" : 0 : "The speed of the water current in the volume, used to move the bubbles."
] // end env_bubbles_keys
@SolidClass base(SBaseEntity, SBaseDiv, env_bubbles_keys, SBaseDynamicBrush, SToggle) = env_bubbles : "An entity used to create a volume in which to spawn bubbles. The brush itself is ordinarily visible by default; this FGD changes the default Render Mode to 'Don't Render' so the volume is not visible. To make the brush visible, change the Render Mode to 'Normal'." [
	rendermode(choices) : "Render Mode" : 0 : "Set a non-standard rendering mode on this entity. The brush itself is visible by default, set this to 'Don't Render' to hide it." = [ // Declared in const.h
		0 : "Normal"
		1 : "Color"
		2 : "Texture"
		3 : "Glow"
		4 : "Solid/Alphatest"
		5 : "Additive"
		6 : "Environmental (Not drawn)"
		7 : "Additive Fractional Frame"
		8 : "Alpha Add"
		9 : "World Space Glow"
		10 : "Don't Render (EF_NODRAW)"
	] // end rendermode

	spawnflags(flags) = [
		1 : "Start Off" : 0
	] // end spawnflags

	input Activate(void) : "Activates the bubbles."
	input Deactivate(void) :  "Deactivates the bubbles."
	input SetCurrent(integer) : "Sets current speed in units per second."
	input SetDensity(integer) : "Sets the bubble density."
	input SetFrequency(integer) : "Sets bubble emission rate in bubbles per second."
] // end env_bubbles

// Origin keyvalue breaks the entity, don't inherit that
@SolidClass base(SBaseEntity, SBaseDiv) = env_embers : "An entity used to create a volume in which to spawn fire embers. The particles can be quite small and tough to see at range. This entity's on/off state is toggled with the Use input exclusively. Can have a maximum of 2048 embers active at once." [
	rendercolor(color255) : "Particle Color (R G B)" : "255 0 0" : "Color of the sprites."
	density(integer) : "Density (particles / sec)" : 50 : "Number of particles spawned each second."
	speed(integer) : "Particle Speed" : 32 : "The move speed of the particles in HU/s."
	angles(angle) : "Particle Direction (Pitch Yaw Roll)" : "0 0 0" : "What direction the particles should move in after spawning."
	lifetime(integer) : "Particle Lifetime" : 4 : "Number of seconds each particle lasts for. A certain amount of randomness is added proportional to the time specified here."

	spawnflags(flags) = [
		1 : "Start On" : 1
		2 : "Toggle - If unchecked, only accepts Use input once" : 0
	] // end spawnflags

	input Color(color255) : "Changes the color that new sprites will spawn with."
] // end env_embers



	// FUNC ENTITIES //

@BaseClass base(SSpeed, SResetDelay, SDamageFilter) = SButton [
	//health(integer) : "Health" : 0 : "Legacy method of specifying whether or not the button can be shot to activate it. Use the 'Damage Activates' spawnflag instead."

	// sounds(choices) : "Sounds" : "0" : "Button sounds. Doesn't work in TF2." = [
		// 0: "None (Silent)"
		// 1: "Big zap & Warmup"
		// 2: "Access Denied"
		// 3: "Access Granted"
		// 4: "Quick Combolock"
		// 5: "Power Deadbolt 1"
		// 6: "Power Deadbolt 2"
		// 7: "Plunger"
		// 8: "Small zap"
		// 9: "Keycard Sound"
		// 10: "Buzz"
		// 11: "Buzz Off"
		// 12: "Latch locked"
		// 13: "Latch Unlocked"
		// 14: "Lightswitch"
		// 15: "Small bleek"
		// 16: "Small deny"
		// 17: "Small doop"
		// 18: "Small tech deny"
		// 19: "Click and combine screen fuzz"
		// 20: "Roomy beep"
		// 21: "Lever or Wheel: turn + move sqeek"
		// 22: "Lever or Wheel: latch + release gas"
		// 23: "Lever or Wheel: ratchet + sqeek"
		// 24: "Lever or Wheel: large ratchet"
		// 25: "Lever or Wheel: clanky + gas release"
		// 26: "Lever or Wheel: latch + large metal thud"
		// 27: "Lever or Wheel: smaller ratchet"
		// 28: "Lever or Wheel: smaller lever move"
		// 31: "Shock buzz"
		// 32: "Clickbeep"
		// 33: "Tech blip"
		// 34: "Clickbeepbeep open"
		// 35: "Small high blip"
		// 36: "Small tech fuzz blip"
		// 37: "Small click bleep (change to lightswitch)"
		// 40: "Combine door lock - locked"
		// 41: "Combine blip growl"
		// 42: "Combine squick growl"
		// 43: "Combine whine purr"
		// 44: "Combine click talk"
		// 45: "Combine click growl fizz"
		// 46: "Combine click fizz (deny)"
		// 47: "Combine click talker"
	// ] // end sounds
	// locked_sound(choices) : "Locked Sound" : 0 : "Sound played when the player tries to use the button, and fails because it's locked. Doesn't work in TF2." = [
		// 0: "None (Silent)"
		// 1: "Big zap & Warmup"
		// 2: "Access Denied"
		// 3: "Access Granted"
		// 4: "Quick Combolock"
		// 5: "Power Deadbolt 1"
		// 6: "Power Deadbolt 2"
		// 7: "Plunger"
		// 8: "Small zap"
		// 9: "Keycard Sound"
		// 10: "Buzz"
		// 11: "Buzz Off"
		// 12: "Latch locked"
		// 13: "Latch Unlocked"
		// 14: "Lightswitch"
		// 15: "Small bleek"
		// 16: "Small deny"
		// 17: "Small doop"
		// 18: "Small tech deny"
		// 19: "Click and combine screen fuzz"
		// 20: "Roomy beep"
		// 21: "Lever or Wheel: turn + move sqeek"
		// 22: "Lever or Wheel: latch + release gas"
		// 23: "Lever or Wheel: ratchet + sqeek"
		// 24: "Lever or Wheel: large ratchet"
		// 25: "Lever or Wheel: clanky + gas release"
		// 26: "Lever or Wheel: latch + large metal thud"
		// 27: "Lever or Wheel: smaller ratchet"
		// 28: "Lever or Wheel: smaller lever move"
		// 31: "Shock buzz"
		// 32: "Clickbeep"
		// 33: "Tech blip"
		// 34: "Clickbeepbeep open"
		// 35: "Small high blip"
		// 36: "Small tech fuzz blip"
		// 37: "Small click bleep (change to lightswitch)"
		// 40: "Combine door lock - locked"
		// 41: "Combine blip growl"
		// 42: "Combine squick growl"
		// 43: "Combine whine purr"
		// 44: "Combine click talk"
		// 45: "Combine click growl fizz"
		// 46: "Combine click fizz (deny)"
		// 47: "Combine click talker"
	// ] // end locked_sound
	// unlocked_sound(choices) : "Unlocked Sound" : 0 : "Sound played when the button is unlocked. Doesn't work in TF2." = [
		// 0: "None (Silent)"
		// 1: "Big zap & Warmup"
		// 2: "Access Denied"
		// 3: "Access Granted"
		// 4: "Quick Combolock"
		// 5: "Power Deadbolt 1"
		// 6: "Power Deadbolt 2"
		// 7: "Plunger"
		// 8: "Small zap"
		// 9: "Keycard Sound"
		// 10: "Buzz"
		// 11: "Buzz Off"
		// 12: "Latch locked"
		// 13: "Latch Unlocked"
		// 14: "Lightswitch"
		// 15: "Small bleek"
		// 16: "Small deny"
		// 17: "Small doop"
		// 18: "Small tech deny"
		// 19: "Click and combine screen fuzz"
		// 20: "Roomy beep"
		// 21: "Lever or Wheel: turn + move sqeek"
		// 22: "Lever or Wheel: latch + release gas"
		// 23: "Lever or Wheel: ratchet + sqeek"
		// 24: "Lever or Wheel: large ratchet"
		// 25: "Lever or Wheel: clanky + gas release"
		// 26: "Lever or Wheel: latch + large metal thud"
		// 27: "Lever or Wheel: smaller ratchet"
		// 28: "Lever or Wheel: smaller lever move"
		// 31: "Shock buzz"
		// 32: "Clickbeep"
		// 33: "Tech blip"
		// 34: "Clickbeepbeep open"
		// 35: "Small high blip"
		// 36: "Small tech fuzz blip"
		// 37: "Small click bleep (change to lightswitch)"
		// 40: "Combine door lock - locked"
		// 41: "Combine blip growl"
		// 42: "Combine squick growl"
		// 43: "Combine whine purr"
		// 44: "Combine click talk"
		// 45: "Combine click growl fizz"
		// 46: "Combine click fizz (deny)"
		// 47: "Combine click talker"
	// ] // end unlocked_sound

	input Lock(void) : "Lock the button, preventing it from functioning."
	input Press(void) : "Activate the button as if it was pressed."
	input PressIn(void) : "Activate the button as if it was pressed, sending it to the bottom position."
	input PressOut(void) : "Unpress the button, sending it to the top position."
	input Unlock(void) : "Unlock the button, allowing it to function."

	output OnDamaged(void) : "Fired when the button is damaged. Does not correctly pass the !activator; the !activator is the PREVIOUS player to damage the button, not the current one."
	output OnIn(void) : "Fired when the button reaches the in/pressed position."
	output OnPressed(void) : "Fired when the button is pressed."
	output OnOut(void) : "Fired when the button reaches the out/released position."
	output OnUseLocked(void) : "Fired when the button is used while locked."
] // end SButton

@BaseClass = SMoveDir [
	movedir(angle) : "Move Direction (Pitch Yaw Roll)" : "0 0 0" : "The direction the entity will move when it is opened/pressed."
] // end SMoveDir

@BaseClass = SMoveLip [
	lip(integer) : "Lip" : 0 : "The amount, in units, of the entity to leave sticking out of the wall it recedes into when pressed. Negative values make the entity move even further."
] // end SMoveLip

@BaseClass base(STrainDiv, SToggle) = STrain [
	target(target_destination) : "First Stop Target" :  : "The name of the first path_track in the train's path. The train will spawn at this path_track and turn to face the direction indicated by the path's 'Orientation Type' setting."
	height(integer) : "Height Above Track" : 0 : "The height above the track that this train moves. The train will follow the path at this vertical offset." // TODO: Absolute or relative to the train's facing direction?
	dmg(integer) : "Blocking Damage" :  : "Amount of damage done to entities that block the movement of this entity, per frame."
	volume(float) : "Volume (0 - 10)" : 10 : "Volume of sounds emitted by this entity. 0 is totally silent, 10 is maximum loudness."

	input Stop(void) : "Stop the train."
] // end STrain

@SolidClass base(SBaseTrigger, SBaseDiv) color(255 150 50) = func_achievement : "Achievement area, such as the Log Jammin achievement in Snakewater. Hard-coded." [
    zone_id(integer) : "Zone ID" : 0 : "ID number for this zone (multiple zones can have the same number to group them)."
] // end func_achievement

@SolidClass base(SBaseLogical, SBaseDiv, SToggle) color(50 50 200) = func_areaportal : "A portal brush used to manage visibility in maps. Areaportals define areas, which are spaces that are connected in the map without crossing through world geometry or an areaportal. Both sides of a portal cannot touch the same area, otherwise an areaportal leak occurs. Each individual func_areaportal entity can only be composed of a single brush, and cannot cross the surface of a water brush; if creating an areaportal through water, position one areaportal above the water, and another below the water, with their faces aligned at the water's surface." [
	StartOpen(choices) : "Initial State" : 1 : "Initial state of this areaportal." = [
		0 : "Closed"
		1 : "Open"
	] // end StartOpen
	target(target_destination) : "Linked Door (Optional)" :  : "A prop_door_rotating or func_door whose open/closed state controls the on/off state of the portal."

	input Open(void) : "Open the portal. When the portal is open is can be seen through."
	input Close(void) : "Close the portal. When the portal is closed it cannot be seen through."
] // end func_areaportal

// TODO: Test and better describe some of these keyvalues
@SolidClass base(SBaseLogical, SBaseDiv) color(50 50 200) sphere(FadeStartDist) sphere(FadeDist) = func_areaportalwindow : "A special areaportal that fades out and closes over distance. If you seal off an area with them, when the viewer moves the specified distance away from them, they will go opaque and the parts inside the area will not be drawn. The 'Opaque Window' brush model should enclose the func_areaportalwindow so no parts of it are culled by the window. If you specify the optional Foreground Brush, then it should enclose the Opaque Window brush model." [
	PortalVersion(integer)	readonly	: "Portal Version"      : 1  : "(Don't change). Differentiates between shipping HL2 maps and maps using new engine features."
	FadeStartDist(integer) : "Fade Start Distance" : 256 : "Distance that the fade into the Rendered Window brush entity begins. The further back the player views, the more visible the brush entity will be."
	FadeDist(integer) : "Fade End Distance"   : 512 : "Distance at which the Rendered Window is fully visible, and the portal closes."
	target(target_destination) : "Rendered Window" :  : "The brush entity that fills the gap left by the portal when closed. Can be inside the areaportal."
	TranslucencyLimit(float) : "Translucency Limit"  : "0.0" : "Prevents the Rendered Window brush's visibility from ever going below this amount. Useful if your rendered window uses an opaque glass material."
	BackgroundBModel(target_destination) : "Foreground Brush"  :  : "Optional brush entity that is drawn after the fading brush model. This model should have alpha in its textures so you can see through it."

	input SetFadeStartDistance(integer) : "Sets fade start distance."
	input SetFadeEndDistance(integer) : "Sets fade end distance."
] // end func_areaportalwindow

// NOTE FROM FICOOL: All keyvalues are defined manually for this instead of taking from Breakable base as the keyvalue/input/output inconsistency is horrendous
// Except in your FGD you did inherit from Breakable??????
@SolidClass base(SBaseEntityOrigin, SBaseBreakableBrush, SBaseDynamicBrush) color(255 100 0) sphere(exploderadius) = func_breakable : "A brush entity that can be broken from damage, or an input." [
] // end func_breakable

@BaseClass = func_breakable_surf_keys [
	fragility(integer) : "Fragility" : 100 : "If the 'Surface Type' is set to Glass, this value sets how fragile the glass pieces are after the surface has been broken."
	surfacetype(choices) : "Surface Type" : 0 = [
		0 : "Glass"
		1 : "Tile"
	] // end surfacetype
] // end func_breakable_surf_keys
@SolidClass base(SBaseEntity, SBaseBreakableBrush, func_breakable_surf_keys, SBaseDynamicBrush, SClassDiv1) color(255 100 0) quadbounds() sphere(exploderadius) = func_breakable_surf : "A breakable surface, for partially breakable glass / tile / etc. All faces but the desired visible one must be marked as NODRAW and that face must be 4 sided. The material applied to the visible face must be set up to be breakable." [
	error(choices) readonly : "Error Type" : 0 : "Set automatically by Hammer to indicate an invalid surface." = [
		0 : "No Errors"
		1 : "Multiple Textured Faces - All except one must have nodraw"
		2 : "Non-Quad Face - Textured face must have 4 sides"
	] // end error
	upperleft(vector) readonly : "Upper-Left Corner" :  : "Read-only keyvalue for quad bound testing."
	upperright(vector) readonly : "Upper-Right Corner" :  : "Read-only keyvalue for quad bound testing."
	lowerleft(vector) readonly : "Lower-Left Corner" :  : "Read-only keyvalue for quad bound testing."
	lowerright(vector) readonly : "Lower-Right Corner" :  : "Read-only keyvalue for quad bound testing."

	spawnflags(flags) = [
		1 : "Physics damage decals" : 0
		2 : "Take damage from held objects" : 0
		4 : "Break on Pressure" : 0
		512 : "Break immediately upon taking physics damage" : 0
		1024 : "Don't take physics damage" : 0
		2048 : "Don't allow bullet penetration": 0
	] // end spawnflags

	input Shatter(vector) : "Shatter the window. Input a vector. First two coordinates are the X,Y center of the shattering (as float values between 0-1). The third coordinate is the radius of the shatter, in units."
] // end func_breakable_surf

@BaseClass = func_brush_keys [
	Solidity(choices) : "Solidity" : 0 : "Used to control the solidity/collision of these brushes. If set to Toggle, the entity will only be solid while it is enabled." = [
		1 : "Never Solid"
		0 : "Toggle"
		2 : "Always Solid"
	] // end Solidity
	excludednpc(string) : "NPC Class Excluded from Collisions" :  : "If an NPC classname is specified here, NPCs of that type won't collide with these brushes. In Episodic, you may also specify an individual entity's name."
	invert_exclusion(choices) : "Invert NPC Class Exclusion" : 0 : "If set, then the excluded NPC class will consider this brush solid, and all other NPC classes will consider it non-solid." = [
		0 : "No"
		1 : "Yes"
	] // end invert_exclusion
] // end func_brush_keys
@SolidClass base(SBaseEntityOrigin, SBaseDiv, SEnableDisable, SToggle, SSolidBSP, func_brush_keys, SBaseDynamicBrush) = func_brush : "An brush built entity with various features." [
	spawnflags(flags) = [
		2 : "Ignore Player +USE" : 1
	] // end spawnflags

	input SetExcluded(string) : "Change the NPC class excluded from collisions."
	input SetInvert(bool) : "Set the state of inversion for NPC class exclusion (0 or 1)."
] // end func_brush

@BaseClass = func_respawnroomvisualizer_keys [
	respawnroomname(target_destination) : "Associated Respawn Room" :  : "Optionally the name of a func_respawnroom that this entity is visualizing. This entity will have its team matched to that for the func_respawnroom, and will update its team if the func_respawnroom ever changes team. Overrides the Team keyvalue if specified."
	solid_to_enemies(choices) : "Solid to Enemies?" : 1 : "Determines if this area is solid to enemy players." = [
		0 : "No"
		1 : "Yes"
	] // end solid_to_enemies
] // end func_respawnroomvisualizer_keys
@SolidClass base(SBaseEntityOrigin, SBaseDiv, SEnableDisable, SToggle, STFTeam, func_respawnroomvisualizer_keys, SSolidBSP, func_brush_keys, SBaseDynamicBrush, func_brush) = func_respawnroomvisualizer : "Brush entity that is only solid and visible to players on the opposite team. Use this to mark/block off areas that should only be accessible to one team (i.e. respawn rooms).\n" +
	"NOTE: This entity will NOT automatically fade in/out textures at a distance; that effect is controlled by material proxies embedded in the VMT file of certain materials." [

	input SetSolid(bool) : "Set whether this area is solid to enemy players or not. 0 = No, 1 = Yes"
	//input RoundActivate(void) : "Forces this entity to activate. Fired automatically at the start of a round."
] // end func_respawnroomvisualizer

@SolidClass base(func_brush) = func_reflective_glass : "Used to produce perfectly reflective glass that renders the world + entities. Only 1 side of the brush can be reflective. Warning: cannot be used together with scenes that have water, and you can only have 1 reflective glass in your view frustum ( + pvs ) at a time. Players will not see their own reflection unless they are in thirdperson mode." [
] // end func_reflective_glass

@SolidClass base(SBaseEntityOrigin, SBaseDiv, SMoveDir, SMoveLip, SButton, SBaseDynamicBrush) = func_button : "A brush entity that's designed to be used for a player-useable button. When used by the player, it moves to a pressed position. Do not lock while pressed; it will not return when unlocked." [
	spawnflags(flags) = [
		256 : "Touch Activates": 0
		1024 : "+USE Activates" : 1
		512 : "Damage Activates": 1
		32 : "Toggle" : 0
		2048 : "Starts Locked" : 0
		4096 : "Sparks" : 0
		1 : "Don't Move" : 0
	] // end spawnflags
] // end func_button

@SolidClass base(SBaseTrigger, SBaseDiv, STFTeam) color(255 150 50) = func_capturezone : "Team Fortress 2 flag capture zone. The team defines which team can score here. Set Team to 'any' for Territory Control maps." [
	capturepoint(integer) : "Capture Point" : 1 : "Used for Attack/Defend and Territory Control maps ONLY. This is ignored for CTF maps. Set this value to the Capture Point number for this entity."
	capture_delay(float) : "Capture Delay" : "1.1" : "Only used on Player Destruction maps, this is the default number of seconds between captures when the player is touching the area."
	capture_delay_offset(float) : "Capture Delay Offset" : "0.025" : "Only used on Player Destruction maps, this is amount of time to reduce the Capture Delay per player on the server."
	shouldBlock(choices) : "Capture Blocking?" : 1 : "Only used on Player Destruction maps, this determines whether multiple teams in the zone will block each other from captures." = [
		0 : "No"
		1 : "Yes"
	] // end shouldBlock

	output OnCapture(void) : "Sent when a flag is captured in this zone."
	output OnCapTeam1(void) : "Sent when RED captures a flag in this zone."
	output OnCapTeam2(void) : "Sent when BLU captures a flag in this zone."
	output OnCapTeam1_PD(void) : "Sent when RED captures a point in this zone during Player Destruction mode."
	output OnCapTeam2_PD(void) : "Sent when BLU captures a point in this zone during Player Destruction mode."
] // end func_capturezone

@SolidClass base(SDoesNotFunction, SBaseTrigger, SBaseDiv, STFTeam) color(255 150 50) = func_changeclass : "Obsoleted by func_respawnroom. Intended to allow players to change class without suiciding in its volume, but actually suppresses class changes for the specified team, even via suicide. This effect lingers even after the player leaves the volume until the player dies or enters a func_respawnroom." [
] // end func_changeclass

@SolidClass base(SBaseLogical, SBaseDiv) = func_clip_vphysics : "An invisible brush entity which is considered solid to VPhysics objects (such as prop_physics). QPhysics objects (such as players) can pass freely. This entity cannot be moved via any means." [
	filtername(filterclass) : "Filter Name" :  : "Filter to use to see if activator collides with me. Entities which pass this filter will collide with this entity; allow means 'Allow to Block' for this entity."

	input Enable(void) : "Enable this entity."
	input Disable(void) : "Disable this entity."
] // end func_clip_vphysics

@SolidClass base(SBaseEntityOrigin, SBaseDiv, SSpeed, SMoveDir, SBaseDynamicBrush) = func_conveyor : "A brush entity that functions as a conveyor belt, with a moving surface. The surface material should have a ConveyorScroll Material Proxy, to synchronize the material movement and push effect." [
	spawnflags(flags) = [
		1 : "No Push" : 0
		2 : "Not Solid" : 0
	] // end spawnflags

	input ToggleDirection(void) : "Change direction of conveyor."
	input SetSpeed(integer) : "Sets Conveyor Speed."
] // end func_conveyor

@SolidClass base(SBaseTrigger) color(255 150 50) = func_croc : "Similar to trigger_hurt, but instead the player is gibbed by a sudden crocodile (dynamically spawned entity_croc) that jumps up from below upon touching. For the crocodile's splash effects to line up with the surface of a water brush, the surface of this trigger should be approximately 64HU above the water surface and the trigger should not be approachable from the sides." [
	output OnEat(void) : "Fired when the entity consumes a player."
	output OnEatRed(void) : "Fired when the entity consumes a player on the RED team."
	output OnEatBlue(void) : "Fired when the entity consumes a player on the BLU team."
] // end func_croc

@SolidClass color(0 175 0) = func_detail : "An entity that turns its brushes into detail brushes. Detail brushes do NOT contribute to visibility in the PVS. World geometry is not clipped to detail brushes, so if you have a small detail clump attached to a wall, the wall won't be cut up by the detail brush. func_detail is great for high-frequency brush geometry that's visual detail only. It is also ideal for reducing a map's VVIS compile time." [
] // end func_detail

@SolidClass = func_detail_blocker : "This entity only works with certain custom VBSP compilers. A brush entity that prevents displacement detail sprites from being placed by VBSP inside its volume. Is entirely unrelated to func_detail." [
] // end func_detail_blocker

@SolidClass base(SBaseEntityOrigin, SBaseDiv, SMoveDir, SMoveLip, SBaseBrushDoor, SBaseDynamicBrush) = func_door : "A brush entity for use as a player-useable door." [
] // end func_door

@SolidClass base(func_door) = func_water : "Legacy support for Half-Life. Same functionality as func_water_analog, although this entity borrows its code from func_door (rather than func_movelinear)." [
] // end func_water

// Doesn't actually have a lip keyvalue!!! (or at least doesnt recognize it)
@SolidClass base(SBaseEntityOrigin, SBaseDiv, SRotateDistance, SSolidBSP, SBaseBrushDoor, SBaseDynamicBrush) = func_door_rotating : "A brush entity for use as a rotating player-useable door. When opened along the Z-axis, the door will (by default) open away from the !activator. Using the One-Way spawnflag will lock the door's opening rotation to a specific direction; by default, the door will always open in the counterclockwise direction, when viewed facing down the door's axis of rotation from the positive side." [
	spawnflags(flags) = [
		64 : "X Axis - Rotate on the X axis (both unchecked = rotate on Z axis)" : 0
		128 : "Y Axis - Rotate on the Y axis (both unchecked = rotate on Z axis)" : 0
		16 : "One-Way - Door only opens in one direction (default counterclockwise)" : 1
		2 : "Reverse Direction - This door always opens in the opposite direction that it otherwise would" : 0
	] // end spawnflags
] // end func_door_rotating

// Origin keyvalue breaks stuff, don't inherit that
@SolidClass base(SBaseEntity, SBaseDiv) = func_dustcloud : "A brush entity that spawns a translucent dust cloud within its volume. Affected by env_wind. This entity is hardcoded to use the material particle/sparkles.vmt, which is extremely low-resolution. You may consider overriding this .vmt for improved appearance." [
	StartDisabled(choices) : "Start Disabled?" : 0 : "Don't create particles when spawned." = [
		0 : "No"
		1 : "Yes"
	] // end StartDisabled
	Color(color255) : "Particle Color (R G B)" : "255 255 255" : "Color of the particles."
	Alpha(integer) : "Particle Translucency (0 - 255)" : 30 : "Transluceny of the particles."
	SpawnRate(integer) : "Particle Per Second" : 40 : "Number of particles to spawn, per second."
	SpeedMax(string) : "Maximum Particle Speed" : 13 : "Maximum speed that the particles can move after spawning."
	LifetimeMin(string) : "Minimum Particle Lifetime" : 3 : "Minimum number of seconds until each particle dies. Particles live for a random duration between this and 'Maximum Particle Lifetime'."
	LifetimeMax(string) : "Maximum Particle Lifetime" : 5 : "Maximum number of seconds until each particle dies. Particles live for a random duration between 'Minimum Particle Lifetime' and this."
	DistMax(integer) : "Maximum Visible Distance" : 1024 : "Maximum distance at which particles are visible. They fade to translucent at this distance."
	SizeMin(string) : "Minimum Particle Size" : 100 : "This value determines the minimum size the particles can be."
	SizeMax(string) : "Maximum Particle Size" : 200 : "This value determines the maximum size the particles can be."
	FallSpeed(integer) : "Particle Fall Speed" : : "How fast the particles fall to the ground."
	Frozen(choices) : "Frozen?" : 0 : "When set, this entity spawns the number of particles in 'Particle Per Second' immediately, and then goes inactive." = [
		0 : "No"
		1 : "Yes"
	] // end Frozen

	input TurnOn(void) : "Turn on."
	input TurnOff(void) : "Turn off."
] // end func_dustcloud

// Origin keyvalue breaks stuff, don't inherit that
@SolidClass base(func_dustcloud) = func_dustmotes : "A brush entity that spawns sparkling dust motes within its volume. Affected by env_wind." [
] // end func_dustmotes

@SolidClass base(SBaseTrigger, SBaseDiv, STFTeam) color(255 150 50) = func_flag_alert : "An otherwise normal trigger entity which has additional outputs for detecting when a player of a certain team enters its zone carrying an item_teamflag, optionally with a minimum delay between outputs and an alarm. If assigned a team, it will not be triggered by players on that team.\n" +
	"TIP: func_flagdetectionzone provides similar functionality. It cannot natively filter for teams, but it detects a wider variety of events and passes the player as the !activator. func_flagdetectionzone is also used for the hatch alarm in MvM instead of this entity.\n" +
	"NOTE: This entity forcibly checks the 'Everything' spawnflag on itself when it spawns, even though it's OnTriggeredByTeam* outputs do not require any spawnflags to function. Like all triggers, its spawnflags can be overridden with AddOutput." [
	alert_delay(integer) : "Delay Before Reset" : 10 : "Amount of time, in seconds, after an OnTriggeredByTeam* output has fired before that output can fire again. Each team has their own independent timer. Unlike trigger_multiple's OnTrigger, the OnTriggeredByTeam* outputs do NOT fire on loop as long as a flag carrier is in the trigger."
	playsound(choices) : "Play Alert?" : 0 : "If Yes, whenever this entity is triggered by a flag carrier, 'Announcer.SecurityAlert' will be played to the opposite team." = [
		0 : "No"
		1 : "Yes"
	] // end playsound

	spawnflags(flags) = [
		64 : "Everything (not including physics debris) - Auto-checked when I spawn" : 0
		4096 : "Disallow TFBots and Puppet Bots" : 0
	] // end spawnflags

	output OnTriggeredByTeam1(void) : "Fired when a flag carrier on the RED team enters this zone. Does not fire if a flag is dropped/moved into the zone without a carrier, or if a flag is picked up inside the zone. Is not affected by filters or spawnflags. This trigger is the !activator, NOT the flag carrier."
	output OnTriggeredByTeam2(void) : "Fired when a flag carrier on the BLU team enters this zone. Does not fire if a flag is dropped/moved into the zone without a carrier, or if a flag is picked up inside the zone. Is not affected by filters or spawnflags. This trigger is the !activator, NOT the flag carrier."
] // end func_flag_alert

// NOTE FROM SPUD: func_flagdetectionzone technically inherits from CBaseTrigger, but also overrides a bunch of the standard trigger's functionality, making certain things (like filters and spawnflags) obsolete and changing the behavior of other stuff. That inheritance has been removed here, and the actually functional stuff has been hand-copied over with updated descriptions to boot.
@SolidClass base(SBaseEntityOrigin, SBaseDiv, SEnableDisable, SToggle, SClassDiv1) color(255 150 50) = func_flagdetectionzone : "A trigger entity that EXCLUSIVELY detects flag carriers in its zone, and has special outputs for detecting flag-related events in its zone. This trigger does not have any native filtering abilities beyond only detecting players carrying item_teamflags, but the TestActivator input on any filter can be used as a workaround with most outputs. It is also used for the hatch alarm in MvM.\n" +
	"TIP: func_flag_alert provides similar functionality. It has native team-filtering abilities and also functions as a normal trigger, although has a reduced variety of flag-related outputs, and its flag outputs do not pass the player as the !activator." [
	alarm(choices) : "Bomb Hatch Alarm?" : 0 : "Only functional in Mann vs Machine. If Yes, when the flag enters this zone, players will be warned that the bomb is nearing the hatch." = [
		0 : "No"
		1 : "Yes"
	] // end alarm

	input Disable(void) : "Disable this trigger. Unlike with normal triggers, this input does NOT properly fire OnEndTouch (or related outputs) for touching entities, which may cause the trigger to still think it is being touched once it is enabled. It is advised to use DisableAndEndTouch instead."
	input DisableAndEndTouch(void) : "Disable this trigger and fire OnEndTouch for any touching flag carriers. BUG: Will crash the server if called after the 'Disable' input was used while a flag carrier was inside!"
	input Enable(void) : "Enable this trigger. If the trigger was previously disabled, it will fire OnStartTouch for any touching flag carriers."
	input EndTouch(void) : "Behave as though the !caller entity just exited the trigger, firing OnEndTouch if the !caller was previously considered to be touching this trigger. The !caller of this input will become the !activator of the OnEndTouch output."
	input StartTouch(void) : "Behave as though the !caller entity just entered the trigger, firing OnStartTouch if the !caller is a flag carrier. The !caller of this input will become the !activator of the OnStartTouch output. OnStartTouch will be fired even if the trigger is disabled."
	input TouchTest(void) : "Test whether any flag carriers are currently touching this trigger, firing OnTouching if this is true and OnNotTouching otherwise."

	input Test(void) : "Test whether any flag carriers are currently touching this trigger, firing OnStartTouch and OnStartTouchFlag if this is true, and OnEndTouchAll and OnEndTouchFlag (but NOT OnEndTouch) otherwise, functioning similar to TouchTest. (Does not fire OnTouching or OnNotTouching.)"

	output OnEndTouch(void) : "Fires when a flag carrier stops touching this trigger or drops their flag within this zone."
	output OnEndTouchAll(void) : "Fires when a flag carrier stops touching this trigger or drops their flag within this zone, and no other flag carriers are touching it."
	output OnNotTouching(void) : "Fires when the TouchTest input is called and no flag carriers are touching this trigger. The trigger entity itself is the !activator (the previous !activator is not preserved)."
	output OnStartTouch(void) : "Fires when a flag carrier starts touching this trigger or picks up a flag within this zone."
	output OnStartTouchAll(void) : "Fires when a flag carrier starts touching this trigger or picks up a flag within this zone, and no other flag carriers are touching it."
	output OnTouching(void) : "Fires when the TouchTest input is called and at least one flag carrier is touching this trigger. The trigger entity itself is the !activator (the previous !activator is not preserved)."

	output OnDroppedFlag(void) : "Fires when a flag is dropped in the zone, either manually or by a player dying. The player that dropped the flag is the !activator of this output."
	output OnEndTouchFlag(void) : "Fires when a flag carrier stops touching this trigger or drops their flag within this zone, and no other flag carriers are touching it. Unlike with the other outputs, this trigger is the !activator, NOT the flag carrier. OnEndTouchAll functions identically, but correctly passes the !activator."
	output OnPickedUpFlag(void) : "Fires when a flag is picked up by a player in the zone."
	output OnStartTouchFlag(void) : "Fires when a flag carrier starts touching this trigger or picks up a flag within this zone, and no other flag carriers are touching it."
] // end func_flagdetectionzone

@SolidClass base(SBaseEntityOrigin, SBaseDiv, SEnableDisable, SToggle, STFTeam, SSolidBSP, SBaseDynamicBrush) = func_forcefield : "A brush entity that is only solid to players on the opposite team. Unlike func_respawnroomvisualizer, this entity is always visible to both teams." [
	spawnflags(flags) = [
		2 : "Ignore Player +USE" : 1
	] // end spawnflags
] // end func_forcefield

@BaseClass = func_guntarget_keys [
	target(target_destination) : "First Stop" :  : "The name of the first path_track entity in the path that this target should follow."
] // end func_guntarget_keys
@SolidClass base(SBaseEntityOrigin, SBaseDiv, SHealth, SSpeed, func_guntarget_keys, SBaseDynamicBrush) = func_guntarget : "This is a moving target that moves along a path of path_tracks. It can be shot and killed." [
	input Start(void) : "Start the target to move."
	input Stop(void) : "Stop the target from moving."
	input Toggle(void) : "Toggle the target between moving and stopped."

	output OnDeath(void) : "Fires when the target is killed."
] // end func_guntarget

@SolidClass base(SPreservedEntity, SBaseEntityOrigin, SBaseDynamicBrush) = func_illusionary : "Legacy support. Use func_brush instead. A basic brush entity which has no collisions to anything. WARNING: This entity will not be rotated currectly when used inside a (rotated) instance. Func_brush works fine." [
] // end func_illusionary

@BaseClass = func_lod_keys [
	DisappearDist(integer) : "Disappear Distance" : 2048 : "Distance at which these brushes should fade out."
] // end func_lod_keys
@SolidClass base(SBaseEntityOrigin, SBaseDiv, func_lod_keys, SBaseDynamicBrush) sphere(DisappearDist) = func_lod : "Brush-built model that fades out over a specified distance. Useful for creating world detail that doesn't need to be drawn far away, for performance reasons." [
] // end func_lod

@BaseClass = func_movelinear_keys [
	startposition(float) : "Start Position" : "0.0" : "Position of brush when spawned. The range is a value between 0.0 and 1.0, where 0 is the starting position and 1 is the starting position + move distance. Allows negative values and values larger than 1."
	movedistance(float) : "Move Distance" : 128 : "The distance from the starting point that the brush should move, in units."
	blockdamage(float) : "Blocking Damage" : 0 : "The amount of damage to do to any entity that blocks this entity, per frame."
	startsound(sound) : "Start Sound" :  : "Sound played when the brush starts moving."
	stopsound(sound) : "Stop Sound" :  : "Sound played when the brush stops moving."
] // end func_movelinear_keys
@SolidClass base(SBaseEntityOrigin, SBaseDiv, SSpeed, SMoveDir, func_movelinear_keys, SBaseDynamicBrush) = func_movelinear : "A brush entity that moves linearly along a given distance, in a given direction." [
	spawnflags(flags) = [
		8 : "Not Solid (does not allow physically-simulated objects to be attached)" : 0
	] // end spawnflags

	input Close(void) : "Move the brush to the starting position."
	input Open(void) : "Move the brush to the end position (starting position + (move direction * move distance))."

	output OnFullyOpen(void) : "Fired when the brush reaches the end position (starting position + (move direction * move distance))."
	output OnFullyClosed(void) : "Fired when the brush reaches the starting position."
	input SetPosition(float) : "Move the brush to a specific position between 0.0 and 1.0, where 0 is the starting position and 1 is the starting position + (move direction * move distance). Negative values are accepted and values above 1.0 and -1.0 will move in multiples of the set Move Distance."
	input SetSpeed(float) : "Set the speed and update immediately."
] // end func_movelinear

@SolidClass base(func_movelinear) = func_water_analog : "A water volume that moves linearly along a given distance, in a given direction, similarly to func_movelinear. Can be parented to other entities for more complex movement of the water volume, including rotation.\n" +
	"NOTE: Water textures with the Water shader do not render correctly on this entity; the only official TF2 water texture that does not use the Water shader is the TOP SIDE ONLY of water_hydro_cheap, which uses the LightmappedGeneric shader. The Refract shader can be alternatively used to simulate water refraction." [
	//WaveHeight(float) : "Wave Height" : "3.0" : "No functionality. Wave height of the water material."
] // end func_water_analog

@SolidClass base(func_movelinear) = momentary_door : "An alternate, obsolete classname for func_movelinear from Half-Life. A brush entity that moves linearly along a given distance, in a given direction." [
] // end momentary_door

@SolidClass base(SBaseEntityOrigin, SBaseDiv, SToggle) color(150 0 200) = func_nav_avoid : "Influence bots to avoid this region by increasing the pathfinding cost within it. Only affects navigation mesh squares which are fully contained within this entity's volume." [
	start_disabled(choices) : "Start Disabled?" : 0 = [
		0 : "No"
		1 : "Yes"
	] // end start_disabled
	team(choices) : "Team" : -2 : "Which team will pay attention to this entity." = [
		-2 : "Everyone"
		2 : "RED"
		3 : "BLU"
		5 : "Boss"
	] // end team
	tags(choices) : "Tags" :  : "A space-delimited list of tags. A tag is a label with no spaces. If a bot has at least one matching tag, it will pay attention to this entity. Automatic tags are listed here, but any tags can be specified. Automatic tags are not found on the bots tag list and can only be used with func_nav_avoid and func_nav_prefer." = [
		"bomb_carrier" : "bomb_carrier"
		"common" : "common (is NOT part of a mission)"
		"mission_sentry_buster" : "mission_sentry_buster"
		"mission_sniper" : "misison_sniper"
		"mission_spy" : "mission_spy"
		"scout" : "scout"
		"soldier" : "soldier"
		"pyro" : "pyro"
		"demoman" : "demoman"
		"heavyweapons" : "heavyweapons"
		"engineer" : "engineer"
		"medic" : "medic"
		"sniper" : "sniper"
		"spy" : "spy"
	] // end tags

	input Enable(void) : "Enable this entity."
	input Disable(void) : "Disable this entity."
] // end func_nav_avoid

@SolidClass base(func_nav_avoid) color(150 0 200) = func_nav_prefer : "Artificially makes bots prefer a certain area when choosing navigation paths. Only affects navigation mesh squares which are fully contained within this entity's volume." [
]

// TODO: Test
@SolidClass base(SBaseEntityOrigin, SBaseDiv, SEnableDisable) color(150 0 200) = func_nav_avoidance_obstacle : "A brush entity that tells bots to avoid navigation areas touching its volume." [
] // end func_nav_avoidance_obstacle

// TODO: Test
@SolidClass base(SBaseEntityOrigin, SBaseDiv) color(150 0 200) = func_nav_blocker : "A brush entity that can block navigation areas touching its volume." [
	teamToBlock(choices) : "Team(s) to block" : -1 : "Team(s) this entity should block" = [
		-1 : "Everyone"
		2 : "RED"
		3 : "BLU"
		5 : "Boss"
	] // end func_nav_blocker
	affectsFlow(choices) : "Affects Flow?" : 0 : "Does this func_nav_blocker block flow in the level? Only func_nav_blockers with this enabled will cause flow recomputation on blocking/unblocking." = [
		0 : "No"
		1 : "Yes"
	] // end affectsFlow

	input BlockNav(string) : "Starts blocking nav areas."
	input UnblockNav(void) : "Stops blocking nav areas."
] // end func_nav_blocker

// TODO: Is there any way to make this entity start disabled? Perhaps the keyvalue is named something esoteric? Maybe a spawnflag?
// TODO: Inherits from CBaseTrigger?
@SolidClass base(SBaseEntityOrigin, SBaseDiv, SToggle) color(150 0 200) = func_nav_prerequisite : "A brush entity that requires bots to perform a task before they can move through it. Always starts enabled. Seems to only work in Mann vs Machine." [
	// Doesn't do anything
	// start_disabled(choices) : "Start Disabled?" : 0 : "Stay dormant until activated with the Enable input." = [
		// 0 : "No"
		// 1 : "Yes"
	// ] // end start_disabled
	filtername(filterclass) : "Filter Name" :  : "A filter entity to test potential activators against. Only bots that pass this filter will have their behavior controlled."
	Task(choices) : "Task" : 2 : "What must be done to move through this volume. Bots will follow this task until the prerequisite is disabled, even after leaving the prerequisite's volume. The 'Wait' task does not actually override the bot's current objective, but causes it to pause occasionally on its path to its current objective (see 'Wait Time')." = [
		//1 : "Destroy Entity (Value = max range to engage, -1 = infinite)" // Does not work
		2 : "Move to Entity"
		3 : "Wait"
	] // end Task
	Entity(target_destination) : "Destination Entity" :  : "The entity to move to, if the Task is 'Move to Entity'. The bot will move to the destination and remain there until the prerequisite is disabled. If the destination is a brush entity, the bot will occasionally change position within the entity's volume."
	Value(float) : "Wait Time" : 0 : "The number of seconds to wait. If the task is 'Move to Entity', upon reaching its destination, the bot will wait this many seconds between changing positions (if the destination is a brush entity). If the Task is 'Wait', the bot will stop moving and wait this many seconds every time it enters a new navigation square. While waiting, the bot will still be permitted to engage enemies, and may strafe in combat."

	input Disable(void) : "Disable this entity, causing all bots controlled by this entity to return to their normal behavior."
	input Enable(void) : "Enable this entity and begin controlling the behavior of all bots touching its volume."
] // end func_nav_prerequisite

@SolidClass base(SBaseTrigger, SBaseDiv, STFTeam) color(255 150 50) = func_nobuild : "A trigger entity which prevents Engineers from building in the specific area it contains while enabled. The 'Team' keyvalue can be used to make this entity only block Engineers on the specified team.\n" +
	"NOTE: This entity only blocks engineers from placing/redeploying buildings in its area while enabled. If the entity is turned on or moved, any buildings already in its volume will not be destroyed.\n" +
	"NOTE: This entity's nobuild functionality can be enabled and disabled independently of its trigger functionality using the Toggle, SetActive, SetInactive, and ToggleActive inputs. The Disable, DisableAndEndTouch, and Enable inputs change the state of the trigger and the nobuild zone together, ensuring their states match after being fired." [
	AllowSentry(choices) : "Allow Sentries?" : 0 : " Are sentries allowed to be built in this volume?" = [
		0 : "No"
		1 : "Yes"
	] // end AllowSentry
	AllowDispenser(choices) : "Allow Dispensers?" : 0 : "Are dispensers allowed to be built in this volume?" = [
		0 : "No"
		1 : "Yes"
	] // end AllowDispenser
	AllowTeleporters(choices) : "Allow Teleporters?" : 0 : "Are teleporters allowed to be built in this volume?" = [
		0 : "No"
		1 : "Yes"
	] // end AllowTeleporters
	DestroyBuildings(choices) : "Destroy Buildings" : 0 : "Destroy buildings when activated" = [
		0 : "No"
		1 : "Yes"
	]

	input Disable(void) : "Disable both the trigger and the nobuild zone, allowing engineers to build in this zone. If the trigger was previously enabled, it will fire OnEndTouch for any touching entities, except entities which started touching via the StartTouch input."
	input DisableAndEndTouch(void) : "Disable this trigger and the nobuild zone, allowing engineers to build in this zone. This immediately fires OnEndTouch for any touching entities, including for entities which started touching via the StartTouch input. OnEndTouch fires marginally faster than with the Disable input."
	input Enable(void) : "Enable this trigger and the nobuild zone, preventing engineers from building in this zone. If the trigger was previously disabled, it will fire OnStartTouch for any touching entities."
	input Toggle(void) : "Toggle the state of the trigger, without toggling the state of the nobuild zone."

	input SetActive(void) : "Enable the nobuild zone, without Enabling the trigger. If the trigger was previously disabled, it will block engineer buildings, but will not fire any trigger-related outputs."
	input SetInactive(void) : "Disable the nobuild zone, without Disabling the trigger. If the trigger was previously enabled, it will no longer block engineer buildings, while still firing trigger-related outputs."
	input ToggleActive(void) : "Toggle the state of the nobuild zone, without toggling the trigger."
] // end func_nobuild

@SolidClass base(SBaseTrigger, SBaseDiv, STFTeam) color(255 150 50) = func_nogrenades : "An invisible, nonsolid trigger entity that nullifies the explosive damage of projectiles that explode within its volume. The explosion is suppressed, instead replaced by a small white flash. If a team is set, only that team's projectiles are nullified." [
] // end func_nogrenades

// Origin keyvalue breaks stuff, don't inherit that
@SolidClass base(SBaseLogical, SBaseDiv, SActivateDeactivate, SToggle) color(50 50 200) = func_occluder : "An occluder brush used to manage dynamic visibility in maps. Occluders perform real-time line-of-sight testing to block rendering of models (not brushes!) that are behind it. The blocking side of an occluder should be textured with 'toolsoccluder', while other sides should be textured with 'toolsnodraw'. Unlike areaportals, occluders can be free-standing and one-sided." [
] // end func_occluder

@SolidClass base(SBaseTrigger, SBaseDiv, STFTeam) color(255 150 50) = func_passtime_goal : "A goal for the PASStime gamemode.\n" +
	"BUG: Due to poor coding, the spawnflag values in Hammer are not the same as the spawnflag values in-game. When the entity spawns, it bit-shifts the spawnflags keyvalue to match the expected in-game values. A consequence of this bit-shifting is that the normal trigger spawnflags cannot be set in Hammer. Instead, this entity is hardcoded to select the 'Clients' and 'Physics Objects' spawnflags on spawn. The spawnflags can be changed via AddOutput. The in-game values for each goal spawnflag are written in parentheses with each flag's description; use these in your AddOutput sum rather than the values from turning off SmartEdit." [ // TODO: Does changing the spawnflags affect the ability of players to score?
	TeamNum(choices) : "Team" : 0 : "Which team can score here (not which team's side this goal is on!). Ignored if 'Points' is -1, in which case the ball will be reset regardless of team." = [
		0 : "0 - Any/Unassigned"
		1 : "1 - Spectator"
		2 : "2 - RED"
		3 : "3 - BLU"
		5 : "5 - Neutral/Boss"
	] // end TeamNum
	points(integer) : "Points" : 1 : "How many points the team gets for scoring here. -1 resets the ball without triggering any of the effects associated with scoring or firing any of this entity's OnScore* outputs."

	spawnflags(flags) = [
		1 : "Winning Goal - Scoring here wins the game (16,777,216)" : 0
		2 : "NOT a Throwing Goal - Do not let the ball score here if it is not being held (33,554,432)" : 0
		4 : "Run-In Goal - Let ball-carrying players score here (67,108,864)" : 0
		8 : "Tower Goal - Show special locked status on HUD (134,217,728)" : 0
	] // end spawnflags

	output OnScoreBlu(void) : "BLU scored here. Useful for doing any effects specific to this goal."
	output OnScoreRed(void) : "RED scored here. Useful for doing any effects specific to this goal."
] // end func_passtime_goal

@SolidClass base(SBaseTrigger, SBaseDiv, STFTeam) color(255 150 50) = func_passtime_goalie_zone : "Awards bonus points to any players on a matching team who intercept or steal the JACK/ball in the zone. Automatically checks the 'Clients' flag when it spawns." [
] // end func_passtime_goalie_zone

@SolidClass base(SBaseTrigger) color (255 150 50) = func_passtime_no_ball_zone : "Players which enter this zone will be forced to drop the JACK/ball (if they are carrying it) and will not be able to pick it up. Will not work if either the 'Clients' or 'Everything' spawnflags are not checked.\n" +
	"NOTE: This zone is not solid to the ball; the ball can still roll in here while not being carried. Official maps combine this entity with filtered func_clip_vphysics and trigger_push entities to prevent the ball from going into spawnrooms." [
] // end func_passtime_no_ball_zone

@BaseClass = func_physbox_keys [
	notsolid(choices) : "Solidity" : 0 : "If set, the object will pass through world geometry." = [
		0: "Solid to World"
		1: "Passes Through World"
	] // end notsolid
	preferredcarryangles(vector) : "Preferred Player-Carry Angles" : "0 0 0" : "If the 'Use Preferred Carry Angles' spawnflag is set, this angle is the angle which the object should orient to when the player picks it up, with the physgun or +use."
] // end func_physbox_keys
@SolidClass base(SBaseEntityOrigin, SPhysics, func_physbox_keys, SBaseBreakableBrush, SBaseDynamicBrush) color(255 100 0) sphere(exploderadius) = func_physbox : "A brush entity that is physically simulated." [
	health(integer) : "Health" : 0 : "Amount of damage this entity can take before dying, breaking, or opening."

	spawnflags(flags) = [
		4096 : "Start Asleep" : 1
		32768 : "Start Motion Disabled" : 0
		//131072 : "Enable motion on Physgun grab" : 0
		8388608 : "Prevent motion enable on player bump" : 0
		16384 : "Debris - Don't collide with the player or other debris" : 0
		65536 : "Use preferred carry angles" : 0
		262144 : "Not affected by rotor wash" : 0
		524288 : "Generate output on +use" : 0
		8192 : "Ignore +use for pickup" : 0
		//1048576 : "Physgun can always pick up. No matter what." : 0
		//2097152 : "Physgun is NOT allowed to pick this up." : 0
		//4194304 : "Physgun is NOT allowed to punt this object." : 0
	] // end spawnflags

	input ForceDrop(void) : "If this object is being carried by a player, with the physgun or +use, force it to be dropped."
	input SetMass(float) : "Set the mass of this object."

	output OnDamaged(void) : "Fired when this entity is damaged."
] // end func_physbox

// TODO: Debris flag doesn't work? Always seems to be non-solid to players, but interacts with non-debris triggers...
@SolidClass base(func_physbox) color(255 100 0) sphere(exploderadius) = func_physbox_multiplayer : "This class is the same as func_physbox, except the runtime collisions use a more bouncy method that avoids the prediction errors normal physics objects get, making it better for use in multiplayer games." [
] // end func_physbox_multiplayer

// Also doesn't have a lip, and the wait time seems to do fuck all...
@BaseClass = func_plat_keys [
	height(float) : "Height" : 0 :	"The distance (height) that this entity moves, in HU. If left as 0, this defaults to 26HU."
	volume(float) : "Volume (0 - 10)" : 10 : "Volume of sounds emitted by this entity. 0 is totally silent, 10 is maximum loudness."
] // end func_plat_keys
@SolidClass base(SBaseEntityOrigin, SBaseDiv, SSpeed, func_plat_keys, SStartStopSounds, SToggle, SBaseDynamicBrush) = func_plat : "A brush entity that moves vertically. The location it is placed in Hammer is its peak. When spawning in, it will immediately move to its lowest point, located <Height> Hammer Units below its peak. Use the inputs to make it move between those two points." [
	spawnflags(flags) = [
		1 : "Toggle" : 1
	] // end spawnflags

	input GoUp(void) : "Tells the platform to go up."
	input GoDown(void) : "Tells the platform to go down."
] // end func_plat

@BaseClass = func_platrot_keys [
	rotation(integer) : "Spin amount" : 180 : "The amount this platform should rotate as it moves, in degrees."
] // end func_platrot_keys
@SolidClass base(SBaseEntityOrigin, SBaseDiv, func_platrot_keys, SSpeed, func_plat_keys, SStartStopSounds, SToggle, SBaseDynamicBrush) = func_platrot : "A brush entity that moves vertically, and can rotate while doing so." [
	spawnflags(flags) = [
		1 : "Toggle" : 1
		64 : "Rotate on X Axis" : 0
		128 : "Rotate on Y Axis" : 0
	] // end spawnflags
] // end func_platrot

@SolidClass base(SBaseTrigger, SBaseDiv, STFTeam) color(255 150 50) = func_powerupvolume : "Players that touch this volume will gain critical hits for 30 seconds." [
] // end func_powerupvolume

// TODO: Test this. Does this do anything at all in TF2 (aside from potentially crash the game)?
// Yes it does work, and it does look great, but it also creates unbearable lag. -Brokk
@SolidClass base(SPreservedEntity, SBaseEntityOrigin, SBaseDiv) = func_precipitation : "A brush entity that creates rain, snow, or ash inside its volume.\n" +
	"WARNING: func_precipitation volumes shouldn't be placed in the same volume as func_smokevolume, as it will invoke a crash. ANOTHER WARNING: This entity creates large amounts of lag in TF2. Official maps use particle systems instead, and there are stock ones available for snow and rain." [
	renderamt(integer) : "Density (0 - 100%)" : 5 : "This is the amount of particles that fall down from top side of brush. However distance from first particle to second depends on a brush volume size!"
	rendercolor(color255) : "Color (R G B)" : "100 100 100" : "Color added to sprites which are rendered transparently (probably rain and snow particles)"
	preciptype(choices) : "Precipitation Type" : 0 : "" = [
		0 : "Rain"
		1 : "Snow"
		2 : "Ash"
		3 : "Snowfall"
	] // end preciptype
] // end func_precipitation

// TODO: Does nothing now?
// TODO: Seems to be linked to prop_physics_multiplayer, which always creates clientside physics props apparently? And if they spawn in this zone, they can respawn... sometimes? How do we trigger that?
// -Defined in physpropclientside.h and physpropclientside.cpp
// -Seems to be triggered on a loop based on cl_phys_props_respawnrate (in C_FuncPhysicsRespawnZone::ClientThink), but only for props that pass the criteria in C_FuncPhysicsRespawnZone::CanMovePropAt...?
//     -The player is further away than cl_phys_props_respawndist
//     -Can't see the prop
//     -And whatever the hell this means: engine->CullBox( vecMins + vecOrigin, vecMaxs + vecOrigin ) (just another part of the visibility check?)
// -There seems to be two independent methods via which clientside physics props are loaded from the map: C_PhysPropClientside::RecreateAll (called only on map load), and when the respawnzone thinks (noted above). Both seem to recreate the prop at its original position
// -Also if it has a model, it... becomes that model? And changes its size to that model? And then turns invisible? The fuck, why? (Seen in C_FuncPhysicsRespawnZone::KeyValue and C_FuncPhysicsRespawnZone::Initialize)
// TODO: This is all great conjecture, but none of it means anything if it doesn't behave that way in-game. TEST!
// According to ficool it is all nuked, disabled by an #ifdef 0 somewhere. But the console commands are in-game?
@SolidClass base(SBaseEntityOrigin) = func_proprrespawnzone : "Zone that handles respawning and distribution of clientside physics props. The classname is spelled correctly." [
] // end func_proprespawnzone

// TODO: Test
@BaseClass = func_pushable_keys [
	size(choices) : "Hull Size" : 0 = [
		0: "Point size"
		1: "Player size"
		2: "Big Size"
		3: "Player duck"
	] // end size
	friction(integer) : "Friction (0-400)" : 50 : "The amount of friction in the brush."
	buoyancy(integer) : "Buoyancy" : 20 : "The amount of buoyancy in the brush."
	target(target_destination) : "Target on Break" :  : "What entity to fire an input to when this brush breaks."
] // end BaseClass
@SolidClass base(SBaseEntityOrigin, SBaseDiv, func_pushable_keys, SBaseBreakableBrush, SBaseDynamicBrush) color(255 100 0) sphere(exploderadius) = func_pushable : "A pushable brush object with very primitive physics. Only moveable with +use inputs by player." [
	health(integer) : "Health" : 0 : "Amount of damage this entity can take before dying, breaking, or opening."

	spawnflags(flags) = [
		128 : "Breakable" : 0
	] // end spawnflags
] // end func_pushable

@SolidClass base(SBaseTrigger, SBaseDiv, STFTeam) color(255 150 50) = func_regenerate : "Regeneration/item resupply zone for players. Resets health and ammo and updates loadout." [
	associatedmodel(target_destination) : "Associated Model" :  : "The prop_dynamic that represents this zone in the world. The associated model should have appropriate 'open' and 'close' animations for when players interact with the zone."
] // end func_regenerate

@SolidClass base(SBaseTrigger) color(255 150 50) = func_respawnflag : "When a dropped item_teamflag or a player carrying an item_teamflag enters this area, the flag will be forced to return to its original position. Useful for deathpits or similar places the flag cannot be recovered from." [
] // end func_respawnflag

@SolidClass base(SBaseTrigger, SBaseDiv, STFTeam) color(255 150 50) = func_respawnroom : "Designates a respawn room for a team. Players whose team matches this entity will be able to change class and loadout without dying within its volume, and engineers are blocked from building in it." [
//duplicated Render Mode to set default to Color since that is the most common fix for render order issues and won't break anything else. -Brokk
rendermode(choices) : "Render Mode" : 1 : "Set a non-standard rendering mode on this entity. Some/most of these are intended for sprites, and may or may not work on other entities. See developer.valvesoftware.com/wiki/Render_Modes for more info." = [ // Declared in const.h
		0 : "Normal"
		1 : "Color"
		2 : "Texture"
		3 : "Glow"
		4 : "Solid/Alphatest"
		5 : "Additive"
		6 : "Environmental (Not drawn)"
		7 : "Additive Fractional Frame"
		8 : "Alpha Add"
		9 : "World Space Glow"
		10 : "Don't Render (EF_NODRAW)"
	] // end rendermode
	input SetActive(void) : "Sets the respawn room as active."
	input SetInactive(void) : "Sets the respawn room as inactive."
	input ToggleActive(void) : "Toggles the respawn room between active and inactive."
	//input RoundActivate(void) : "Forces this entity to activate. Fired automatically at the start of a round."
] // end func_respawnroom

@SolidClass base(SBaseEntityOrigin, SBaseDiv, SButton, SRotateDistance, SBaseDynamicBrush) = func_rot_button : "A brush entity that's designed to be used for a rotating player-useable button. When used by the player, it rotates to a pressed position. By default, this entity rotates in the counterclockwise direction, when viewed facing down the entity's axis of rotation from the positive side." [
	spawnflags(flags) = [
		256 : "Touch Activates": 0
		1024 : "+USE Activates" : 1
		512 : "Damage Activates": 1
		32 : "Toggle" : 1
		2048 : "Starts Locked" : 0
		4096 : "Sparks" : 0
		1 : "Not Solid" : 0
		2 : "Reverse Direction - Rotate clockwise instead of counterclockwise" : 0
		64 : "Rotate on X Axis" : 0
		128 : "Rotate on Y Axis" : 0
	] // end spawnflags
] // end func_rot_button

@BaseClass = func_rotating_keys [
	maxspeed(integer) : "Max Rotation Speed" : 100 : "The maximum rotation speed of the brushes, in degrees per second."
	fanfriction(integer) : "Friction (0 - 100%)" : 20 : "The amount of rotational friction, which determines how much quickly the rotator spins up/slows down. Value must be between 0 and 100. Higher values accelerate faster, lower values accelerate slower. Requires the Accelerate/Decelerate spawnflag to be checked to function."
	volume(integer) : "Volume (0 - 10)" : 10 : "Volume of sounds emitted by this entity. 0 is totally silent, 10 is maximum loudness."
	message(sound) : "Rotating Sound" :  : "Sound to play while rotating."
] // end func_rotating_keys
@SolidClass base(SBaseEntityOrigin, SBaseDiv, func_rotating_keys, SSolidBSP, SToggle, SBaseDynamicBrush) = func_rotating : "A simple rotating brush entity. By default, this entity rotates in the counterclockwise direction, when viewed facing down the entity's axis of rotation from the positive side." [
	spawnflags(flags) = [
		1 : "Start On"  : 1
		4 : "X Axis - Rotate on the X axis (both unchecked = rotate on Z axis)" : 0
		8 : "Y Axis - Rotate on the Y axis (both unchecked = rotate on Z axis)" : 0
		2 : "Reverse Direction - Rotate clockwise instead of counterclockwise" : 0
		16 : "Accelerate/Decelerate - Entity will accelerate/decelerate to/from max speed based on the Friction keyvalue" : 0
		//16 : "Clientside Rotation" : 1 // This flag dun got yeeted and replaced with Acc/Dec
		64 : "Not Solid" : 0
		32 : "Fan Pain - Damages touching players once per frame, faster speed = more damage (must be solid and rotating)" : 0
		128 : "Small Sound Radius - Use ATTN_IDLE (60dB)" : 0
		256 : "Medium Sound Radius - Use ATTN_STATIC (~67dB)" : 0
		512 : "Large Sound Radius - Use ATTN_NORM (~75dB) (Default)" : 1
	] // end spawnflags

	input SetSpeed(integer) : "Set the speed as a ratio of the specified Max Rotation Speed, where 0 is stopped and 1 is the Max Rotation Speed."
	input Start(void) : "Start the rotator rotating."
	input Stop(void) : "Stop the rotator from rotating."
	input StopAtStartPos(void) : "Stop the rotator from rotating when it gets around to the start position again (on its rotation axis)."
	input StartForward(void) : "Start the rotator rotating forward."
	input StartBackward(void) : "Start the rotator rotating backward."
	input Reverse(void) : "Reverse the direction of rotation of the rotator."
] // end func_rotating

// Origin keyvalue breaks stuff, don't inherit that
@SolidClass base(SBaseEntity, SBaseDiv) = func_smokevolume : "A brush entity that spawns smoke particles within its volume. Should not be placed in a func_precipitation, as it will cause crashes." [
	material(material) : "Material" : "particle/particle_smokegrenade" : "The material to use for the particles."
	Color1(color255) : "Particle Color1 (R G B)" : "255 255 255" : "Color to use for particles."
	Color2(color255) : "Particle Color2 (R G B)" : "255 255 255" : "Secondary color to use for particles."
	ParticleDrawWidth(float) : "Particle Draw Width (units)" : 120 : "The size of the particles, in units/units."
	ParticleSpacingDistance(float) : "Particle Spacing Distance (units)" : 80 : "The distance between the particles inside the volume. The lower the number, the denser the particles, and the more overdraw there will be. It is best to keep it as high as you can without it looking bad."
	Density(float) : "Density [0..1]" : 1 : ""
	DensityRampSpeed(float) : "Density Ramp Speed (seconds)" : 1 : "Time to go from density 0 to density 1, in seconds."
	RotationSpeed(float) : "Rotation Speed (degrees/sec)" : 10 : "The speed that the particles should rotate, in degrees per second."
	MovementSpeed(float) : "Movement Speed (units/sec)" : 10 : "The speed that the particles should move around, in units/units per second."

	spawnflags(flags) = [
		1 : "Emissive - Changes how the smoke particles are drawn. Emissive is 4 times more expensive to render, but prettier." : 0
	] // end spawnflags

	input SetRotationSpeed(float) : "Set the particle rotation speed (in degrees per second)."
	input SetMovementSpeed(float) : "Set the particle movement speed (in units per second)."
	input SetDensity(float) : "Set the particle density. It should be a range from 0 to 1."
] // end func_smokevolume

// TODO: Fuck it, another one on my list of entities to test
@SolidClass base(SBaseTrigger, SBaseDiv, STFTeam) color(255 150 50) = func_suggested_build : "Engineer suggested build area, used in training mode." [
	object_type(choices) : "Suggested Object" : 0 : "Suggested object to build in this area." = [
		0 : "Any"
		1 : "Sentry"
		2 : "Dispenser"
		3 : "Teleporter Entrance"
		4 : "Teleporter Exit"
	] // end object_type
	face_entity(target_destination) : "Must Face zrntity" :  : "If this is not empty, the built object must face the point this entity is at."
	face_entity_fov(float) : "Facing Angle FOV Tolerance" : 90 : "If the 'must face entity' property is set, this is the tolerance aka field-of-view when facing that entity (in degrees)."

	spawnflags(flags) = [
		1 : "Clients/Players/Bots - Also Built Object Never Dies" : 0
		//32 : "Only clients in vehicles" : 0
		//512 : "Only clients NOT in vehicles" : 0
		2 : "NPCs" : 0
		16 : "Only player ally NPCs" : 0
		//2048 : "Only NPCs in vehicles (respects player ally flag)" : 0
		4 : "Pushables": 0
		8 : "Physics Objects (not including physics debris)" : 0
		1024 : "Physics Debris" : 0
		64 : "Everything (not including physics debris)" : 0
		4096 : "Disallow TFBots and Puppet Bots" : 0
	] // end spawnflags

	//spawnflags(flags) =  [
	//	1 : "Built Object Never Dies" : 0
	//] // end spawnflags

	input SetActive(void) : "Disables the build area."
	input SetInactive(void) : "Enables the build area."
	input ToggleActive(void) : "Changes the build area from enabled to disabled or from disabled to enabled."

	output OnBuildingUpgraded(void) : "Sent when a building in this area is upgraded."
	output OnBuildInsideArea(void) : "Sent when the player builds an appropriate object inside a suggested area."
	output OnBuildNotFacing(void) : "Sent when the player builds an appropriate object inside a suggested area, but it has a bad orientation."
] // end func_suggested_build

@SolidClass base(SBaseEntityOrigin, SBaseDiv, SEnableDisable) color(150 0 200) = func_tfbot_hint : "Define 'hint' regions for TFBot behaviors." [ // TODO: MvM-specific or general-purpose?
	team(choices) : "Team" : -1 : "Which team will use this hint?" = [
		-2 : "Everyone"
		2 : "RED"
		3 : "BLU"
	] // end team
	hint(choices) : "Hint Type" : 0 : "What type of hint is this?" = [
		0 : "Sniper Spot (aim at hint origin)" // TODO: Does "aim at hint origin" work?
		1 : "Sentry Gun Spot (aim at hint origin)" // TODO: Does this work?
	] // end hint
] // end func_tfbot_hint

// TODO: i wanna test these
// Apparently Black Mesa uses this one a lot. Might be neat for TF2. Will test. -Brokk
@BaseClass = func_trackautochange_keys [
	height(integer) : "Travel Altitude" : 0 : "Travel distance, from top to bottom. If Start at Bottom flag is selected, the travel distance won't change from bottom to top, it will only make the platform start at bottom and awaits for func_tracktrain to arrive."
	rotation(integer) : "Spin Amount" : 0 : "The amount this platform should rotate as it moves, in degrees."
	train(target_destination) : "Train to Switch" :  : "Name of func_tracktrain this platform will transport to top/bottom track."
	toptrack(target_destination) : "Top Track" :  : "Name of last path_track of the top path (if Start at Bottom flag is selected, this is the name of the first path_track at the top path)."
	bottomtrack(target_destination) : "Bottom Track" :  : "Name of first path_track of the bottom track (if Start at Bottom flag is selected, this is the name of the last path_track at the bottom path)."
] // end func_trackautochange_keys
@SolidClass base(SBaseEntityOrigin, SBaseDiv, SSpeed, func_trackautochange_keys, SBaseDynamicBrush) = func_trackautochange : "An entity that works as a rotating/moving platform that will carry a train to a new track. It must be larger in X-Y planar area than the train, since it must contain the train within these dimensions in order to operate when the train is near it. The track will rotate around its own origin. This entity will only allowed to be triggered if the train is on a path_track which is a dead end. If Auto Activate Train flag is ticked, the train isn't paused at the top/bottom of the path after this func_trackautochange has finished it's movement. Instead, it will continue moving forward automatically and doesn't need to be reactivated. If Rotate Only is selected, the platform only rotates in place without travelling the specified altitude. The top and the bottom path_tracks should have their origin positioned in the same coordinates." [
	spawnflags(flags) = [
		8 : "Start at Bottom - Platform starts at the bottom instead at the top path_track if this flag is ticked" : 0
		16 : "Rotate Only - see description" : 0
		1 : "Auto Activate Train - see description" : 0
		2 : "Relink Track" : 0
		64 : "Rotate on X Axis" : 0
		128 : "Rotate on Y Axis" : 0
	] // end spawnflags

	input Trigger(void) : "Trigger the track change. The train must be currently on a dead end of a path_track."
] // end func_trackautochange

@SolidClass base(func_trackautochange) = func_trackchange : "An entity that works as a rotating/moving platform that will carry a train to a new track. It must be larger in X-Y planar area than the train, since it must contain the train within these dimensions in order to operate when the train is near it. The track will rotate around its own origin. A similar variant to this entity is func_trackautochange, however you can't trigger func_trackautochange unless the path_track is a dead end. If Auto Activate Train flag is ticked, the train isn't paused at the top/bottom of the path after this func_trackchange has finished it's movement. Instead, it will continue moving forward automatically and doesn't need to be reactivated. If selected, the platform only rotates in place without travelling the specified altitude. The top and the bottom path_tracks should have their origin positioned in the same coordinates." [
] // end func_trackchange

@BaseClass = func_tracktrain_keys_1 [
	speed(float) : "Initial Speed" : 100 : "The initial speed at which this entity moves, in HU/sec."
	startspeed(float) : "Max Speed" : 100 : "The maximum speed that this train can move, in HU/sec. Any speeds applied to this train, such as by path_tracks or SetSpeed inputs, will be clamped within this maximum value."
	velocitytype(choices) : "Change Velocity..." : 0 : "The method through which this train changes its velocity as it moves along the path." = [
		0 : "Instantaneously"
		1 : "Linear blend"
		2 : "Ease in/ease out"
	] // end velocitytype
	ManualSpeedChanges(choices) : "Manual Train Speed?" : 0 : "Train Speed is controlled through I/O only, and handles acceleration/deceleration times." = [
		0 : "Off"
		1 : "On"
	] // end ManualSpeedChanges
	ManualAccelSpeed(float) : "Manual Accel Speed" : 0 : "Units per second to accelerate to target speed."
	ManualDecelSpeed(float) : "Manual Decel Speed" : 0 : "Units per second to decelerate to target speed."
	orientationtype(choices) : "Change Angles..." : 1 : "The method through which this train changes its orientation as it moves along the path." = [
		0 : "Never (fixed orientation)"
		1 : "Near path_tracks"
		2 : "Linear blend"
		3 : "Ease in/ease out"
	] // end orientationtype
	wheels(integer) : "Distance Between the Wheels" : 50 : "How far ahead of the train's origin are the front wheels located (the rear wheels are assumed to be at the origin). Used for turning and stopping. Higher values will result in smoother turns."
	bank(string) : "Bank Angle on Turns" : "0" : "The angle at which the train will 'bank' or tilt when approaching a turn. Use positive or negative angle numbers close to 0 (ie. between -5 and +5, depending on left or right) to achieve realistic tilt angles."
] // end func_tracktrain_keys
@BaseClass = func_tracktrain_keys_2 [
	StartSound(sound) : "Start Sound" :  : "A sound played when the train starts moving."
	StopSound(sound) : "Stop Sound" :  : "A sound played when the train stops moving."
	MoveSound(sound) : "Move Sound" :  : "A sound that is played (and looped) while the train is moving."
	MovePingSound(sound) : "Move Ping Sound" :  : "A sound that is played more frequently as the train speeds up."
	MoveSoundMinTime(float) : "Min Ping Sound Interval" : 0 : "Minimum interval at which to play the move ping sound."
	MoveSoundMaxTime(float) : "Max Ping Sound Interval" : 0 : "Maximum interval at which to play the move ping sound."
	MoveSoundMinPitch(integer) : "Min Pitch (1-255, > 100 = higher)" : 60 : "The sound pitch value that the train will approach as it comes to a stop."
	MoveSoundMaxPitch(integer) : "Max Pitch (1-255, > 100 = higher)" : 200 : "The sound pitch value that the train will approach as it approaches its max speed (or 1000 units/second if the 'Use max speed for pitch shifting move sound' flag is not set)."
] // end func_tracktrain_keys_2
@SolidClass base(SBaseEntityOrigin, STrain, func_tracktrain_keys_1, SClassDiv1, func_tracktrain_keys_2, SBaseDynamicBrush) = func_tracktrain : "A moving platform that the player can ride. It follows a path of path_track entities. Engineers are blocked from building on this entity.\n" +
	"NOTE: Build your train so that the front is facing down the X axis (right in the 2D Top view). When it spawns it will automatically rotate to face the direction indicated by its starting path_track (unless Fixed Orientation is enabled, in which case the train will never rotate)." [
	dmg(integer) : "Blocking Damage" :  : "Amount of damage done to entities that block the movement of this entity, per frame. If the 'Not Blockable' keyvalue is checked, blocking damage is disabled."

	spawnflags(flags) = [
		1 : "No Pitch (Y-axis rotation) - Don't rotate forward/backward" : 0
		16 : "Fixed Orientation - Ignore rotation settings from path_tracks, use Pitch Yaw Roll only" : 0
		128 : "Rideable Train - Use BSP collision (unchecked = VPhysics)" : 0
		8 : "Passable - No collision to anything" : 0
		512 : "Not Blockable - Don't allow this train to be blocked by entities" : 1
		2 : "No User Control" : 0
		256 : "Use max speed for pitch shifting move sound" : 0
	] // end spawnflags

	input Resume(void) : "Resume the train moving in the current direction after it was stopped via the 'Stop' or 'Toggle' input."
	input Reverse(void) : "Reverse the direction of the train."
	input StartBackward(void) : "Start the train moving backward."
	input StartForward(void) : "Start the train moving forward."
	input Toggle(void) : "Toggle the train between start and stop."

	input SetSpeed(float) : "Set the speed of the train, as a ratio of max speed [0, 1]"
	input SetSpeedDir(float) : "Set the speed of the train, as a ratio of max speed. Negative values reverse the direction [-1, 1]"
	input SetSpeedDirAccel(float) : "Accel/Decel to the specified speed, as a ratio of max speed. Negative values reverse the direction [-1, 1]"
	input SetSpeedForwardModifier(float) : "Applies the given modifier to all forward speeds. [0, 1]"
	input SetSpeedReal(float) : "Set the speed of the train. Must be a positive value from 0 to max speed."
	input TeleportToPathTrack(target_destination) : "Teleport train to the designated path_track."

	output OnStart(void) : "Fired when the train starts moving in either direction."
	output OnNextPoint(void) : "Fires continuously when the train is moving to its next destination."
] // end func_tracktrain

@SolidClass base(func_tracktrain) = func_tanktrain : "Identical to func_tracktrain, but engineers can place buildings on this entity. Buildings placed on a func_tanktrain will automatically be parented to the train. This function works best with BSP collisions (Rideable Train flag), otherwise the train will slow when buildings are placed on it.\n" +
	"NOTE: Build your train so that the front is facing down the X axis (right in the 2D Top view). When it spawns it will automatically rotate to face the direction indicated by its starting path_track (unless Fixed Orientation is enabled, in which case the train will never rotate)." [
] // end func_tanktrain

// TODO: Description, is the only difference from func_tracktrain just less keyvalues?
@BaseClass = func_train_keys [
	wait(float) : "Wait Time" :  : "How long to wait before moving again. -1 will wait forever."
] // end func_train_keys
@SolidClass base(SBaseEntityOrigin, STrain, SSpeed, func_train_keys, SStartStopSounds, SBaseDynamicBrush) = func_train : "" [
	spawnflags(flags) = [
		8 : "Non-Solid" : 0
	] // end spawnflags
] // end func_train

// TODO: func_train or func_tracktrain? Does this work in tf2?
@BaseClass = func_traincontrols_keys [
	target(target_destination) : "Associated Train" :  : "The target train to control when the player +uses these controls."
] // end func_traincontrols_keys
@SolidClass base(SBaseEntityOrigin, SBaseDiv, func_traincontrols_keys, SBaseDynamicBrush) = func_traincontrols : "When +used by the player, this entity overrides the player's controls to let them drive a train." [
] // end func_traincontrols

@SolidClass base(SPreservedEntity, SBaseEntityOrigin, SBaseDiv, SEnableDisable) = func_upgradestation : "The upgrade station area for MvM, where players buy upgrades." [
] // end func_upgradestation

@SolidClass base(SBaseEntityOrigin, SBaseDiv, SEnableDisable) = func_vehicleclip : "Acts as a functional clip or barrier affecting vehicle entities, such as prop_vehicle_driveables. Should be used with the tools/toolscontrolclip texture." [
] // end func_vehicleclip

@SolidClass color(50 50 200) = func_viscluster : "Any visleaves touching this brush will have their visibility merged together into a single cluster. This means they will effectively be treated as one visleaf (despite not actually being merged). Can reduce VVIS compile time, at the cost of in-game performance if not used extremely carefully. Cannot cross the surface of a water plane or areaportal." [
] // end func_viscluster

@SolidClass base(SPreservedEntity, SBaseEntityOrigin, SBaseDynamicBrush) = func_wall : "Legacy support for Half-Life. Use func_brush instead. A general brush entity." [
] // end func_wall

@SolidClass base(func_wall, SToggle) = func_wall_toggle : "Legacy support for Half-Life. Use func_brush instead. A general brush entity which can be toggled." [
	spawnflags(flags) = [
		1 : "Starts Invisible" : 0
	] // end spawnflags
] // end func_wall_toggle

@BaseClass = func_weight_button_keys [
	WeightToActivate(float) : "Weight to Activate" :  : "Amount of weight required before this button activates, in KG."
] // end func_weight_button_keys
@SolidClass base(SBaseEntityOrigin, SBaseDiv, func_weight_button_keys, SBaseDynamicBrush) = func_weight_button : "A button which activates after a specified amount of weight is applied." [
	output OnPressed(void) : "Fired when the button is touching enough weight."
	output OnReleased(void) : "Fired when the button was pressed, but weight was removed."
] // end func_weight_button



	// GAME ENTITIES //

//hmm can you use a filter to not count spectators? -Brokk
@SolidClass base(SBaseEntityOrigin) = game_zone_player : "An entity used to count the number of players within its volume.\n" +
	"NOTE: This entity also counts spectating players, including detecting whether they are in the zone. A workaround for this is to use a trigger linked to a math_counter." [
	//master(string) : "Master" : : "Half-Life legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."

	input CountPlayersInZone(void) : "Count the number of players in the zone, and fire the corresponding outputs."

	output OnPlayerInZone(void) : "Fired whenever a count finds a player inside the zone, with the player as the !activator."
	output OnPlayerOutZone(void) : "Fired whenever a count finds a player outside the zone, with the player as the !activator."
	output PlayersInCount(integer) : "Fired after a count, and contains the number of players found inside the zone."
	output PlayersOutCount(integer) : "Fired after a count, and contains the number of players found outside the zone."
] // end game_zone_player



	// MOMENTARY ENTITIES //

@BaseClass = momentary_rot_button_keys [
	returnspeed(integer) : "Auto-Return Speed" : 15 : "If the 'Toggle' spawnflag is not set, the speed at which the wheel auto-returns when left alone, in degrees per second. Enables the Toggle spawnflag automatically if this is 0."
	startposition(float) : "Start Position" : "0.0" : "Position when spawned. The value is a float between 0.0 and 1.0, where 0 is its unpressed position and 1 is its fully pressed position."
	startdirection(choices) : "Start Direction" : -1 : "Which way the entity rotates while being pressed, when viewed facing down the entity's axis of rotation FROM the positive side." = [
		-1 : "Counterclockwise"
		1 : "Clockwise"
	] // end startdirection
	//master(string) : "Master (Obsolete)" : : "Half-Life legacy support: The name of a master entity. If the master hasn't been activated, this button cannot be used."
	// sounds(choices) : "Sounds" : 0 = [
		// 0 : "None (Silent)"
		// 1 : "Big zap & Warmup"
		// 2 : "Access Denied"
		// 3 : "Access Granted"
		// 4 : "Quick Combolock"
		// 5 : "Power Deadbolt 1"
		// 6 : "Power Deadbolt 2"
		// 7 : "Plunger"
		// 8 : "Small zap"
		// 9 : "Keycard Sound"
		// 10 : "Buzz"
		// 11 : "Buzz Off"
		// 12 : "Latch locked"
		// 13 : "Latch Unlocked"
		// 14 : "Lightswitch"
		// 15 : "Small bleek"
		// 16 : "Small deny"
		// 17 : "Small doop"
		// 18 : "Small tech deny"
		// 19 : "Click and combine screen fuzz"
		// 20 : "Roomy beep"
		// 21 : "Lever or Wheel: turn + move sqeek"
		// 22 : "Lever or Wheel: latch + release gas"
		// 23 : "Lever or Wheel: ratchet + sqeek"
		// 24 : "Lever or Wheel: large ratchet"
		// 25 : "Lever or Wheel: clanky + gas release"
		// 26 : "Lever or Wheel: latch + large metal thud"
		// 27 : "Lever or Wheel: smaller ratchet"
		// 28 : "Lever or Wheel: smaller lever move"
		// 31 : "Shock buzz"
		// 32 : "Clickbeep"
		// 33 : "Tech blip"
		// 34 : "Clickbeepbeep open"
		// 35 : "Small high blip"
		// 36 : "Small tech fuzz blip"
		// 37 : "Small click bleep (change to lightswitch)"
		// 40 : "Combine door lock - locked"
		// 41 : "Combine blip growl"
		// 42 : "Combine squick growl"
		// 43 : "Combine whine purr"
		// 44 : "Combine click talk"
		// 45 : "Combine click growl fizz"
		// 46 : "Combine click fizz (deny)"
		// 47 : "Combine click talker"
	// ] // end sounds
] // end momentary_rot_button_keys
@SolidClass base(SBaseEntityOrigin, SBaseDiv, SRotateDistance, SSpeed, momentary_rot_button_keys, SSolidBSP, SBaseDynamicBrush) = momentary_rot_button : "A rotating button that can be rotated to arbitrary positions between its start and end angles." [
	spawnflags(flags) = [
		1024 : "+USE Activates" : 1
		32 : "Toggle - Alternates rotation direction with each +use (disables auto return)" : 0
		2048 : "Starts Locked" : 0
		8192 : "Jiggle when used while locked" : 0
		1 : "Not Solid" : 0
		64 : "Rotate on X Axis" : 0
		128 : "Rotate on Y Axis" : 0
	] // end spawnflags

	input Disable(void) : "Disable this button."
	input Enable(void) : "Enable this button."
	input Lock(void) : "Lock the button, preventing it from functioning."
	input SetPosition(float) : "Move to a position. The parameter must be a value between 0 and 1, where 0 is the unrotated position and 1 is the rotated position + 'Distance'."
	input SetPositionImmediately(float) : "Immediately teleport to a position. The parameter must be a value between 0 and 1, where 0 is the unrotated position and 1 is the rotated position + 'Distance'."
	input Unlock(void) : "Unlock the button, allowing it to function."
	input _DisableUpdateTarget(void) : "Suppress the 'Position' input from firing when the button moves."
	input _EnableUpdateTarget(void) : "Allow the 'Position' input to continue firing after being disabled with '_DisableUpdateTarget'."

	output OnFullyClosed(void) : "Fired when the button has reached position 1, the rotated position + 'Distance'."
	output OnFullyOpen(void) : "Fired when the button has reached position 0, the unrotated starting position."
	output OnPressed(void) : "Fired when the button is first pressed."
	output OnReachedPosition(void) : "Fired when the button has reached a position specified by a 'SetPosition' input."
	output OnUnpressed(void) : "Fired when the button is first released from being pressed."
	output Position(float) : "Fired constantly whenever the button is moving. The parameter is the position of the button, as a float from 0.0 to 1.0."
] // end momentary_rot_button



	// TRIGGER ENTITIES //

// CBaseVPhysicsTrigger
@BaseClass base(SBaseEntity, STrigger) color(255 150 50) = SBaseTriggerPhysics [
	spawnflags(flags) = [
		1 : "Clients/Players/Bots" : 1 //only a true masochist would make an FGD that does not have this set to 1 -Brokk
		//32 : "Only clients in vehicles" : 0
		//512 : "Only clients NOT in vehicles" : 0
		2 : "NPCs" : 0
		16 : "Only player ally NPCs" : 0
		//2048 : "Only NPCs in vehicles (respects player ally flag)" : 0
		4 : "Pushables": 0
		8 : "Physics Objects (not including physics debris)" : 0
		1024 : "Physics Debris" : 0
		64 : "Everything (not including physics debris)" : 0
		// TODO: Are we SURE this does nothing? It seems to certainly do stuff in code...
		// CBaseVPhysicsTrigger::CreateVPhysics() and CBaseEntity::VPhysicsInitStatic() code indicate that this flag is effectively checked if the trigger spawns with a parent. Let's try dynamically assigning it one...
		4096 : "Can Move - Auto-checked if this spawns with a parent" : 0 // VPhysics triggers are supposed to have this, but they don't seem to break if this is unchecked while they move.
	] // end spawnflags
] // end SBaseTriggerPhysics

@SolidClass base(SBaseTrigger) color(255 150 50) = trigger : "A basic trigger. No special purpose. Doesn't seem to function as a physical trigger, but the StartTouch and EndTouch inputs work." [
] // end trigger

// TODO: BigfootBeto has mentioned having issues with this entity before, even though it is certainly functional. What issues did he experience? Maybe it doesn't like weapon attributes?
// TODOP: If a player dies in this trigger, that doesn't count as EndTouching it? And if you Disable(AndEndTouch) inside the trigger while a player that was in the trigger is dead, it crashes? What causes this? Maybe it can't remove the attribute from a dead player...?
//2023 update: Never heard of the above issues in all this time. Seems to be fine. -Brokk
@SolidClass base(SBaseTrigger, SBaseDiv) color(255 150 50) = trigger_add_or_remove_tf_player_attributes : "A trigger that will add or remove attributes on players. See wiki.teamfortress.com/wiki/List_of_item_attributes for a list and description of attributes." [
	attribute_name(choices) : "Attribute Name" :  : "The attribute name (NOT the attribute class). See wiki.teamfortress.com/wiki/List_of_item_attributes for a list with descriptions of each." = [
		"absorb damage while cloaked" : "absorb damage while cloaked"
		"accepted wedding ring account id 1" : "accepted wedding ring account id 1"
		"accepted wedding ring account id 2" : "accepted wedding ring account id 2"
		"accuracy scales damage" : "accuracy scales damage"
		"active health degen" : "active health degen"
		"active health regen" : "active health regen"
		"add cloak on hit" : "add cloak on hit"
		"add cloak on kill" : "add cloak on kill"
		"add head on hit" : "add head on hit"
		"add jingle to footsteps" : "add jingle to footsteps"
		"add onhit addammo" : "add onhit addammo"
		"add uber charge on hit" : "add uber charge on hit"
		"add_head_on_kill" : "add_head_on_kill"
		"additional halloween response criteria name" : "additional halloween response criteria name"
		"afterburn duration bonus" : "afterburn duration bonus"
		"afterburn duration penalty" : "afterburn duration penalty"
		"afterburn immunity" : "afterburn immunity"
		"aiming knockback resistance" : "aiming knockback resistance"
		"aiming movespeed decreased" : "aiming movespeed decreased"
		"aiming movespeed increased" : "aiming movespeed increased"
		"aiming no flinch" : "aiming no flinch"
		"air dash count" : "air dash count"
		"air jump on attack" : "air jump on attack"
		"airblast cost decreased" : "airblast cost decreased"
		"airblast cost increased" : "airblast cost increased"
		"airblast cost scale hidden" : "airblast cost scale hidden"
		"airblast disabled" : "airblast disabled"
		"airblast pushback scale" : "airblast pushback scale"
		"airblast vertical pushback scale" : "airblast vertical pushback scale"
		"airblast vertical vulnerability multiplier" : "airblast vertical vulnerability multiplier"
		"airblast vulnerability multiplier" : "airblast vulnerability multiplier"
		"airblast vulnerability multiplier hidden" : "airblast vulnerability multiplier hidden"
		"airblast_deflect_projectiles_disabled" : "airblast_deflect_projectiles_disabled"
		"airblast_destroy_projectile" : "airblast_destroy_projectile"
		"airblast_give_teammate_speed_boost" : "airblast_give_teammate_speed_boost"
		"airblast_pushback_disabled" : "airblast_pushback_disabled"
		"airblast_pushback_no_stun" : "airblast_pushback_no_stun"
		"airblast_pushback_no_viewpunch" : "airblast_pushback_no_viewpunch"
		"airblast_put_out_teammate_disabled" : "airblast_put_out_teammate_disabled"
		"airblast_turn_projectile_to_ammo" : "airblast_turn_projectile_to_ammo"
		"allow_halloween_offering" : "allow_halloween_offering"
		"allowed in medieval mode" : "allowed in medieval mode"
		"alt fire teleport to spawn" : "alt fire teleport to spawn"
		"alt-fire disabled" : "alt-fire disabled"
		"always tradable" : "always tradable"
		"always_transmit_so" : "always_transmit_so"
		"ammo becomes health" : "ammo becomes health"
		"ammo gives charge" : "ammo gives charge"
		"ammo regen" : "ammo regen"
		"aoe_deflection" : "aoe_deflection"
		"applies snare effect" : "applies snare effect"
		"apply look velocity on damage" : "apply look velocity on damage"
		"apply z velocity on damage" : "apply z velocity on damage"
		"armor piercing" : "armor piercing"
		"arrow heals buildings" : "arrow heals buildings"
		"attach particle effect" : "attach particle effect"
		"attach particle effect static" : "attach particle effect static"
		"Attack not cancel charge" : "Attack not cancel charge"
		"attack projectiles" : "attack projectiles"
		"attack_minicrits_and_consumes_burning" : "attack_minicrits_and_consumes_burning"
		"auto fires full clip" : "auto fires full clip"
		"auto fires full clip all at once" : "auto fires full clip all at once"
		"auto fires full clip penalty" : "auto fires full clip penalty"
		"auto fires when full" : "auto fires when full"
		"axtinguisher properties" : "axtinguisher properties"
		"back headshot" : "back headshot"
		"backstab shield" : "backstab shield"
		"become fireproof on hit by fire" : "become fireproof on hit by fire"
		"bidirectional teleport" : "bidirectional teleport"
		"blast dmg to self increased" : "blast dmg to self increased"
		"Blast radius decreased" : "Blast radius decreased"
		"Blast radius increased" : "Blast radius increased"
		"bleeding duration" : "bleeding duration"
		"bombinomicon effect on death" : "bombinomicon effect on death"
		"boost on damage" : "boost on damage"
		"boots falling stomp" : "boots falling stomp"
		"bot custom jump particle" : "bot custom jump particle"
		"bot medic uber deploy delay duration" : "bot medic uber deploy delay duration"
		"bot medic uber health threshold" : "bot medic uber health threshold"
		"breadgloves properties" : "breadgloves properties"
		"build rate bonus" : "build rate bonus"
		"building cost reduction" : "building cost reduction"
		"building instant upgrade" : "building instant upgrade"
		"bullets per shot bonus" : "bullets per shot bonus"
		"burn damage earns rage" : "burn damage earns rage"
		"can overload" : "can overload"
		"can shuffle crate contents" : "can shuffle crate contents"
		"cancel falling damage" : "cancel falling damage"
		"cannonball push back" : "cannonball push back"
		"cannot be backstabbed" : "cannot be backstabbed"
		"cannot delete" : "cannot delete"
		"cannot disguise" : "cannot disguise"
		"cannot giftwrap" : "cannot giftwrap"
		"cannot pick up buildings" : "cannot pick up buildings"
		"cannot pick up intelligence" : "cannot pick up intelligence"
		"cannot restore" : "cannot restore"
		"cannot trade" : "cannot trade"
		"cannot_transmute" : "cannot_transmute"
		"canteen specialist" : "canteen specialist"
		"CARD: damage bonus" : "CARD: damage bonus"
		"CARD: dmg taken from bullets reduced" : "CARD: dmg taken from bullets reduced"
		"CARD: health regen" : "CARD: health regen"
		"CARD: move speed bonus" : "CARD: move speed bonus"
		"centerfire projectile" : "centerfire projectile"
		"charge impact damage decreased" : "charge impact damage decreased"
		"charge impact damage increased" : "charge impact damage increased"
		"charge meter on hit" : "charge meter on hit"
		"charge recharge rate increased" : "charge recharge rate increased"
		"charge time decreased" : "charge time decreased"
		"charge time increased" : "charge time increased"
		"charged airblast" : "charged airblast"
		"class select override vcd" : "class select override vcd"
		"cleaver description" : "cleaver description"
		"clip size bonus" : "clip size bonus"
		"clip size bonus upgrade" : "clip size bonus upgrade"
		"clip size penalty" : "clip size penalty"
		"clip size penalty HIDDEN" : "clip size penalty HIDDEN"
		"clip size upgrade atomic" : "clip size upgrade atomic"
		"clipsize increase on kill" : "clipsize increase on kill"
		"cloak consume rate decreased" : "cloak consume rate decreased"
		"cloak consume rate increased" : "cloak consume rate increased"
		"cloak regen rate decreased" : "cloak regen rate decreased"
		"cloak regen rate increased" : "cloak regen rate increased"
		"cloak_consume_on_feign_death_activate" : "cloak_consume_on_feign_death_activate"
		"closerange backattack minicrits" : "closerange backattack minicrits"
		"collection bits DEPRECATED" : "collection bits DEPRECATED"
		"community description" : "community description"
		"Construction rate decreased" : "Construction rate decreased"
		"Construction rate increased" : "Construction rate increased"
		"cosmetic taunt sound" : "cosmetic taunt sound"
		"cosmetic_allow_inspect" : "cosmetic_allow_inspect"
		"counts as assister is some kind of pet this update is going to be awesome" : "counts as assister is some kind of pet this update is going to be awesome" // well at least someone at valve was having a good time
		"crate generation code" : "crate generation code"
		"crit does no damage" : "crit does no damage"
		"crit forces victim to laugh" : "crit forces victim to laugh"
		"crit from behind" : "crit from behind"
		"crit kill will gib" : "crit kill will gib"
		"crit mod disabled" : "crit mod disabled"
		"crit mod disabled hidden" : "crit mod disabled hidden"
		"crit on hard hit" : "crit on hard hit"
		"crit vs burning players" : "crit vs burning players"
		"crit vs disguised players" : "crit vs disguised players"
		"crit vs non burning players" : "crit vs non burning players"
		"crit vs stunned players" : "crit vs stunned players"
		"crit vs wet players" : "crit vs wet players"
		"crit_dmg_falloff" : "crit_dmg_falloff"
		"crit_vs_burning_FLARES_DISPLAY_ONLY" : "crit_vs_burning_FLARES_DISPLAY_ONLY"
		"critboost" : "critboost"
		"critboost on kill" : "critboost on kill"
		"crits_become_minicrits" : "crits_become_minicrits"
		"currency bonus" : "currency bonus"
		"custom desc attr" : "custom desc attr"
		"custom employee number" : "custom employee number"
		"custom name attr" : "custom name attr"
		"custom projectile model" : "custom projectile model"
		"custom texture hi" : "custom texture hi"
		"custom texture lo" : "custom texture lo"
		"custom_paintkit_seed_hi" : "custom_paintkit_seed_hi"
		"custom_paintkit_seed_lo" : "custom_paintkit_seed_lo"
		"damage all connected" : "damage all connected"
		"damage applies to sappers" : "damage applies to sappers"
		"damage blast push" : "damage blast push"
		"damage bonus" : "damage bonus"
		"damage bonus bullet vs sentry target" : "damage bonus bullet vs sentry target"
		"damage bonus HIDDEN" : "damage bonus HIDDEN"
		"damage bonus vs burning" : "damage bonus vs burning"
		"damage bonus while disguised" : "damage bonus while disguised"
		"damage causes airblast" : "damage causes airblast"
		"damage force increase" : "damage force increase"
		"damage force increase hidden" : "damage force increase hidden"
		"damage force increase text" : "damage force increase text"
		"damage force reduction" : "damage force reduction"
		"damage penalty" : "damage penalty"
		"damage penalty on bodyshot" : "damage penalty on bodyshot"
		"deactive date" : "deactive date"
		"decapitate type" : "decapitate type"
		"decoded by itemdefindex" : "decoded by itemdefindex"
		"deflection size multiplier" : "deflection size multiplier"
		"deploy time decreased" : "deploy time decreased"
		"deploy time increased" : "deploy time increased"
		"DEPRECATED socketed item definition id DEPRECATED " : "DEPRECATED socketed item definition id DEPRECATED "
		"disable fancy class select anim" : "disable fancy class select anim"
		"disable weapon hiding for animations" : "disable weapon hiding for animations"
		"disable weapon switch" : "disable weapon switch"
		"disguise damage reduction" : "disguise damage reduction"
		"disguise no burn" : "disguise no burn"
		"disguise on backstab" : "disguise on backstab"
		"disguise speed penalty" : "disguise speed penalty"
		"display duck leaderboard" : "display duck leaderboard"
		"dmg bonus vs buildings" : "dmg bonus vs buildings"
		"dmg bonus while half dead" : "dmg bonus while half dead"
		"dmg falloff decreased" : "dmg falloff decreased"
		"dmg falloff increased" : "dmg falloff increased"
		"dmg from melee increased" : "dmg from melee increased"
		"dmg from ranged reduced" : "dmg from ranged reduced"
		"dmg penalty vs buildings" : "dmg penalty vs buildings"
		"dmg penalty vs nonburning" : "dmg penalty vs nonburning"
		"dmg penalty vs nonstunned" : "dmg penalty vs nonstunned"
		"dmg penalty vs players" : "dmg penalty vs players"
		"dmg penalty while half alive" : "dmg penalty while half alive"
		"dmg pierces resists absorbs" : "dmg pierces resists absorbs"
		"dmg taken from blast increased" : "dmg taken from blast increased"
		"dmg taken from blast reduced" : "dmg taken from blast reduced"
		"dmg taken from bullets increased" : "dmg taken from bullets increased"
		"dmg taken from bullets reduced" : "dmg taken from bullets reduced"
		"dmg taken from crit increased" : "dmg taken from crit increased"
		"dmg taken from crit reduced" : "dmg taken from crit reduced"
		"dmg taken from fire increased" : "dmg taken from fire increased"
		"dmg taken from fire reduced" : "dmg taken from fire reduced"
		"dmg taken from fire reduced on active" : "dmg taken from fire reduced on active"
		"dmg taken increased" : "dmg taken increased"
		"dragons fury negative properties" : "dragons fury negative properties"
		"dragons fury neutral properties" : "dragons fury neutral properties"
		"dragons fury positive properties" : "dragons fury positive properties"
		"drop health pack on kill" : "drop health pack on kill"
		"duck badge level" : "duck badge level"
		"duck rating" : "duck rating"
		"duckstreaks active" : "duckstreaks active"
		"duel loser account id" : "duel loser account id"
		"effect bar recharge rate increased" : "effect bar recharge rate increased"
		"electrical airblast DISPLAY ONLY" : "electrical airblast DISPLAY ONLY"
		"elevate quality" : "elevate quality"
		"elevate to unusual if applicable" : "elevate to unusual if applicable"
		"enables aoe heal" : "enables aoe heal"
		"end drop date" : "end drop date"
		"energy buff dmg taken multiplier" : "energy buff dmg taken multiplier"
		"energy weapon charged shot" : "energy weapon charged shot"
		"energy weapon no ammo" : "energy weapon no ammo"
		"energy weapon no deflect" : "energy weapon no deflect"
		"energy weapon no drain" : "energy weapon no drain"
		"energy weapon no hurt building" : "energy weapon no hurt building"
		"energy weapon penetration" : "energy weapon penetration"
		"engineer building teleporting pickup" : "engineer building teleporting pickup"
		"engineer rage on dmg" : "engineer rage on dmg"
		"engineer sentry build rate multiplier" : "engineer sentry build rate multiplier"
		"engineer teleporter build rate multiplier" : "engineer teleporter build rate multiplier"
		"engy building health bonus" : "engy building health bonus"
		"engy dispenser radius increased" : "engy dispenser radius increased"
		"engy disposable sentries" : "engy disposable sentries"
		"engy sentry damage bonus" : "engy sentry damage bonus"
		"engy sentry fire rate increased" : "engy sentry fire rate increased"
		"engy sentry radius increased" : "engy sentry radius increased"
		"event date" : "event date"
		"expiration date" : "expiration date"
		"explode_on_ignite" : "explode_on_ignite"
		"explosive sniper shot" : "explosive sniper shot"
		"extinguish earns revenge crits" : "extinguish earns revenge crits"
		"extinguish reduces cooldown" : "extinguish reduces cooldown"
		"extinguish restores health" : "extinguish restores health"
		"falling_impact_radius_pushback" : "falling_impact_radius_pushback"
		"falling_impact_radius_stun" : "falling_impact_radius_stun"
		"faster reload rate" : "faster reload rate"
		"fire particle blue" : "fire particle blue"
		"fire particle blue crit" : "fire particle blue crit"
		"fire particle red" : "fire particle red"
		"fire particle red crit" : "fire particle red crit"
		"fire rate bonus" : "fire rate bonus"
		"fire rate bonus HIDDEN" : "fire rate bonus HIDDEN"
		"fire rate bonus with reduced health" : "fire rate bonus with reduced health"
		"fire rate penalty" : "fire rate penalty"
		"fire rate penalty HIDDEN" : "fire rate penalty HIDDEN"
		"fire retardant" : "fire retardant"
		"fish damage override" : "fish damage override"
		"fists have radial buff" : "fists have radial buff"
		"fixed_shot_pattern" : "fixed_shot_pattern"
		"flame ammopersec decreased" : "flame ammopersec decreased"
		"flame ammopersec increased" : "flame ammopersec increased"
		"flame life bonus" : "flame life bonus"
		"flame life penalty" : "flame life penalty"
		"flame size bonus" : "flame size bonus"
		"flame size penalty" : "flame size penalty"
		"flame_drag" : "flame_drag"
		"flame_gravity" : "flame_gravity"
		"flame_ignore_player_velocity" : "flame_ignore_player_velocity"
		"flame_lifetime" : "flame_lifetime"
		"flame_random_life_time_offset" : "flame_random_life_time_offset"
		"flame_reflect_on_collision" : "flame_reflect_on_collision"
		"flame_reflection_add_life_time" : "flame_reflection_add_life_time"
		"flame_speed" : "flame_speed"
		"flame_spread_degree" : "flame_spread_degree"
		"flame_up_speed" : "flame_up_speed"
		"force center wrap" : "force center wrap"
		"force level display" : "force level display"
		"force weapon switch" : "force weapon switch"
		"freeze backstab victim" : "freeze backstab victim"
		"full charge turn control" : "full charge turn control"
		"fuse bonus" : "fuse bonus"
		"generate rage on damage" : "generate rage on damage"
		"generate rage on heal" : "generate rage on heal"
		"gesture speed increase" : "gesture speed increase"
		"gifter account id" : "gifter account id"
		"grenade damage reduction on world contact" : "grenade damage reduction on world contact"
		"grenade detonation damage penalty" : "grenade detonation damage penalty"
		"grenade launcher mortar mode" : "grenade launcher mortar mode"
		"grenade no bounce" : "grenade no bounce"
		"grenade no spin" : "grenade no spin"
		"grenade not explode on impact" : "grenade not explode on impact"
		"grenades1_resupply_denied" : "grenades1_resupply_denied"
		"grenades2_resupply_denied" : "grenades2_resupply_denied"
		"grenades3_resupply_denied" : "grenades3_resupply_denied"
		"gunslinger punch combo" : "gunslinger punch combo"
		"halloween fire rate bonus" : "halloween fire rate bonus"
		"halloween increased jump height" : "halloween increased jump height"
		"halloween item" : "halloween item"
		"halloween reload time decreased" : "halloween reload time decreased"
		"Halloween Spellbook Page: Audere" : "Halloween Spellbook Page: Audere"
		"Halloween Spellbook Page: Congeriae" : "Halloween Spellbook Page: Congeriae"
		"Halloween Spellbook Page: Gratanter" : "Halloween Spellbook Page: Gratanter"
		"Halloween Spellbook Page: Tumidum" : "Halloween Spellbook Page: Tumidum"
		"Halloween Spellbook Page: Veteris" : "Halloween Spellbook Page: Veteris"
		"halloweenvision filter DISPLAY ONLY" : "halloweenvision filter DISPLAY ONLY"
		"halloweenvision opt in DISPLAY ONLY" : "halloweenvision opt in DISPLAY ONLY"
		"hand scale" : "hand scale"
		"has pipboy build interface" : "has pipboy build interface"
		"has team color paintkit" : "has team color paintkit"
		"hat only unusual effect" : "hat only unusual effect"
		"head scale" : "head scale"
		"headshot damage increase" : "headshot damage increase"
		"heal on hit for rapidfire" : "heal on hit for rapidfire"
		"heal on hit for slowfire" : "heal on hit for slowfire"
		"heal on kill" : "heal on kill"
		"heal rate bonus" : "heal rate bonus"
		"heal rate penalty" : "heal rate penalty"
		"healing mastery" : "healing mastery"
		"healing received bonus" : "healing received bonus"
		"healing received penalty" : "healing received penalty"
		"health drain" : "health drain"
		"health from healers increased" : "health from healers increased"
		"health from healers reduced" : "health from healers reduced"
		"health from packs decreased" : "health from packs decreased"
		"health from packs increased" : "health from packs increased"
		"health on radius damage" : "health on radius damage"
		"health regen" : "health regen"
		"hidden maxhealth non buffed" : "hidden maxhealth non buffed"
		"hidden primary max ammo bonus" : "hidden primary max ammo bonus"
		"hidden secondary max ammo penalty" : "hidden secondary max ammo penalty"
		"hide crate series number" : "hide crate series number"
		"hide enemy health" : "hide enemy health"
		"hide_strange_prefix" : "hide_strange_prefix"
		"hit self on miss" : "hit self on miss"
		"holster_anim_time" : "holster_anim_time"
		"honorbound" : "honorbound"
		"hype decays over time" : "hype decays over time"
		"hype on damage" : "hype on damage"
		"hype resets on jump" : "hype resets on jump"
		"increase buff duration" : "increase buff duration"
		"increase buff duration HIDDEN" : "increase buff duration HIDDEN"
		"increase player capture value" : "increase player capture value"
		"increased air control" : "increased air control"
		"increased jump height" : "increased jump height"
		"increased jump height from weapon" : "increased jump height from weapon"
		"inspect_viewmodel_offset" : "inspect_viewmodel_offset"
		"is australium item" : "is australium item"
		"is commodity" : "is commodity"
		"is giger counter" : "is giger counter"
		"is marketable" : "is marketable"
		"is throwable chargeable" : "is throwable chargeable"
		"is throwable primable" : "is throwable primable"
		"is_a_sword" : "is_a_sword"
		"is_festivized" : "is_festivized"
		"is_operation_pass" : "is_operation_pass"
		"is_passive_weapon" : "is_passive_weapon"
		"item drop wave" : "item drop wave"
		"item in slot 1" : "item in slot 1"
		"item in slot 2" : "item in slot 2"
		"item in slot 3" : "item in slot 3"
		"item in slot 4" : "item in slot 4"
		"item in slot 5" : "item in slot 5"
		"item in slot 6" : "item in slot 6"
		"item in slot 7" : "item in slot 7"
		"item in slot 8" : "item in slot 8"
		"item name text override" : "item name text override"
		"item slot criteria 1" : "item slot criteria 1"
		"item slot criteria 2" : "item slot criteria 2"
		"item slot criteria 3" : "item slot criteria 3"
		"item slot criteria 4" : "item slot criteria 4"
		"item slot criteria 5" : "item slot criteria 5"
		"item slot criteria 6" : "item slot criteria 6"
		"item slot criteria 7" : "item slot criteria 7"
		"item slot criteria 8" : "item slot criteria 8"
		"item style override" : "item style override"
		"item_meter_charge_rate" : "item_meter_charge_rate"
		"item_meter_charge_type" : "item_meter_charge_type"
		"item_meter_charge_type_3_DISPLAY_ONLY" : "item_meter_charge_type_3_DISPLAY_ONLY"
		"item_meter_damage_for_full_charge" : "item_meter_damage_for_full_charge"
		"item_meter_resupply_denied" : "item_meter_resupply_denied"
		"item_meter_starts_empty_DISPLAY_ONLY" : "item_meter_starts_empty_DISPLAY_ONLY"
		"items traded in for" : "items traded in for"
		"jarate backstabber" : "jarate backstabber"
		"jarate description" : "jarate description"
		"jarate duration" : "jarate duration"
		"kill eater" : "kill eater"
		"kill eater 2" : "kill eater 2"
		"kill eater 3" : "kill eater 3"
		"kill eater kill type" : "kill eater kill type"
		"kill eater score type" : "kill eater score type"
		"kill eater score type 2" : "kill eater score type 2"
		"kill eater score type 3" : "kill eater score type 3"
		"kill eater user 1" : "kill eater user 1"
		"kill eater user 2" : "kill eater user 2"
		"kill eater user 3" : "kill eater user 3"
		"kill eater user score type 1" : "kill eater user score type 1"
		"kill eater user score type 2" : "kill eater user score type 2"
		"kill eater user score type 3" : "kill eater user score type 3"
		"kill forces attacker to laugh" : "kill forces attacker to laugh"
		"kill refills meter" : "kill refills meter"
		"killstreak effect" : "killstreak effect"
		"killstreak idleeffect" : "killstreak idleeffect"
		"killstreak tier" : "killstreak tier"
		"limited quantity item" : "limited quantity item"
		"loot list name" : "loot list name"
		"loot rarity" : "loot rarity"
		"lose demo charge on damage when charging" : "lose demo charge on damage when charging"
		"lose hype on take damage" : "lose hype on take damage"
		"lose revenge crits on death DISPLAY ONLY" : "lose revenge crits on death DISPLAY ONLY"
		"lunchbox adds maxhealth bonus" : "lunchbox adds maxhealth bonus"
		"lunchbox adds minicrits" : "lunchbox adds minicrits"
		"lunchbox healing decreased" : "lunchbox healing decreased"
		"mad milk syringes" : "mad milk syringes"
		"major increased jump height" : "major increased jump height"
		"major move speed bonus" : "major move speed bonus"
		"makers mark id" : "makers mark id"
		"mark for death" : "mark for death"
		"mark for death on building pickup" : "mark for death on building pickup"
		"max health additive bonus" : "max health additive bonus"
		"max health additive penalty" : "max health additive penalty"
		"max pipebombs decreased" : "max pipebombs decreased"
		"max pipebombs increased" : "max pipebombs increased"
		"max_flame_reflection_count" : "max_flame_reflection_count"
		"maxammo grenades1 increased" : "maxammo grenades1 increased"
		"maxammo metal increased" : "maxammo metal increased"
		"maxammo metal reduced" : "maxammo metal reduced"
		"maxammo primary increased" : "maxammo primary increased"
		"maxammo primary reduced" : "maxammo primary reduced"
		"maxammo secondary increased" : "maxammo secondary increased"
		"maxammo secondary reduced" : "maxammo secondary reduced"
		"medic regen bonus" : "medic regen bonus"
		"medic regen penalty" : "medic regen penalty"
		"medigun blast resist deployed" : "medigun blast resist deployed"
		"medigun blast resist passive" : "medigun blast resist passive"
		"medigun bullet resist deployed" : "medigun bullet resist deployed"
		"medigun bullet resist passive" : "medigun bullet resist passive"
		"medigun charge is crit boost" : "medigun charge is crit boost"
		"medigun charge is megaheal" : "medigun charge is megaheal"
		"medigun charge is resists" : "medigun charge is resists"
		"medigun crit blast percent bar deplete" : "medigun crit blast percent bar deplete"
		"medigun crit bullet percent bar deplete" : "medigun crit bullet percent bar deplete"
		"medigun crit fire percent bar deplete" : "medigun crit fire percent bar deplete"
		"medigun fire resist deployed" : "medigun fire resist deployed"
		"medigun fire resist passive" : "medigun fire resist passive"
		"melee attack rate bonus" : "melee attack rate bonus"
		"melee bounds multiplier" : "melee bounds multiplier"
		"melee range multiplier" : "melee range multiplier"
		"melts in fire" : "melts in fire"
		"merasmus hat level display ONLY" : "merasmus hat level display ONLY"
		"metal regen" : "metal regen"
		"metal_pickup_decreased" : "metal_pickup_decreased"
		"meter_label" : "meter_label"
		"min_viewmodel_offset" : "min_viewmodel_offset"
		"mini rockets" : "mini rockets"
		"minicrit vs burning player" : "minicrit vs burning player"
		"minicrit_boost_charge_rate" : "minicrit_boost_charge_rate"
		"minicrit_boost_when_charged" : "minicrit_boost_when_charged"
		"minicritboost on kill" : "minicritboost on kill"
		"minicrits become crits" : "minicrits become crits"
		"minigun no spin sounds" : "minigun no spin sounds"
		"minigun spinup time decreased" : "minigun spinup time decreased"
		"minigun spinup time increased" : "minigun spinup time increased"
		"mod ammo per shot" : "mod ammo per shot"
		"mod ammo per shot missed DISPLAY ONLY" : "mod ammo per shot missed DISPLAY ONLY"
		"mod bat launches balls" : "mod bat launches balls"
		"mod bat launches ornaments" : "mod bat launches ornaments"
		"mod crit while airborne" : "mod crit while airborne"
		"mod demo buff type" : "mod demo buff type"
		"mod flamethrower back crit" : "mod flamethrower back crit"
		"mod flamethrower push" : "mod flamethrower push"
		"mod flaregun fires pellets with knockback" : "mod flaregun fires pellets with knockback"
		"mod max primary clip override" : "mod max primary clip override"
		"mod medic healed damage bonus" : "mod medic healed damage bonus"
		"mod medic healed deploy time penalty" : "mod medic healed deploy time penalty"
		"mod medic killed marked for death" : "mod medic killed marked for death"
		"mod medic killed minicrit boost" : "mod medic killed minicrit boost"
		"mod medic killed revenge" : "mod medic killed revenge"
		"mod mini-crit airborne" : "mod mini-crit airborne"
		"mod mini-crit airborne deploy" : "mod mini-crit airborne deploy"
		"mod no reload DISPLAY ONLY" : "mod no reload DISPLAY ONLY"
		"mod rage damage boost" : "mod rage damage boost"
		"mod rage on hit bonus" : "mod rage on hit bonus"
		"mod rage on hit penalty" : "mod rage on hit penalty"
		"mod see enemy health" : "mod see enemy health"
		"mod sentry killed revenge" : "mod sentry killed revenge"
		"mod shovel damage boost" : "mod shovel damage boost"
		"mod shovel speed boost" : "mod shovel speed boost"
		"mod soldier buff type" : "mod soldier buff type"
		"mod stun waist high airborne" : "mod stun waist high airborne"
		"mod teleporter cost" : "mod teleporter cost"
		"mod use metal ammo type" : "mod use metal ammo type"
		"mod weapon blocks healing" : "mod weapon blocks healing"
		"mod wrench builds minisentry" : "mod wrench builds minisentry"
		"mod_air_control_blast_jump" : "mod_air_control_blast_jump"
		"mod_cloak_no_regen_from_items" : "mod_cloak_no_regen_from_items"
		"mod_disguise_consumes_cloak" : "mod_disguise_consumes_cloak"
		"mod_mark_attacker_for_death" : "mod_mark_attacker_for_death"
		"mod_maxhealth_drain_rate" : "mod_maxhealth_drain_rate"
		"move speed bonus" : "move speed bonus"
		"move speed bonus resource level" : "move speed bonus resource level"
		"move speed bonus shield required" : "move speed bonus shield required"
		"move speed penalty" : "move speed penalty"
		"mult airblast refire time" : "mult airblast refire time"
		"mult charge turn control" : "mult charge turn control"
		"mult cloak meter consume rate" : "mult cloak meter consume rate"
		"mult cloak meter regen rate" : "mult cloak meter regen rate"
		"mult cloak rate" : "mult cloak rate"
		"mult decloak rate" : "mult decloak rate"
		"mult sniper charge after bodyshot" : "mult sniper charge after bodyshot"
		"mult sniper charge after headshot" : "mult sniper charge after headshot"
		"mult sniper charge after miss" : "mult sniper charge after miss"
		"mult sniper charge penalty DISPLAY ONLY" : "mult sniper charge penalty DISPLAY ONLY"
		"mult_dmgtaken_active" : "mult_dmgtaken_active"
		"mult_end_flame_size" : "mult_end_flame_size"
		"mult_health_fromhealers_penalty_active" : "mult_health_fromhealers_penalty_active"
		"mult_item_meter_charge_rate" : "mult_item_meter_charge_rate"
		"mult_patient_overheal_penalty_active" : "mult_patient_overheal_penalty_active"
		"mult_player_movespeed_active" : "mult_player_movespeed_active"
		"mult_spread_scale_first_shot" : "mult_spread_scale_first_shot"
		"mult_spread_scales_consecutive" : "mult_spread_scales_consecutive"
		"multiple sentries" : "multiple sentries"
		"mvm completed challenges bitmask" : "mvm completed challenges bitmask"
		"never craftable" : "never craftable"
		"no charge impact range" : "no charge impact range"
		"no crit boost" : "no crit boost"
		"no crit vs nonburning" : "no crit vs nonburning"
		"no double jump" : "no double jump"
		"no metal from dispensers while active" : "no metal from dispensers while active"
		"no primary ammo from dispensers while active" : "no primary ammo from dispensers while active"
		"no self blast dmg" : "no self blast dmg"
		"no_attack" : "no_attack"
		"no_duck" : "no_duck"
		"no_jump" : "no_jump"
		"NoCloakWhenCloaked" : "NoCloakWhenCloaked"
		"noise maker" : "noise maker"
		"non economy" : "non economy"
		"obsolete ammo penalty" : "obsolete ammo penalty"
		"overheal bonus" : "overheal bonus"
		"overheal decay bonus" : "overheal decay bonus"
		"overheal decay disabled" : "overheal decay disabled"
		"overheal decay penalty" : "overheal decay penalty"
		"overheal expert" : "overheal expert"
		"overheal fill rate reduced" : "overheal fill rate reduced"
		"overheal penalty" : "overheal penalty"
		"override footstep sound set" : "override footstep sound set"
		"override item level desc string" : "override item level desc string"
		"override projectile type" : "override projectile type"
		"paint decal enum" : "paint decal enum"
		"paintkit_proto_def_index" : "paintkit_proto_def_index"
		"panic_attack" : "panic_attack"
		"panic_attack_negative" : "panic_attack_negative"
		"parachute attribute" : "parachute attribute"
		"particle effect use head origin" : "particle effect use head origin"
		"particle effect vertical offset" : "particle effect vertical offset"
		"patient overheal penalty" : "patient overheal penalty"
		"player skin override" : "player skin override"
		"powerup charges" : "powerup charges"
		"powerup duration" : "powerup duration"
		"powerup max charges" : "powerup max charges"
		"preserve ubercharge" : "preserve ubercharge"
		"projectile entity name" : "projectile entity name"
		"projectile particle name" : "projectile particle name"
		"projectile penetration" : "projectile penetration"
		"projectile penetration heavy" : "projectile penetration heavy"
		"Projectile range decreased" : "Projectile range decreased"
		"Projectile range increased" : "Projectile range increased"
		"Projectile speed decreased" : "Projectile speed decreased"
		"Projectile speed increased" : "Projectile speed increased"
		"Projectile speed increased HIDDEN" : "Projectile speed increased HIDDEN"
		"projectile spread angle penalty" : "projectile spread angle penalty"
		"provide on active" : "provide on active"
		"purchased" : "purchased"
		"pyro year number" : "pyro year number"
		"pyrovision only DISPLAY ONLY" : "pyrovision only DISPLAY ONLY"
		"pyrovision opt in DISPLAY ONLY" : "pyrovision opt in DISPLAY ONLY"
		"quality text override" : "quality text override"
		"quest earned bonus points" : "quest earned bonus points"
		"quest earned standard points" : "quest earned standard points"
		"quest loaner id hi" : "quest loaner id hi"
		"quest loaner id low" : "quest loaner id low"
		"ragdolls become ash" : "ragdolls become ash"
		"ragdolls plasma effect" : "ragdolls plasma effect"
		"rage giving scale" : "rage giving scale"
		"rage on assists" : "rage on assists"
		"rage on kill" : "rage on kill"
		"random drop line item 0" : "random drop line item 0"
		"random drop line item 1" : "random drop line item 1"
		"random drop line item 2" : "random drop line item 2"
		"random drop line item 3" : "random drop line item 3"
		"random drop line item footer desc" : "random drop line item footer desc"
		"random drop line item unusual chance" : "random drop line item unusual chance"
		"random drop line item unusual list" : "random drop line item unusual list"
		"recall" : "recall"
		"recipe component defined item 1" : "recipe component defined item 1"
		"recipe component defined item 10" : "recipe component defined item 10"
		"recipe component defined item 2" : "recipe component defined item 2"
		"recipe component defined item 3" : "recipe component defined item 3"
		"recipe component defined item 4" : "recipe component defined item 4"
		"recipe component defined item 5" : "recipe component defined item 5"
		"recipe component defined item 6" : "recipe component defined item 6"
		"recipe component defined item 7" : "recipe component defined item 7"
		"recipe component defined item 8" : "recipe component defined item 8"
		"recipe component defined item 9" : "recipe component defined item 9"
		"recipe no partial complete" : "recipe no partial complete"
		"redirected_flame_size_mult" : "redirected_flame_size_mult"
		"reduced_healing_from_medics" : "reduced_healing_from_medics"
		"ReducedCloakFromAmmo" : "ReducedCloakFromAmmo"
		"referenced item def UPDATED" : "referenced item def UPDATED"
		"referenced item id high" : "referenced item id high"
		"referenced item id low" : "referenced item id low"
		"refill_ammo" : "refill_ammo"
		"reflected_flame_dmg_reduction" : "reflected_flame_dmg_reduction"
		"Reload time decreased" : "Reload time decreased"
		"reload time decreased while healed" : "reload time decreased while healed"
		"Reload time increased" : "Reload time increased"
		"reload time increased hidden" : "reload time increased hidden"
		"repair health to metal ratio DISPLAY ONLY" : "repair health to metal ratio DISPLAY ONLY"
		"Repair rate decreased" : "Repair rate decreased"
		"Repair rate increased" : "Repair rate increased"
		"restore health on kill" : "restore health on kill"
		"reveal cloaked victim on hit" : "reveal cloaked victim on hit"
		"reveal disguised victim on hit" : "reveal disguised victim on hit"
		"revive" : "revive"
		"revolver use hit locations" : "revolver use hit locations"
		"ring of fire while aiming" : "ring of fire while aiming"
		"rj air bombardment" : "rj air bombardment"
		"robo sapper" : "robo sapper"
		"rocket jump damage reduction" : "rocket jump damage reduction"
		"rocket jump damage reduction HIDDEN" : "rocket jump damage reduction HIDDEN"
		"rocket launch impulse" : "rocket launch impulse"
		"rocket specialist" : "rocket specialist"
		"rocketjump attackrate bonus" : "rocketjump attackrate bonus"
		"sanguisuge" : "sanguisuge"
		"sapper damage bonus" : "sapper damage bonus"
		"sapper damage leaches health" : "sapper damage leaches health"
		"sapper damage penalty" : "sapper damage penalty"
		"sapper damage penalty hidden" : "sapper damage penalty hidden"
		"sapper degenerates buildings" : "sapper degenerates buildings"
		"sapper health bonus" : "sapper health bonus"
		"sapper health penalty" : "sapper health penalty"
		"sapper kills collect crits" : "sapper kills collect crits"
		"sapper voice pak" : "sapper voice pak"
		"sapper voice pak idle wait" : "sapper voice pak idle wait"
		"saxxy award category" : "saxxy award category"
		"scattergun has knockback" : "scattergun has knockback"
		"scattergun knockback mult" : "scattergun knockback mult"
		"scattergun no reload single" : "scattergun no reload single"
		"self dmg push force decreased" : "self dmg push force decreased"
		"self dmg push force increased" : "self dmg push force increased"
		"self mark for death" : "self mark for death"
		"selfdmg on hit for rapidfire" : "selfdmg on hit for rapidfire"
		"selfdmg on hit for slowfire" : "selfdmg on hit for slowfire"
		"selfmade description" : "selfmade description"
		"series number" : "series number"
		"SET BONUS: alien isolation merc bonus neg" : "SET BONUS: alien isolation merc bonus neg"
		"SET BONUS: alien isolation merc bonus pos" : "SET BONUS: alien isolation merc bonus pos"
		"SET BONUS: alien isolation xeno bonus neg" : "SET BONUS: alien isolation xeno bonus neg"
		"SET BONUS: alien isolation xeno bonus pos" : "SET BONUS: alien isolation xeno bonus pos"
		"SET BONUS: calling card on kill" : "SET BONUS: calling card on kill"
		"SET BONUS: chance of hunger decrease" : "SET BONUS: chance of hunger decrease"
		"SET BONUS: cloak blink time penalty" : "SET BONUS: cloak blink time penalty"
		"SET BONUS: custom taunt particle attr" : "SET BONUS: custom taunt particle attr"
		"SET BONUS: dmg from sentry reduced" : "SET BONUS: dmg from sentry reduced"
		"SET BONUS: dmg taken from bullets increased" : "SET BONUS: dmg taken from bullets increased"
		"SET BONUS: dmg taken from crit reduced set bonus" : "SET BONUS: dmg taken from crit reduced set bonus"
		"SET BONUS: dmg taken from fire reduced set bonus" : "SET BONUS: dmg taken from fire reduced set bonus"
		"SET BONUS: health regen set bonus" : "SET BONUS: health regen set bonus"
		"SET BONUS: max health additive bonus" : "SET BONUS: max health additive bonus"
		"SET BONUS: move speed set bonus" : "SET BONUS: move speed set bonus"
		"SET BONUS: mystery solving time decrease" : "SET BONUS: mystery solving time decrease"
		"SET BONUS: no death from headshots" : "SET BONUS: no death from headshots"
		"SET BONUS: quiet unstealth" : "SET BONUS: quiet unstealth"
		"SET BONUS: special dsp" : "SET BONUS: special dsp"
		"set cloak is feign death" : "set cloak is feign death"
		"set cloak is movement based" : "set cloak is movement based"
		"Set DamageType Ignite" : "Set DamageType Ignite"
		"set icicle knife mode" : "set icicle knife mode"
		"set item tint RGB" : "set item tint RGB"
		"set item tint RGB 2" : "set item tint RGB 2"
		"set supply crate series" : "set supply crate series"
		"set throwable type" : "set throwable type"
		"set_item_texture_wear" : "set_item_texture_wear"
		"share consumable with patient" : "share consumable with patient"
		"shot penetrate all players" : "shot penetrate all players"
		"show paint description" : "show paint description"
		"shuffle crate item def max" : "shuffle crate item def max"
		"shuffle crate item def min" : "shuffle crate item def min"
		"silent killer" : "silent killer"
		"single wep deploy time decreased" : "single wep deploy time decreased"
		"single wep deploy time increased" : "single wep deploy time increased"
		"single wep holster time increased" : "single wep holster time increased"
		"slow enemy on hit" : "slow enemy on hit"
		"slow enemy on hit major" : "slow enemy on hit major"
		"sniper aiming movespeed decreased" : "sniper aiming movespeed decreased"
		"sniper charge per sec" : "sniper charge per sec"
		"sniper crit no scope" : "sniper crit no scope"
		"sniper fires tracer" : "sniper fires tracer"
		"sniper fires tracer HIDDEN" : "sniper fires tracer HIDDEN"
		"sniper full charge damage bonus" : "sniper full charge damage bonus"
		"sniper independent zoom DISPLAY ONLY" : "sniper independent zoom DISPLAY ONLY"
		"sniper no charge" : "sniper no charge"
		"sniper no headshot without full charge" : "sniper no headshot without full charge"
		"sniper no headshots" : "sniper no headshots"
		"sniper only fire zoomed" : "sniper only fire zoomed"
		"sniper penetrate players when charged" : "sniper penetrate players when charged"
		"sniper rage DISPLAY ONLY" : "sniper rage DISPLAY ONLY"
		"sniper zoom penalty" : "sniper zoom penalty"
		"soldier model index" : "soldier model index"
		"spawn with physics toy" : "spawn with physics toy"
		"special taunt" : "special taunt"
		"speed boost when active" : "speed boost when active"
		"speed buff ally" : "speed buff ally"
		"speed_boost_on_hit" : "speed_boost_on_hit"
		"speed_boost_on_hit_enemy" : "speed_boost_on_hit_enemy"
		"speed_boost_on_kill" : "speed_boost_on_kill"
		"SPELL: Halloween death ghosts" : "SPELL: Halloween death ghosts"
		"SPELL: Halloween green flames" : "SPELL: Halloween green flames"
		"SPELL: Halloween pumpkin explosions" : "SPELL: Halloween pumpkin explosions"
		"SPELL: Halloween voice modulation" : "SPELL: Halloween voice modulation"
		"SPELL: set Halloween footstep type" : "SPELL: set Halloween footstep type"
		"SPELL: set item tint RGB" : "SPELL: set item tint RGB"
		"spellbook page attr id" : "spellbook page attr id"
		"spread penalty" : "spread penalty"
		"spunup_damage_resistance" : "spunup_damage_resistance"
		"spunup_push_force_immunity" : "spunup_push_force_immunity"
		"squad surplus claimer id DEPRECATED" : "squad surplus claimer id DEPRECATED"
		"SRifle Charge rate decreased" : "SRifle Charge rate decreased"
		"SRifle Charge rate increased" : "SRifle Charge rate increased"
		"start drop date" : "start drop date"
		"stickies detonate stickies" : "stickies detonate stickies"
		"sticky air burst mode" : "sticky air burst mode"
		"sticky arm time bonus" : "sticky arm time bonus"
		"sticky arm time penalty" : "sticky arm time penalty"
		"sticky detonate mode" : "sticky detonate mode"
		"stickybomb charge rate" : "stickybomb charge rate"
		"stickybomb fizzle time" : "stickybomb fizzle time"
		"stickybomb_charge_damage_increase" : "stickybomb_charge_damage_increase"
		"store sort override DEPRECATED" : "store sort override DEPRECATED"
		"strange part new counter ID" : "strange part new counter ID"
		"strange restriction type 1" : "strange restriction type 1"
		"strange restriction type 2" : "strange restriction type 2"
		"strange restriction type 3" : "strange restriction type 3"
		"strange restriction user type 1" : "strange restriction user type 1"
		"strange restriction user type 2" : "strange restriction user type 2"
		"strange restriction user type 3" : "strange restriction user type 3"
		"strange restriction user value 1" : "strange restriction user value 1"
		"strange restriction user value 2" : "strange restriction user value 2"
		"strange restriction user value 3" : "strange restriction user value 3"
		"strange restriction value 1" : "strange restriction value 1"
		"strange restriction value 2" : "strange restriction value 2"
		"strange restriction value 3" : "strange restriction value 3"
		"strange score selector" : "strange score selector"
		"stun enemies wielding same weapon" : "stun enemies wielding same weapon"
		"style changes on strange level" : "style changes on strange level"
		"subtract victim cloak on hit" : "subtract victim cloak on hit"
		"subtract victim medigun charge on hit" : "subtract victim medigun charge on hit"
		"switch from wep deploy time decreased" : "switch from wep deploy time decreased"
		"tag__eotlearlysupport" : "tag__eotlearlysupport"
		"tag__summer2014" : "tag__summer2014"
		"taunt attach particle index" : "taunt attach particle index"
		"taunt attack name" : "taunt attack name"
		"taunt attack time" : "taunt attack time"
		"taunt force move forward" : "taunt force move forward"
		"taunt force weapon slot" : "taunt force weapon slot"
		"taunt is highfive" : "taunt is highfive"
		"taunt is press and hold" : "taunt is press and hold"
		"taunt mimic" : "taunt mimic"
		"taunt move acceleration time" : "taunt move acceleration time"
		"taunt move speed" : "taunt move speed"
		"taunt only unusual effect" : "taunt only unusual effect"
		"taunt success sound" : "taunt success sound"
		"taunt success sound loop" : "taunt success sound loop"
		"taunt success sound loop offset" : "taunt success sound loop offset"
		"taunt success sound offset" : "taunt success sound offset"
		"taunt turn acceleration time" : "taunt turn acceleration time"
		"taunt turn speed" : "taunt turn speed"
		"taunt_attr_player_invis_percent" : "taunt_attr_player_invis_percent"
		"texture_wear_default" : "texture_wear_default"
		"thermal_thruster" : "thermal_thruster"
		"thermal_thruster_air_launch" : "thermal_thruster_air_launch"
		"throwable damage" : "throwable damage"
		"throwable detonation time" : "throwable detonation time"
		"throwable fire speed" : "throwable fire speed"
		"throwable healing" : "throwable healing"
		"throwable particle trail only" : "throwable particle trail only"
		"throwable recharge time" : "throwable recharge time"
		"tickle enemies wielding same weapon" : "tickle enemies wielding same weapon"
		"tmp dmgbuff on hit" : "tmp dmgbuff on hit"
		"tool escrow until date" : "tool escrow until date"
		"tool needs giftwrap" : "tool needs giftwrap"
		"tool target item" : "tool target item"
		"tool_target_item_icon_offset" : "tool_target_item_icon_offset"
		"torso scale" : "torso scale"
		"tradable after date" : "tradable after date"
		"turn to gold" : "turn to gold"
		"uber duration bonus" : "uber duration bonus"
		"ubercharge" : "ubercharge"
		"ubercharge overheal rate penalty" : "ubercharge overheal rate penalty"
		"ubercharge rate bonus" : "ubercharge rate bonus"
		"ubercharge rate bonus for healer" : "ubercharge rate bonus for healer"
		"ubercharge rate penalty" : "ubercharge rate penalty"
		"ubercharge_preserved_on_spawn_max" : "ubercharge_preserved_on_spawn_max"
		"unique craft index" : "unique craft index"
		"unlimited quantity" : "unlimited quantity"
		"unlimited quantity hidden" : "unlimited quantity hidden"
		"unusualifier_attribute_template_name" : "unusualifier_attribute_template_name"
		"upgrade rate decrease" : "upgrade rate decrease"
		"use large smoke explosion" : "use large smoke explosion"
		"use_model_cache_icon" : "use_model_cache_icon"
		"uses ammo while aiming" : "uses ammo while aiming"
		"vision opt in flags" : "vision opt in flags"
		"voice pitch scale" : "voice pitch scale"
		"weapon burn dmg increased" : "weapon burn dmg increased"
		"weapon burn dmg reduced" : "weapon burn dmg reduced"
		"weapon burn time increased" : "weapon burn time increased"
		"weapon burn time reduced" : "weapon burn time reduced"
		"weapon spread bonus" : "weapon spread bonus"
		"weapon_allow_inspect" : "weapon_allow_inspect"
		"weapon_stattrak_module_scale" : "weapon_stattrak_module_scale"
		"weapon_uses_stattrak_module" : "weapon_uses_stattrak_module"
		"wide item level" : "wide item level"
		"Wrench index" : "Wrench index"
		"zombiezombiezombiezombie" : "zombiezombiezombiezombie"
		"zoom speed mod disabled" : "zoom speed mod disabled"
	] // end attribute_name
	add_or_remove(choices) : "Add or Remove?" : 0 : "Whether to add or remove the specified attribute." = [
		0 : "Add"
		1 : "Remove"
	] // end add_or_remove
	duration(float) : "Duration" : "-1" : "The duration of the attribute, if adding. -1 means last until the player exits the trigger."
	value(float) : "Value" : "1.0" : "The value for the chosen attribute, if adding."
] // end trigger_add_or_remove_tf_player_attributes

@SolidClass base(SBaseTrigger, SBaseDiv, STFConditions) color(255 150 50) = trigger_add_tf_player_condition : "A trigger that will add a player condition to players." [
	duration(float) : "Duration" : -1 : "The duration of the condition. -1 means last until the player exits the trigger."
] // end trigger_add_tf_player_condition

@SolidClass base(SBaseTrigger, SBaseDiv) color(255 150 50) = trigger_apply_impulse : "A trigger that adds an impulse to touching entities, but only when given the ApplyImpulse input." [
	impulse_dir(angle) : "Impulse Direction (Pitch Yaw Roll)" : "0 0 0" : "Angles indicating the direction to push touching entities. Does not orient relative to parent angles."
	force(float) : "Impulse Force" : "300" : "The amount of force to apply to the touching entities."

	input ApplyImpulse(void) : "Apply impulse to touching entities"
] // end trigger_apply_impulse

@SolidClass base(SBaseTrigger, SBaseDiv) color(255 150 50) = trigger_bot_tag : "Add or remove tags to bots that pass through this trigger.\n" +
	"BUG: This entity's tag-changing functionality was programmed independent of its trigger functionality. More specifically, bots that do NOT pass this trigger's filters will STILL have their tags changed (but will NOT fire the OnStartTouch output), and the !caller of a StartTouch input will NOT have their tags changed (despite still firing the OnStartTouch output)." [
	tags(string) : "Tags" :  : "Add/Remove these tags. Multiple tags may be separated by spaces."
	add(choices) : "Operation" : 1 : "Whether to add or remove tags from bots." = [
		0 : "Remove"
		1 : "Add"
	] // end add
] // end trigger_bot_tag

// TODO: Test some of these keyvalues
@SolidClass base(SBaseEntityOrigin, SBaseDiv, SEnableDisable) color(255 150 50) = trigger_brush : "Obsolete entity from Half-Life 2 beta. An invisible, solid brush which has unique coding for the Use function compared to other brush entities. Causes strange collision behavior when certain objects collide with it.\n" +
	"NOTE: The game player events (such as game_playerdie) are useable by all entities and not just by this entity, despite common misconception. This entity may still be preferred however, due to being one of few entities capable of directly passing +use events to an output. See developer.valvesoftware.com/wiki/Targetname#Player_Events for more info." [
	InputFilter(choices) : "Input Filter" : 0 : "Used to specify which inputs this entity will accept." = [
		0 : "Allow All Inputs"
		8 : "Ignore Touch/Untouch"
		16 : "Ignore Use"
		32 : "Ignore All"
	] // end InputFilter
	DontMessageParent(choices) : "Don't Message Parent?" : 0 : "Makes the trigger_brush intercept the StartTouch/EndTouch/Use events, only sending its own output without passing the event on to its BaseClass. Doesn't actually seem to do anything." = [
		0 : "No"
		1 : "Yes"
	] // end DontMessageParent

	spawnflags(flags) = [
		2 : "Ignore Player +USE" : 1
	] // end spawnflags

	output OnEndTouch(void) : "Fired when an entity stops touching this trigger. Only entities that passed this trigger's filters will cause this output to fire."
	output OnStartTouch(void) : "Fired when an entity starts touching this trigger. The touching entity must pass this trigger's filters to cause this output to fire."
	output OnUse(void) : "Fired when the entity is used, either via a special function or by a player (if the Ignore Player +USE spawnflag is unticked). The !activator is the player who triggered this entity."
] // end trigger_brush

@SolidClass base(SBaseTrigger, SBaseDiv) color(255 150 50) = trigger_capture_area : "Capture area for a team_control_point to make a capture point. Also used to define the push/block zone around a Payload cart when a func_tracktrain is defined as its parent." [
	area_cap_point(target_destination) : "Control Point" :  : "Name of the control point this area is linked to."
	area_time_to_cap(integer) : "Time to Cap" : 6 : "The amount of time it takes TWO players (or one Scout) to capture this area, in seconds. Scales based on the number of allies within the zone, with more players capturing faster, utilizing harmonic numbers (en.wikipedia.org/wiki/Harmonic_number)."
	// TODO: What's the relation to decay time?
	team_cancap_2(choices) : "Can RED Cap?" : 1 = [
		1 : "Yes"
		0 : "No"
	] // end team_cancap_2
	team_cancap_3(choices) : "Can BLUE Cap?" : 1 = [
		1 : "Yes"
		0 : "No"
	] // end team_cancap_3
	team_startcap_2(integer) : "Number of RED players to start capping" : 1 : ""
	team_numcap_2(integer) : "Number of RED players to cap" : 1 : ""
	team_startcap_3(integer) : "Number of BLUE players to start capping" : 1 : ""
	team_numcap_3(integer) : "Number of BLUE players to cap" : 1 : ""
	team_spawn_2(integer) : "RED Spawn Adjust" : 0 : "Adjust the minimum respawn time for the RED team by this amount (in seconds) when RED captures this point. If the RED team owns this point when BLUE captures it, this adjustment is reversed."
	team_spawn_3(integer) : "BLUE Spawn Adjust" : 0 : "Adjust the minimum respawn time for the BLUE team by this amount (in seconds) when BLUE captures this point. If the BLUE team owns this point when RED captures it, this adjustment is reversed."

	input CaptureCurrentCP(void) : "If this capture area is currently being captured, force a capture by the team currently capturing it."
	input SetTeamCanCap(vector) : "Set whether a specific team is allowed to capture this area. Format is: <team number> <0/1>. i.e. '2 0' would prevent RED from capturing this area, whereas '3 1' would allow BLUE to cap it."
	input SetControlPoint(target_destination) : "Assign this capture area to the specified control point."

	output OnBreakCap(void) : "Sent when either team fails an attempt to capture the area (the capture progress returns to 0)."
	output OnBreakTeam1(void) : "Sent when a RED capture is broken (the capture progress returns to 0)."
	output OnBreakTeam2(void) : "Sent when a BLU capture is broken (the capture progress returns to 0)."
	output OnCapTeam1(void)   : "Sent when RED team captures this area."
	output OnCapTeam2(void)   : "Sent when BLU team captures this area."
	output OnEndCap(void)   : "Sent when either team captures this area."
	output OnStartCap(void) : "Sent when either team starts capturing this area."
	output OnStartTeam1(void) : "Sent when RED team starts capturing this area."
	output OnStartTeam2(void) : "Sent when BLU team starts capturing this area."

	output OnNumCappersChanged(integer) : "Sent when the number of cappers changes, passing the player count as an integer. Scouts and Pain Train wielders are properly counted as two players."
	output OnNumCappersChanged2(integer) : "Sent when the number of cappers changes, passes the player count as an integer. Scouts and Pain Train wielders are properly counted as two players. -1 indicates capture is being blocked."
] // end trigger_capture_area

@SolidClass base(trigger_capture_area, SClassDiv1) color(255 150 50) = trigger_timer_door : "A version of trigger_capture_area that links the move speed of a func_door to the capture time of a control point, such that the amount of time it takes for this control point to be captured is equivalent to the time it takes for the func_door to open. This will not automatically tell the door to open/close as this point is being captured, use outputs to manually do that." [
	area_time_to_cap(integer) : "Time to Cap" : 6 : "The amount of time it WOULD take two players (or one Scout) to capture this point, in seconds, if this were a trigger_capture_area. Note that unlike trigger_capture_area, the capture rate for this entity does NOT increase with multiple players capturing; the capture rate is always that of one player, regardless of how many players are standing in the capture zone." // TODO: What is the exact formula for capture time with one person?

	door_name(target_destination) : "Door Name" :  : "Name of the door entity the trigger is linked to."
] // end trigger_timer_door

@BaseClass = trigger_catapult_keys_1 [
	launchDirection(angle) : "Launch Direction" : "0 0 0" : "Direction to launch the player in."
	launchTarget(target_destination) : "Launch Target" :  : "Entity to try to 'hit' when launching. Overrides launch direction if specified."
	playerSpeed(float) : "Player Speed" : 450 : "Speed at which to launch players (HU/sec)."
	physicsSpeed(float) : "Physics Object Speed" : 450 : "Speed at which to launch physics objects (HU/sec)."
	useExactVelocity(choices) : "Use Exact Velocity?" : 0 : "Try to fling exactly at the speed specified - this prevents the added upward velocity from a launch target." = [ // TODO: What does this mean exactly?
		0 : "No"
		1 : "Yes"
	] // end useExactVelocity
	exactVelocityChoiceType(choices) : "Exact Solution Method" : 0 : "Using exact velocity generates two correct solutions. Use this to force which one you choose." = [ // TODO: What does this mean exactly?
		0 : "Best"
		1 : "Solution One"
		2 : "Solution Two"
	] // end exactVelocityChoiceType
	// Okay, so you wanna hear something funny? The below keyvalue is actually a boolean when we've all been assuming its a vector/angles, based on the name "DirectionSuppressAirControl". But no, it's a boolean, meant to be used to enable/disable air control suppression entirely.
	// The funny part is that whichever brainlet put this in the code forgot to port this check to the LaunchByTarget code, so it only blocks air control suppression if you're launching by direction. And if unspecified, this defaults to false. That's why it appears that "Air Control Suppression Time" only works when launching by target, because nobody ever thought to try setting this value to true because nobody knew what it even was!
	// But wait, it gets funnier! Surely now that we know definitively what these keyvalues do we can finally take full advantage of them, right? WRONG! Because the line that actually applies the air control effect is commented out in both Launch by Direction and Launch by Target code! Why? Because the absolute geniuses at volvo weren't sure how to convert seconds to milliseconds! This is the exact line in the code:
			//pPlayer->SetAirControlSupressionTime( flSupressionTimeInSeconds * 1000.0f ); // fix units, this method expects milliseconds
	// The funniest part is that THE CODE IS WRITTEN TO CONVERT SECONDS TO MILLISECONDS CORRECTLY! So someone actually DID fix it, but nobody took the time to uncomment the line!
	// I swear, valve coders are the greatest comedians of our time...
	//DirectionSuppressAirControl(choices) : "Suppress Air Control?" : 0 : "Whether or not Air Control Suppression should be enabled when launching by direction. Has no effect if a Launch Target is specified; air control suppression is always enabled in that case." = [
	//	0 : "No"
	//	1 : "Yes"
	//] // end DirectionSuppressAirControl
	//AirCtrlSupressionTime(float) : "Air Control Suppression Time" : "0.0" : "If greater than zero, suppress player air control for this amount of time (in seconds). If less than or equal to zero, use the default (quarter second)."
	applyAngularImpulse(choices) : "Apply Angular Impulse" : 1 : "If a random angular impulse should be applied to physics objects being catapulted." = [
		0 : "No"
		1 : "Yes"
	] // end applyAngularImpulse
] // end trigger_catapult_keys_1
@SolidClass base(SBaseTrigger, SBaseDiv, trigger_catapult_keys_1, SClassDiv1) color(255 150 50) line(255 255 255, targetname, launchTarget) = trigger_catapult : "Catapults entities in a given diretion at a given velocity. Entities' velocity is set (not added to!) every half-second." [
	useThresholdCheck(choices) : "Use Velocity Check?" : 0 : "If set to Yes, the player/object will only be catapulted if its velocity (prior to catapulting) is within the limits specified in the keyvalues for lower and upper threshold." = [
		0 : "No"
		1 : "Yes"
	] // end useThresholdCheck
	onlyVelocityCheck(choices) : "Only Check Velocity?" : 0 : "If Yes, don't actually catapult touching objects (even if their velocity passes our check) (but still fire the OnCatapulted output). Can be used to create velocity-checking triggers. Only works when 'Use Threshold Check' is enabled." = [
		0 : "No"
		1 : "Yes"
	] // end onlyVelocityCheck
	entryAngleTolerance(float) : "Entry Angle Tolerance" : "0.0" : "Catapulted entity's velocity must be pointing this much at the target. Specify a value between -1 and 1: 1 means exactly, 0 means within 180 degrees, -1 means any angle is accepted. This is only used if 'Use Threshold Check' is set to Yes."
	// VALVE WHY DO THESE KEYVALUES FUNCTION SO DAMN WEIRDLY WHY DO I HAVE TO DO ALL THIS ADDING AND SUBTRACTING AND MULTIPLYING PERCENTAGES BULLSHIT JUST LET ME ENTER IN A RAW SPEED I SWEAR THIS ENGINE WAS MADE BY FUCKING BRAINLETS
	lowerThreshold(float) : "Lower Threshold (0 - 1)" : "0.15" : "Touching object must be moving faster than this subtracted percentage of launch speed to be catapulted. The minimum speed is calculated as (Launch Speed - (Lower Threshold * Launch Speed)). For example, the default value of '0.15' means the touching entity must be moving no slower than 85% of the launch speed to be catapulted. Only used if Use Threshold Check is set to Yes."
	upperThreshold(float) : "Upper Threshold (0 - 1)" : "0.30" : "Touching object must be moving slower than this added percentage of launch speed to be catapulted. The maximum speed is calculated as (Launch Speed + (Upper Threshold * Launch Speed)). For example, the default value of '0.30' means the touching entity must be moving no faster than 130% of the launch speed to be catapulted. Only used if Use Threshold Check is set to Yes."

	input SetPlayerSpeed(float) : "Set the speed to launch players at."
	input SetPhysicsSpeed(float) : "Set the speed to launch physics objects at."
	input SetLaunchTarget(target_destination) : "Set the entity to try hit when launched."
	input SetExactVelocityChoiceType(integer) : "Set the Exact Solution Method."

	output OnCatapulted(void) : "Fired when an object has been launched, or, if Use Threshold Check and Only Check Velocity are both set to Yes, when an object has passed our threshold check. The !activator is the entity that activated this trigger."
] // end trigger_catapult

@SolidClass base(SBaseTrigger, SBaseDiv) color(255 150 50) = trigger_gravity : "A trigger volume that changes the gravity keyvalue on any entity that touches it. Only QPhysics objects (ie players) can have their gravity changed; to change the gravity of VPhysics objects (ie physics props), use trigger_vphysics_motion.\n" +
	"BUG: Custom gravity values are not properly lag-compensated, so players with high ping will have jittery jumping.\n" +
	"NOTE: Players will not have their normal gravity restored when they leave the volume, or on a round restart; this must be done manually.\n" +
	"TIP: A player's gravity can also be changed via AddOutput." [
	gravity(float) : "Gravity" : "1.0" : "Gravity multiplier. 1 is normal gravity, 2 is double gravity, 0.001 is none. A value of 0 cannot be used! Accepts negative values and decimals."
] // end trigger_gravity

@SolidClass base(SBaseTrigger, SBaseDiv, SDamageTypes) color(255 150 50) = trigger_hurt : "A trigger volume that damages entities that touch it. The damage indicator will point towards the origin of the brush, but damage push force will push entities away from the center of the brush (unless disabled)." +
	"BUG: Fire-related damage types will not ignite the player. Use trigger_ignite instead for this." [
	//master(string) : "Master (Obsolete)" :  : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."
	damage(float) : "Damage" : 10 : "The amount of damage done to entities that touch this trigger per second. The specified damage will be halved and dealt every half-second. Negative values will heal. The damage types DMG_RADIUS_MAX (1024) and DMG_HALF_FALLOFF (262144) do not affect damage dealt, but other types can."
	nodmgforce(choices) : "Zero Damage Force?" : 0 : "Should the damaged entity receive no physics force from this trigger?" = [
		0 : "No"
		1 : "Yes"
	] // end nodmgforce
	damagemodel(choices) : "Damage Model" : 0 : "How damage is dealt. Normal always does the specified amount of damage each second. Doubling starts with the specified amount and doubles it each time it hurts the toucher. Forgiveness means that if the toucher gets out of the trigger, the damage will reset to the specified value. Good for making triggers that are deadly over time without having to cause massive damage on each touch." = [
		0 : "Normal"
		1 : "Doubling w/ Forgiveness"
	] // end damagemodel
	damagecap(float) : "Damage Cap" : 20 : "Maximum damage dealt per second. This field is only used if you select the Doubling w/ Forgiveness damage model."

	input SetDamage(float) : "Set a new amount of damage for this trigger."

	output OnHurt(void) : "Fired whenever this trigger hurts something other than a player."
	output OnHurtPlayer(void) : "Fired whenever this trigger hurts a player."
] // end trigger_hurt

@SolidClass base(SBaseTrigger, SBaseDiv) color(255 150 50) = trigger_ignite : "Ignites touching players and burns them over time." [
	burn_duration(float) : "Burn Duration" : 5 : "Duration of the afterburn effect on the player after leaving the trigger."
	damage_percent_per_second(float) : "Damage (%) per Second" : 10 : "Damage per second while inside the trigger." // TODO: Why is this documented as a percent?
	ignite_particle_name(string) : "Ignite Particle Name" :  : "Name of the particle that plays when player first touch the trigger."
	ignite_sound_name(sound) : "Ignite Sound Name" :  : "Name of the sound script that plays when player first touch the trigger."
] // end trigger_ignite

// TODO: Test
@SolidClass base(SBaseTrigger) color(255 150 50) = trigger_ignite_arrows : "Trigger that ignites arrows on bows held by Snipers who touch the trigger while looking at the origin." [
] // end trigger_ignite_arrows

@SolidClass base(SBaseTrigger, SBaseDiv) color(255 150 50) = trigger_impact : "A trigger volume that can be told to push all physics objects that are inside of it in the direction specified by this trigger's angles." [
	Magnitude(float) : "Magnitude" : 200 : "The strength of the impact. Negative values reverse the direction."
	noise(float) : "Noise" : "0.1" : "The amount of directional noise (0-1). 0 = no noise, 1 = random direction."
	viewkick(float) : "Viewkick" : "0.05" : "The amount to kick player's view if the player is in the trigger. Proportional to magnitude (0-1)."

	input Impact(float) : "Fire the impact, pushing all entities within the volume."
	input SetMagnitude(float) : "Set the magnitude of the impact."

	output ImpactForce(string) : "Fired after an impact. The parameter passed along is the force of the impact that was generated."
] // end trigger_impact

// TODO: How does this behave with multiple players?
// TODO: Doesn't work with non-players?
// TODO: Might ignore filters?
@SolidClass base(SBaseTrigger, SBaseDiv) color(255 150 50) line(255 255 255, targetname, target) = trigger_look : "An entity used to trigger something when the player looks at something. It fires 'OnTrigger' when the player looks at a target entity for the given amount of time, while within the trigger volume. If the player leaves the trigger or looks away from the target entity, the clock resets." [
	target(target_destination) : "Look Target" :  : "The name of the entity to be looked at."
	FieldOfView(float) : "Field of View" : "0.5" : "How close the player has to be looking at the target. 1.0 = straight ahead, 0.0 = +/- 90 degrees, -1.0 = all directions."
	LookTime(float) : "Look Time" : "0.5" : "The time, in seconds, that the player must look at the target before firing the output. Resets if player leaves the trigger, or looks outside the Field of View threshold."
	Timeout(float) : "Timeout Time" : "0.0" : "The time, in seconds, to wait after player enters the trigger before firing the OnTimeout output, 0 = never."

	spawnflags(flags) = [
		256 : "Check Velocity - Check if the player is MOVING towards target (don't check looking)" : 0
		1 : "Clients/Players/Bots" : 1
		//32 : "Only clients in vehicles" : 0
		//512 : "Only clients NOT in vehicles" : 0
		2 : "NPCs" : 0
		16 : "Only player ally NPCs" : 0
		//2048 : "Only NPCs in vehicles (respects player ally flag)" : 0
		4 : "Pushables": 0
		8 : "Physics Objects (not including physics debris)" : 0
		1024 : "Physics Debris" : 0
		64 : "Everything (not including physics debris)" : 0
		4096 : "Disallow TFBots and Puppet Bots" : 0
	] // end spawnflags

	input FieldOfView(float) : "Set the Field of View keyvalue."
	input LookTime(float) : "Set the Look Time keyvalue."
	output OnTimeout(void) : "Fired after the timeout interval expires if the player never looked at the target." // TODO: Does this fire if the player leaves the trigger?
	output OnTrigger(void) : "Fired when a player looks at the Look Target for <Look Time> seconds."
] // end trigger_look

@SolidClass base(SBaseTrigger, SBaseDiv) color(255 150 50) = trigger_multiple : "A trigger volume that repeatedly fires an OnTrigger output as long as an entity that passes its filters is within its volume. It is commonly used as a generic trigger. Notably, most other trigger entities (including some func_ entities) share this trigger's most frequently used features." [
	wait(integer) : "Delay Before Retrigger" : 1 : "Amount of time, in seconds, after the trigger has fired its OnTrigger output before it can fire that output again. If set to -1, it will never trigger again (in which case you should just use a trigger_once)."

	output OnTrigger(void) : "Fired every <Delay Before Retrigger> seconds while a valid entity is inside this volume."
] // end trigger_multiple

// Yea, this inherits from trigger_multiple for some reason. Go figure
@SolidClass base(trigger_multiple, SClassDiv1) color(255 150 50) = trigger_player_respawn_override : "Trigger that overrides the default map-wide respawn wave time of any player that dies within its volume with its own fixed respawn time. Players can also be made to respawn at a specified respawn entity rather than the default ones. For some reason, this entity also inherits trigger_multiple's OnTrigger behavior (which has nothing to do with this entity's respawn functionality)." [
	RespawnTime(float) : "Respawn Time" : -1 : "The number of seconds before players that die inside the volume of this trigger can respawn. Setting -1 will allow the game to decide."
	RespawnName(target_destination) : "Respawn Entity Name" :  : "Optionally the name of info_player_teamspawn entities for players to respawn at when they die inside this volume, instead of the usual ones."

	input SetRespawnTime(float) : "Set the number of seconds before players that die inside the volume of this trigger can respawn."
	input SetRespawnName(target_destination) : "Set the name of the player team spawn(s) to use when a player dies in this volume."
] // end trigger_player_respawn_override

@SolidClass base(SBaseTrigger) color(255 150 50) = trigger_once : "A trigger volume that removes itself after it is triggered once." [
	output OnTrigger(void) : "Fired when the trigger is activated."
] // end trigger_once

// TODO: Test
@SolidClass base(SBaseTrigger, SBaseDiv) color(255 150 50) = trigger_particle : "A trigger volume that spawns and attaches particles to the activating object. May not work correctly as the entity is half-finished." [
	particle_name(string) : "Particle Name" :  : "The name of the particle to spawn/use. Not the name of a .pcf file!"
	attachment_name(string) : "Attachment Name" :  : "The name of the $attachment to attach to on the model. May possibly not be necessary if using an origin Attachment Type."
	attachment_type(choices) : "Attachment Type" : "follow_attachment" : "The type of attaching to use." = [
		"start_at_origin" : "Start at origin of model"
		"start_at_attachment" : "Start at specified attachment of model"
		"follow_origin" : "Follow the origin of model"
		"follow_attachment" : "Follow the specified attachment of model"
	] // end attachment_type
] // end trigger_particle

// not part of Trigger class for some reason
@SolidClass base(SBaseEntityOrigin) color(255 150 50) = trigger_passtime_ball : "Sends outputs when the JACK/ball or a player with the JACK/ball enters and exits this trigger." [
	output OnBallEnter(void) : "Fired when the JACK/ball enters this trigger."
	output OnBallExit(void) : "Fired when the JACK/ball exits this trigger."
] // end trigger_passtime_ball

@SolidClass base(SBaseTrigger) color(255 150 50) = trigger_playermovement : "An entity that can be used to control player's movement options, for instance by automatically ducking or forcing walking speed.\n" +
	"The 'Disable Auto Uncrouch/Step-up' spawnflag will, if the player crouches, prevent them from uncrouching when they release the key. The player will only be able to uncrouch after they leave the trigger. The spawnflag also makes the player unable to 'step up' small ledges such as stairs." [
	spawnflags(flags) = [
		128 : "Disable Auto Uncrouch/Step-Up - See description" : 0
		2048 : "Auto-duck while in trigger" : 0
		//4096 : "Auto-walk while in trigger" : 0 // Does nothing
		1 : "Clients/Players/Bots" : 1
		//32 : "Only clients in vehicles" : 0
		//512 : "Only clients NOT in vehicles" : 0
		2 : "NPCs" : 0
		16 : "Only player ally NPCs" : 0
		//2048 : "Only NPCs in vehicles (respects player ally flag)" : 0
		4 : "Pushables": 0
		8 : "Physics Objects (not including physics debris)" : 0
		1024 : "Physics Debris" : 0
		64 : "Everything (not including physics debris)" : 0
		4096 : "Disallow TFBots and Puppet Bots" : 0
	] // end spawnflags
] // end trigger_playermovement

@SolidClass base(SBaseTrigger, SBaseDiv) color(255 150 50) sphere(radius) = trigger_proximity : "Measures the distance of the player within the trigger volume from a given point (and within a given radius). The NearestPlayerDistance output will be 0 when the player is at the center point, and 1 when the player is at the radius." [
	measuretarget(target_destination) : "Point to Measure From" :  : "The name of a target entity who's origin is the point to measure the player's distance from."
	radius(string) : "Radius to Measure Within" : 256 : "The radius to which the distance should be mapped. If the player is outside the radius he will be ignored."

	output NearestEntityDistance(float) : "Fired continuously when entities are touching the trigger volume. The output parameter is the distance from the Point to Measure From to the nearest entity that passed this trigger's filters. The distance is mapped to the radius distance, so it will be 0 when the entity is on the point, and 1 when the entity is at the edge of the radius."
] // end trigger_proximity

@SolidClass base(SBaseTrigger, SBaseDiv) color(255 150 50) = trigger_push : "A trigger volume that pushes entities that touch it, except those with a parent." [
	pushdir(angle) : "Push Direction (Pitch Yaw Roll)" : "0 0 0" : "Angles indicating the direction to push touched entities."
	speed(integer) : "Speed of Push" : 40 : "The speed at which to push entities away, in units / second."
	alternateticksfix(float) : "Scale Force for Alternate Ticks" : "0" : "If nonzero, scale the force by this amount when running with alternate ticks. This fixes problems with an overly large force due to the longer frametime on when running with sv_alternateticks 1."

	spawnflags(flags) = [
		128 : "Once Only - Remove self after applying push force" : 0
		1 : "Clients/Players/Bots" : 1
		//32 : "Only clients in vehicles" : 0
		//512 : "Only clients NOT in vehicles" : 0
		2 : "NPCs" : 0
		16 : "Only player ally NPCs" : 0
		//2048 : "Only NPCs in vehicles (respects player ally flag)" : 0
		4 : "Pushables": 0
		8 : "Physics Objects (not including physics debris)" : 0
		1024 : "Physics Debris" : 0
		64 : "Everything (not including physics debris)" : 0
		4096 : "Disallow TFBots and Puppet Bots" : 0
	] // end spawnflags
] // end trigger_push

@SolidClass base(SBaseTrigger, SBaseDiv, STFTeam) color(255 150 50) = trigger_rd_vault_trigger : "The trigger zone responsible for adding powercores to a stolen core, in the Robot Destruction gamemode." [
	output OnPointsEndStealing(void) : "Send when points stop being stolen."
	output OnPointsStartStealing(void) : "Sent when points start being stolen."
	output OnPointsStolen(void) : "Sent during every point stealing 'pulse'."
] // end trigger_rd_vault_trigger

@SolidClass base(SBaseTrigger) color(255 150 50) = trigger_remove : "A trigger volume that removes any entities that touch it completely from the game. Be careful, removing some entities can cause instability or crashing, especially with a player." [
	output OnRemove(void) : "Fired whenever an entity is removed."
] // end trigger_remove

@SolidClass base(SBaseTrigger, SBaseDiv, STFConditions) color(255 150 50) = trigger_remove_tf_player_condition : "A trigger that will remove a condition (or all if set to INVALID) from a player." [
] // end trigger_remove_tf_player_condition

@SolidClass base(SPreservedEntity, SBaseTrigger, SBaseDiv) color(255 150 50) = trigger_soundscape : "Automatically triggers an env_soundscape_triggerable whenever a player is inside its volume and not triggering any other soundscape entities." [
	soundscape(target_destination) : "Soundscape Entity" :  : "The env_soundscape_triggerable that this brush triggers. (Not to be confused with the actual soundscape that the env_soundscape_triggerable then calls.)"
] // end trigger_soundscape

@SolidClass base(SBaseTrigger, SBaseDiv) color(255 150 50) = trigger_stun : "A trigger volume that stuns entities that touch it. A small boot icon on the HUD indicates to the player that their move speed is reduced (but does not indicate by how much; the icon is displayed even if the player has no move speed reduction). Re-applies the stun effect every half-second until the player leaves the trigger." [
	stun_type(choices) : "Stun Type" : 0 : "The type of stun that is applied. If Spook or Sandman Stun is selected, players will be unable to fire their weapons for the duration of the stun and will be put into third-person perspective."  = [
		0 : "Movement Only (No sound)"
		2 : "Spook (Scared scream, humiliation pose)"
		1 : "Sandman Stun (BONK sound, cannot move)"
	] // end stun_type
	trigger_delay(float) : "Trigger Delay" : "0.25" : "Delay after an entity touches before the first stun is applied, in seconds. If the player leaves the trigger before the Trigger Delay passes, they will be stunned immediately once."
	stun_duration(float) : "Stun Duration" : "1.0" : "Length of the stun effect in seconds. As the stun is applied once every half-second, this should be at least 0.5 seconds so the stun effect doesn't constantly flicker."
	move_speed_reduction(float) : "Move Speed Reduction" : "0.6" : "Amount to reduce the player's move speed while stunned, as a percentage between 0 and 1. 0 is no move speed reduction, 1 is 100% immobile. (Out-of-range values are clamped.) If Sandman Weapon Stun is the selected Stun Type, this setting is ignored and stunned players' movement will always be reduced to completely immobile. Note that totally immobile players will be unable to leave the trigger on their own."
	stun_effects(choices) : "Enable Stun Effects?" : 0 : "Only works if Stun Type is set to Spook or Sandman Stun. If set to Yes, then blue ghost particles and a 'YIKES' bubble will appear over stunned players' heads." = [
		0 : "No"
		1 : "Yes"
	] // end stun_effects

	output OnStunPlayer(void) : "Fired whenever this trigger stuns a player, every time the stun is applied. Fires every half-second while a player is in the trigger."
] // end trigger_stun

@SolidClass base(SBaseTrigger, SBaseDiv) color(255 150 50) = trigger_teleport : "A trigger volume that teleports entities that touch it. Entities are teleported to the Remote Destination, and have their angles set to that of the Remote Destination's. If a Local Destination Landmark is specified, teleported entities are offset from the target by their initial offset from the landmark, and their angles are left alone." [
	target(target_destination) : "Remote Destination" :  : "The entity specifying the point to which entities should be teleported. Does not have to be an info_teleport_destination."
	landmark(target_destination) : "Local Destination Landmark" :  : "If specified, then teleported entities are offset from the target by their initial offset from the landmark."

	spawnflags(flags) = [
		32 : "Preserve angles even when a local landmark is not specified" : 0
		1 : "Clients/Players/Bots" : 1
		//32 : "Only clients in vehicles" : 0
		//512 : "Only clients NOT in vehicles" : 0
		2 : "NPCs" : 0
		16 : "Only player ally NPCs" : 0
		//2048 : "Only NPCs in vehicles (respects player ally flag)" : 0
		4 : "Pushables": 0
		8 : "Physics Objects (not including physics debris)" : 0
		1024 : "Physics Debris" : 0
		64 : "Everything (not including physics debris)" : 0
		4096 : "Disallow TFBots and Puppet Bots" : 0
	] // end spawnflags
] // end trigger_teleport

@SolidClass base(SBaseTrigger, SBaseDiv) color(255 150 50) = trigger_teleport_relative : "A trigger volume that teleports entities that touch it to a position relative to the center of the brush (NOT relative to the origin, and NOT relative to the touching entity!)." [
	teleportoffset(vector) : "Offset (X Y Z)" : "0 0 0" : "The offset to teleport the entity from the trigger's center (not origin!) when the trigger is touched."
] // end trigger_teleport_relative

@BaseClass = trigger_vphysics_motion_keys_1 [
	SetGravityScale(float) : "Gravity Scale" : "1.0" : "Scale gravity of objects in the field."
	SetAdditionalAirDensity(float) : "Air Density" : "0.0" : "Additional air density for drag."
	SetVelocityScale(float) : "Velocity Scale/Drag" : "1.0" : ""
	SetVelocityLimit(float) : "Max Velocity" : "0.0" : "Maximum allowed velocity in this field (0 disables)."
	SetVelocityLimitDelta(float) : "Max Velocity Reduction" : "0.0" : "The maximum amount to reduce velocity per second when it exceeds the velocity limit (0 disables)."
	SetAngVelocityScale(float) : "Angular Velocity Scale/Drag" : "1.0" : ""
	SetAngVelocityLimit(float) : "Max Angular Velocity" : "0.0" : "Maximum angular velocity in field (degrees/seconds, 0 disables)."
	SetLinearForce(float) : "Linear Force" : "0.0" : "(0 disables)"
	SetLinearForceAngles(angle) : "Force Direction (Pitch Yaw Roll)" : "0 0 0" : "Direction of linear force."
] // end trigger_vphysics_motion_keys_1
@SolidClass base(SBaseTriggerPhysics, SBaseDiv, trigger_vphysics_motion_keys_1, SClassDiv1) color(255 150 50) = trigger_vphysics_motion : "A volumetric trigger that affects the motion of physical objects that touch it. Optionally, it can also create a particle trail that attaches to objects within its volume. Particle trails emit particles in the shape of its parent model or brush. Does not affect players." [
	ParticleTrailMaterial(material) : "Particle Trail Material" :  : "Optional: Name of a material to use for the particle trail."
	ParticleTrailLifetime(float) : "Particle Trail Lifetime" : 4 : "Lifetime of the particles to emit."
	ParticleTrailStartSize(float) : "Particle Trail Starting Sprite Size" : 2 : "Starting size of the sprite to emit."
	ParticleTrailEndSize(float) : "Particle Trail Ending Sprite Size" : 3 : "Ending size of the sprite to emit."

	input SetAdditionalAirDensity(float) : "Set the additional air density for drag."
	input SetAngVelocityLimit(float) : "Set the Maximum Angular Velocity in field."
	input SetAngVelocityScale(float) : "Set the Angular Velocity scale/drag."
	input SetGravityScale(float) : "Set the scale gravity of objects in the field."
	input SetLinearForce(float) : "Set the Linear force (0 disables)."
	input SetLinearForceAngles(vector) : "Direction of linear force, in X Y Z."
	input SetVelocityLimit(float) : "Set the maximum velocity in field."
	input SetVelocityLimitDelta(float) : "Set the maximum amount to reduce velocity per second."
	input SetVelocityLimitTime(vector) : "Accepts two arguments: the first is the new velocity limit, the second is the time it takes to ramp to that value."
	input SetVelocityScale(float) : "Set the Velocity scale/drag,"
] // end trigger_vphysics_motion

@SolidClass base(SBaseTriggerPhysics, SBaseDiv) = trigger_wind : "A trigger volume that pushes physics objects that touch it." [
	Speed(integer) : "Speed" : 200 : "The baseline for how hard the wind blows."
	SpeedNoise(integer) : "Speed Noise" : 0 : "Noise added to wind speed +/-."
	DirectionNoise(integer) : "Direction Noise" : 10 : "Noise added to wind direction."
	HoldTime(integer) : "Hold Time"	: 0 : "Baseline for how long to wait before changing wind."
	HoldNoise(integer) : "Hold Noise" : 0 : "Noise added to how long to wait before changing wind."

	spawnflags(flags) = [
		1 : "Clients/Players/Bots" : 1
		//32 : "Only clients in vehicles" : 0
		//512 : "Only clients NOT in vehicles" : 0
		2 : "NPCs" : 0
		16 : "Only player ally NPCs" : 0
		//2048 : "Only NPCs in vehicles (respects player ally flag)" : 0
		4 : "Pushables": 0
		8 : "Physics Objects (not including physics debris)" : 0
		1024 : "Physics Debris" : 0
		64 : "Everything (not including physics debris)" : 0
		// TODO: Are we SURE this does nothing? It seems to certainly do stuff in code...
		// CBaseVPhysicsTrigger::CreateVPhysics() and CBaseEntity::VPhysicsInitStatic() code indicate that this flag is effectively checked if the trigger spawns with a parent. Let's try dynamically assigning it one...
		4096 : "Can Move - Auto-checked if this spawns with a parent" : 0 // VPhysics triggers are supposed to have this, but they don't seem to break if this is unchecked while they move.
	] // end spawnflags

	input SetSpeed(integer) : "Set the baseline for how hard the wind blows."
] // end trigger_wind



//----- POINT ENTITIES -----//



	// AI ENTITIES //

@BaseClass = STargetActor [
	actor(target_name_or_class) : "Actor(s) to Affect" :  : "The targetname or classname of any NPCs that will be affected. Wildcards are supported."
	SearchType(choices) : "Search Type" : 0 : "What the 'Actor(s) to affect' keyvalue targets by." = [
		0 : "Entity Name"
		1 : "Classname"
	] // end SearchType

	input UpdateActors(void) : "Tell the entity to re-check Actor(s) to affect in case any disappeared, or any new NPCs spawned."
] // end STargetActor

@PointClass base(SBaseEntity, SBaseDiv, SActivateDeactivate) color(150 0 200) iconsprite("editor-ficool2/ai_battle_line") = ai_battle_line : "Instructs NPCs to try and stay behind it to a configurable degree during a standoff with other NPCs." [
	actor(target_name_or_class) : "Actor(s) to affect" :  : "The targetname or classname of any NPCs that will be affected. Wildcards are supported."
	Strict(choices) : "Strict?" : 1 : "If true, players will not be able to order their allies to ignore the battle line by commanding them with impulse 50 (bound to C by default)." = [
		0 : "No"
		1 : "Yes"
	] // end Strict

	spawnflags(flags) = [
		1 : "Use parent's orientation" : 0
	] // end spawnflags

	input Activate(void) : "If the entity is not yet active, this input will activate it."
	input Deactivate(void) : "If the entity is not yet inactive, this input will turn it inactive."
] // end ai_battle_line

@PointClass base(SBaseLogical, SBaseDiv) color(150 0 200) sphere(Radius) iconsprite("editor-ficool2/ai_changehintgroup") = ai_changehintgroup : "Changes or adds a specific hint group to an NPC or hint node." [
	SearchType(choices) : "Search Type" : 0 : "How to search for the entities to change." = [
		0 : "Entity Name"
		1 : "Classname"
		2 : "Old Hint Group"
	] // end SearchType
	SearchName(string) : "Name to Search for" :  : "A targetname, classname, or name of a hint group."
	NewHintGroup(string) : "New Hint Group" :  : "New hint group to add to the entities meeting search criteria."
	Radius(float) : "Search Radius" : "0.0" : "Radius to search (0 searches entire map)."
	hintlimiting(choices) : "Hint Limit Navigation?" : 0 : "Limits NPC to using specified hint group for navigation requests, does not limit local navigation." = [
		0 : "No"
		1 : "Yes"
	] // end hintlimiting

	input Activate(void) : "Change the Hint Group."
] // end ai_changehintgroup

@PointClass base(SBaseLogical, SBaseDiv) color(150 0 200) iconsprite("editor-ficool2/ai_changetarget") = ai_changetarget : "Changes the target keyvalue of NPCs, but it can change the target of any entity if applicable. This task can also be done using AddOutput 'target'." [
	target(target_destination) : "Entity to Change" :  : "Entity(s) that should have their target changed."
	m_iszNewTarget(target_destination) : "New Target" :  : "New targetname for the targeted entity(s) to target."

	input Activate(void) : "Trigger the target change."
] // end ai_changetarget

@PointClass base(SBaseLogical, SBaseDiv, STargetActor, SActivateDeactivate) color(150 0 200) iconsprite("editor-ficool2/ai_goal_assault") = ai_goal_assault : "This entity specifies which NPCs are to carry out an assault, and triggers it when any conditions given are met. One goal can handle multiple rally points. Must be active to be able to be triggered." [
	rallypoint(target_destination) : "Rally Point Set" :  : "The name of the assault_rallypoint(s) at which this assault will begin. This field can also support wildcards, so that you can enter the root name of all rally points for this assault followed by an asterisk '*', to match all with the same root. Each NPC needs its own rally point."
	RallySelectMethod(choices) : "Rally Point Selection Method" : 0 : "How NPCs will decide which rallypoint to move to." = [
		0 : " Choose by priority. If there are multiple tied for priority, go to the closest one"
		1 : "Choose randomly"
	] // end RallySelectMethod
	AssaultCue(choices) : "Assault Cue" : 1 : "Chooses when the goal is going to be set after this entity has been activated. " = [
		1 : "Entity System Input (BeginAssault)"
		2 : "Gunfire"
		3 : "Don't wait for a cue (Attack immediately after rallying finishes)"
	] // end AssaultCue

	input BeginAssault(void) : "If the entity is active and this entity's Assault Cue keyvalue is set to Entity System Input, begin the assault."
	input UpdateActors(void) : "Tell the goal entity to re-check Actor(s) to affect in case any disappeared, or any new NPCs spawned."
] // end ai_goal_assault

@PointClass base(SBaseLogical, SBaseDiv, STargetActor, SActivateDeactivate) color(150 0 200) iconsprite("editor-ficool2/ai_goal_follow") = ai_goal_follow : "Makes the target NPCs follow another entity or the player at a configurable distance. NPCs do not intelligently follow their target. They will instead walk or run depending on distance directly towards it." [
	goal(string) : "Target Entity" :  : "The name of the entity that the NPCs should follow. If this value is blank, NPCs will follow the player, if they are friendly towards them."
	Formation(choices) : "Formation" : 0 : "" = [
	    0: "Close circle"
        1: "Medium Circle"
        2: "Wide circle"
        3: "Sidekick"
        4: "Vortigaunt"
	] // end Formation
] // end ai_goal_follow

@PointClass base(SBaseLogical, SBaseDiv, STargetActor, SActivateDeactivate) color(150 0 200) iconsprite("editor-ficool2/ai_goal_lead") sphere(LeadDistance) sphere(RetrieveDistance) = ai_goal_lead : "When activated by a trigger, makes an NPC attempt to lead the player to a target. Optionally, a point can be set for the NPC to wait for the player before beginning to lead the player." [
	goal(string) : "Target Entity" :  : "The name of the entity that the NPC will lead the player to (i.e. an info_target)."
	LeadDistance(float) : "Lead Distance" : 128 : "The player is considered to be too far behind if they're beyond this distance. Past this distance, the leader will nag the player to hurry up."
	Run(choices) : "Run instead of Walk?" : "0" = [
		0 : "No"
		1 : "Yes"
	] // end Run
	WaitPointName(target_destination) : "Wait Point" :  : "If the NPC loses line-of-sight to the player, it will return to this entity (i.e. an info_target)."
	WaitDistance(float) : "Wait Distance" : 128 : "The player must be within this distance of the NPC before the NPC initially begins leading them."
	Retrieve(choices) : "Retrieve player?" : 1 = [
		0 : "No, just idle and wait"
		1 : "Yes, move to retrieve"
	] // end Retrieve
	RetrieveDistance(float) : "Retrieve Distance" : "192" : "The distance from the player that the NPC should return to when retrieving a lagging player. Must be between ('Lead Distance' + 24) and ('Lead Distance' * 4) to avoid the leader ping-ponging."
	SuccessDistance(float) : "Success Distance" : "0" : "The distance from the player (to the NPC) that the player must be within for the Lead to succeed, once the NPC has reached the goal. If set to 0, it will use the lead distance instead."

	ComingBackWaitForSpeak(choices) : "Before Coming Back, Wait for speech?" : 1 = [
		0 : "No, come back while speaking"
		1 : "Yes, wait for speech to finish"
	] // end ComingBackWaitForSpeak
	RetrieveWaitForSpeak(choices) : "On Retrieve, Wait for speech?" : 1 = [
		0 : "No, start leading while speaking"
		1 : "Yes, wait for speech to finish"
	] // end RetrieveWaitForSpeak
	DontSpeakStart(choices) : "Speak start greeting?" : 0 = [
		0 : "Yes, speak the start greeting"
		1 : "No, don't speak the greeting"
	] // end DontSpeakStart
	LeadDuringCombat(choices) : "Lead during combat?" : 0 = [
		0 : "No. Stop to fight, resume leading when safe"
		1 : "Yes, lead while fighting"
	] // end LeadDuringCombat
	GagLeader(choices) : "Gag Leader?" : 0 = [
		0 : "No. Speak lead concepts normally, respecting other lead speech settings"
		1 : "Yes, don't speak any lead concepts at all, overriding all other lead speech settings"
	] // end GagLeader

	AttractPlayerConceptModifier(string)	: "Attract player concept modifier" :  : "Appended to the keyvalues passed into the response rules when the 'TLK_LEAD_ATTRACTPLAYER' concept is spoken."
	WaitOverConceptModifier(string)		: "Player wait over concept modifier" :  : "Appended to the keyvalues passed into the response rules when the 'TLK_LEAD_WAITOVER' concept is spoken."
	ArrivalConceptModifier(string)		: "Arrival concept modifier" :  : "Appended to the keyvalues passed into the response rules when the 'TLK_LEAD_ARRIVAL' concept is spoken."
	PostArrivalConceptModifier(string)	: "Post-arrival concepts modifier" : : "Appended to the keyvalues passed into the response rules when the 'TLK_LEAD_POSTARRIVAL' concept is spoken."
	SuccessConceptModifier(string)		: "Success concept modifier" :  : "Appended to the keyvalues passed into the response rules when the 'TLK_LEAD_SUCCESS' concept is spoken."
	FailureConceptModifier(string)		: "Failure concept modifier" :  : "Appended to the keyvalues passed into the response rules when the 'lead_fail' concept is spoken."
	ComingBackConceptModifier(string)	: "Coming Back concept modifier" :  : "Appended to the keyvalues passed into the response rules when the 'TLK_LEAD_RETRIEVE' concept is spoken. Spoken as the NPC starts returning to the player to retrieve him."
	RetrieveConceptModifier(string)		: "Retrieve concept modifier" :  : "Appended to the keyvalues passed into the response rules when the 'TLK_LEAD_COMINGBACK' concept is spoken. Spoken when NPC has finally reached the player to retrieve him."

	spawnflags(flags) = [
		1 : "No defined success" : 0
		2 : "No defined failure" : 0
		4 : "Use goal facing" : 1
	] // end spawnflags

	input SetSuccess(void) : "Notify success of leading. Not required, use only if the standard code for detecting success does not meet your needs or fails."

	output OnArrival(void) : "Fires when NPC reaches the lead point. (Player may still be behind)"
	output OnArrivalDone(void) : "Fires when NPC has played out any arrival speech."
	output OnDone( void ) : "Fires when NPC completes behavior (any post-success or fail acting is complete)."
	output OnFailure( void ) : "Fires when NPC fails to achieves the goal."
	output OnSuccess( void ) : "Fires when NPC achieves the goal."
] // end ai_goal_lead

@PointClass base(ai_goal_lead) color(150 0 200) iconsprite("editor-ficool2/ai_goal_lead_weapon") sphere(LeadDistance) sphere(RetrieveDistance) = ai_goal_lead_weapon : "Alternative of the ai_goal_lead entity that requires the player to have the specified weapon before the actor(s) will lead the player to their target." [
	WeaponName(string) : "Weapon Name" :  : "The classname of the weapon required."
	MissingWeaponConceptModifier(string) : "Missing weapon concept modifier" :  : ""
] // end ai_goal_lead_weapon

@PointClass base(SBaseLogical, SBaseDiv, STargetActor, SActivateDeactivate) color(150 0 200) iconsprite("editor-ficool2/ai_goal_standoff") = ai_goal_standoff : "Specifies what NPCs are a part of the standoff and what special rules they should follow - they will attack more tactically, take cover frequently, and possibly wait for the player to lead forward." [
	HintGroupChangeReaction(choices) : "Reaction to tactical change" : 1 : "Defines how biased NPCs should be to finding cover when the status of the standoff changes. The ways the status can change include the battle line/player moving, NPCs dying, hint group changes, and the SetAggressiveness input. " = [
		0 : "Move when ready (default AI)"
		1 : "Move when seek cover"
		2 : "Move immediately"
	] // end HintGroupChangeReaction
	Aggressiveness(choices) : "Aggressiveness" : 2 : "How aggressive will NPCs behave? Generally, higher aggression means more risk-taking and attacking for longer periods of time." = [
		0 : "0 : Very Low"
		1 : "1 : Low"
		2 : "2 : Medium"
		3 : "3 : High"
		4 : "4 : Very High"
		5 : "5 : Custom"
	] // end Aggressiveness
	PlayerBattleline(choices) : "Player battleline?" : 1 : "Player defines a battle line, applies to allies only." = [
		0 : "No"
		1 : "Yes"
	] // end PlayerBattleline
	StayAtCover(choices) : "Stay at cover location?" : 0 : "When have suitable cover, don't change it (disables advancing to battle line)." = [
		0 : "No"
		1 : "Yes"
	] // end StayAtCover
	AbandonIfEnemyHides(choices) : "Abandon if enemies hide?" : 0 : "If no enemy detected recently, stop the standoff." = [
		0 : "No"
		1 : "Yes"
	] // end AbandonIfEnemyHides
	CustomCoverOnReload(choices) : "Custom: Take cover to reload?" : 1 : "When reloading, NPCs will take cover." = [
		0 : "No"
		1 : "Yes"
	] // end CustomCoverOnReload
	CustomMinTimeShots(float) : "Custom: Min time wait to shoot"	  : 2 : "Minimum time between bursts of shots."
	CustomMaxTimeShots(float) : "Custom: Max time wait to shoot"	  : 4 : "Maximum time between bursts of shots."
	CustomMinShots(integer) : "Custom: Min shots in a burst"	  : 1 : "Minimum number of bullets in a burst of shots."
	CustomMaxShots(integer) : "Custom: Max shots in a burst"	  : 4 : "Maximum number of bullets in a burst of shots."
	CustomOddsCover(integer) : "Custom: Odds cover on damage"	  : 25 : "When an NPC is damaged, this is the percent of the time in which they will immediately take cover."

	input SetAggressiveness(integer) : "Changes the value of Aggressiveness."
] // end ai_goal_standoff

@PointClass base(SBaseLogical, SBaseDiv) color(150 0 200) iconsprite("editor-ficool2/ai_relationship") sphere(radius) = ai_relationship : "Sets a relationship type between two parties. These parties can be an NPC, an NPC class, or the player(s)." [
	subject(target_name_or_class) : "NPC(s) to Affect" :  : "The targetname or classname of the NPCs whose disposition will change."
	target(target_name_or_class) : "Target(s)" :  : "The targetname or class name of the NPCs about whom the subject(s) will change their disposition towards."
	disposition(choices) : "Disposition" : 3 : "The way the subject(s) should feel about the target(s)." = [
		1 : "Hate"
		2 : "Fear"
		3 : "Like"
		4 : "Neutral"
	] // end disposition
	radius(float) : "Radius for Subject" : 0 : "Only NPCs within this distance of the entity will have their dispositions changed."
	rank(integer) : "Disposition Priority" : 0 : "How much the Subject(s) should Like/Hate/Fear the Target(s). Higher priority = stronger feeling."
	Reciprocal(choices) : "Reciprocal?" : 0 : "Make the new disposition apply to the targets as well as the subjects."  = [
		0 : "No"
		1 : "Yes"
	] // end Reciprocal

	spawnflags(flags) = [
		1 : "Notify subject of target's location" : 0
		2 : "Notify target of subject's location" : 0
	] // end spawnflags

	input ApplyRelationship(void) : "Apply relationship changes. This will change all Subject entities' relationships to all Target entities. Once this input is fired, this entity is then always active until a Disable input or RevertRelationship input is sent. During the time this entity is on, any entities that spawn who match the Subject or Target names will be affected. Unpredictable results may occur when two ai_relationship entities refer to the same set or subset of target or subject entities."
	input RevertRelationship(void) : "Revert relationship changes. This will return the relationship to what it was at the time the ApplyRelationship input was called (or when this ai_relationship was spawned if StartActive is set)."
	input RevertToDefaultRelationship(void) : "Revert relationship changes to the default relationship, which may have changed since this ai_relationship was applied. This returns control of the entity relationship to the code."
] // end ai_relationship

@PointClass base(SBaseLogical, SBaseDiv, SEnableDisable) color(150 0 200) iconsprite("editor-ficool2/ai_script_conditions") = ai_script_conditions : "Allows defining a list of conditions relating to the player, an NPC and a target (optional), to trigger events when these conditions are fulfilled. Fired only once, automatically, when the condition is first fulfilled, then disables itself. Use 'Enable' inputs to recheck conditions." [
	Actor(target_destination) : "Actor" : : "NPC we should be concerned with."
	MinimumState(choices) : "Minimum State" : 1 : "Minimum state of selected target NPC - if for example alert is set, while idle it will do nothing." = [
		1 : "Idle"
		2 : "Alert"
		3 : "Combat"
	] // end MinimumState
	MaximumState(choices) : "Maximum State" : 3 : "Maximum state of selected target NPC - if for example alert is set, while combat it will do nothing." = [
		1 : "Idle"
		2 : "Alert"
		3 : "Combat"
	] // end MaximumState
	ScriptStatus(choices) : "Actor is running a script?" : 2 = [
		0 : "No"
		1 : "Yes"
		2 : "Don't care"
	] // end ScriptStatus
	RequiredTime(float) : "Required Time"	  : 0 : "Duration of time that all the conditions must be true for the entity to consider them fulfilled."
	MinTimeout(float) : "Minimum time out"  : 0 : "Minimum time before OnConditionsTimeout is fired. 0 = never expire."
	MaxTimeout(float) : "Maximum time out"  : 0 : "Maximum time before OnConditionsTimeout is fired. 0 = ignore (If you don't specify a Maximum timeout, conditions will time out at exactly Minimum Time Out. If you DO specify a Maximum time out, timeout will occur randomly between Minimum and Maximum time out values.)"
	ActorSeePlayer(choices) : "Actor Sees Player?" : 2 : "Select if actor has to have LOS (line of sight) to player." = [
		0 : "No"
		1 : "Yes"
		2 : "Don't care"
	] // end ActorSeePlayer
	PlayerActorProximity(float) : "Player distance"  : 0 : "The distance the player must/must not be to the actor. Negative values for NOT, 0 for ignore."
	PlayerActorFOV(float) : "Player FOV for Actor " : 360 : "Specify angle of view cone in degrees. Negative value = NOT."
	PlayerActorFOVTrueCone(choices ) : "Player FOV to Actor is a true view cone?" : 0 : "Player's view cone is evaluated as a true cone, not pie slice." = [
		0 : "No - Tall pie slice (Ignores the Z position of things being looked at)"
		1 : "Yes - True view cone (See objects by an actual cone)"
	] // end PlayerActorFOVTrueCone
	PlayerActorLOS(choices) : "Player has LOS to Actor?" : 2 : "Checks that the player has clear Line of Sight to the Actor." = [
		0 : "No"
		1 : "Yes"
		2 : "Don't care"
	]
	target(target_destination) : "Target (Optional)" :  : "Optional third entity to include in conditions."
	ActorSeeTarget(choices)  : "Actor Sees Target?" : 2 : "NPC can see the target?" = [
		0 : "No"
		1 : "Yes"
		2 : "Don't care"
	]
	ActorTargetProximity(float) : "Target distance"  : 0 : "The distance the actor must/must not be to the Target. Negative values for NOT, 0 for ignore."
	PlayerTargetProximity(float) : "Player distance from Target"  : 0 : "The distance the player must/must not be to the Target. Negative values for NOT, 0 for ignore."
	PlayerTargetFOV(float) : "Player FOV for Target" : 360 : "Specify angle of view cone in degrees. Negative value = NOT."
	PlayerTargetFOVTrueCone(choices ) : "Player FOV to Target is a true view cone?" : 0 : "Player's view cone is evaluated as a true cone, not pie slice." = [
		0 : "No - Tall pie slice (Ignores the Z position of things being looked at)"
		1 : "Yes - True view cone  (See objects by an actual cone)"
	]
	PlayerTargetLOS(choices) : "Player has LOS to Target?" : 2 : "Checks that the player has clear Line of Sight to the Target." = [
		0 : "No"
		1 : "Yes"
		2 : "Don't care"
	]
	PlayerBlockingActor(choices) : "Player blocking Actor?" : 2 : "Checks that the player is blocking the Actor's path." = [
		0 : "No"
		1 : "Yes"
		2 : "Don't care"
	]
	ActorInPVS(choices)	: "Actor in Player's PVS?" : 2 : "Checks that the actor is in the player's PVS (Potentially Visible Set)." = [
		0 : "No"
		1 : "Yes"
		2 : "Don't care"
	]
	ActorInVehicle(choices)	: "Actor in a vehicle?" : 2 : "Checks the actor's state in a vehicle." = [
		0 : "No"
		1 : "Yes"
		2 : "Don't care"
	]
	PlayerInVehicle(choices)	: "Player in a vehicle?" : 2 : "Checks the player's state in a vehicle." = [
		0 : "No"
		1 : "Yes"
		2 : "Don't care"
	]

	spawnflags(flags) = [
		1 : "Fire outputs with the Actor as Activator" : 0
	] // end spawnflags

	output OnConditionsSatisfied(void) : "Fires when AI conditions satisfied."
	output OnConditionsTimeout(void)   : "Fires when AI conditions timed out."
	output NoValidActor(void) : "Fires if/when there are no matching actors in the map."
] // end ai_script_conditions

@PointClass base(SBaseEntity, SBaseDiv) color(150 0 200) iconsprite("editor-ficool2/ai_sound") sphere(volume) = ai_sound : "This entity makes sounds or smells that can be sensed by NPCs, but not by the player. This can be used to cause reactions in nearby NPCs." [
	volume(integer) : "Hearing Radius" : 128 : "How far away this sound can be heard."
	duration(float) : "Duration" : "0.5" : "How long the sound persists each time it plays."
	soundtype(choices) : "Sound Type" : 0 : "The type of sound or smell will determine the reaction of NPCs that sense it." = [
		0: "None"
		1: "Combat - Will cause most NPCs to become alert"
		2: "World - Will cause most NPCs to become alert"
		4: "Player - Feign player audible"
		8: "Danger - Will cause most NPCs to move away from the position of the sound"
		16: "Bullet Impact"
		32: "Carcass"
		64: "Meat"
		128: "Garbage"
		256: "Thumper - causes Antlions to run away briefly"
		512: "Bugbait - get nearby Antlions' attention"
		1024: "Physics Danger - Scares off npc_metropolice, npc_combine_s, and npc_antlion"
		2048: "Sniper Danger - Scares npc_snipers into their hole"
		4096: "Move Away - Most NPCs will clear the radius of this sound when heard"
		8192: "Player Vehicle - Makes NPCs hear the player and makes npc_metropolice turn towards the sound"
		16384: "Readiness - Low, causes player companions that can hear this sound to change readiness"
		32768: "Readiness - Medium, causes player companions that can hear this sound to change readiness"
		65536: "Readiness - High, causes player companions that can hear this sound to change readiness"
	]
	soundcontext(choices) : "Additional sound context (optional)" : 0 : "Optional settings specifying such things as who can or cannot hear the sound." = [
		0 : "None"
		1048576 : "Sound is from Sniper"
		2097152 : "Gunfire (use with combat sound type) "
		4194304 : "Mortar (pending explosion) "
		8388608 : "Only Combine hear/smell"
		16777216  : "React to source (faces the ai_sound instead of location proxy) "
		33554432 : "Explosion (use with combat sound type)"
		67108864 : "Combine cannot hear"
		134217728 : "Danger approach (react with danger if you see the ai_sound, just face if otherwise, shouldn't work with location proxy)"
		268435456 : "Only allies (npc_citizen, etc.) hear/smell "
	]
	locationproxy(target_destination) : "Location Proxy" :  : "If you specify an entity here, the sound will be made at that entity's location."

	input InsertSound(integer) : "Insert a sound in the AI sound list at a specified volume (1-100) which influences detection radius."
	input EmitAISound(void) : "Make the sound."
] // end ai_sound

@PointClass base(SBaseEntity, SBaseDiv, SEnableDisable) color(150 0 200) iconsprite("editor-ficool2/ai_speechfilter") = ai_speechfilter : "An entity that can be used to control the idle speech patterns of a set of NPCs." [
	subject(target_destination) : "Subject(s)" :  : "This is the NPC(s) whose speech we're filtering. May be a targetname or a classname."
	IdleModifier(float) : "Idle modifier." : "1.0" : "Multiplier to the percentage chance that our NPC(s) will idle speak. Set to 0 to prevent all idle speech."
	NeverSayHello(choices) : "Greet Player?" : 0 : "If set to Yes, our NPC(s) won't greet the player when they first meet him." = [
		0 : "Yes"
		1 : "No"
	]

	input SetIdleModifier(float) : "Change the Idle Modifier keyvalue at any time."
] // end ai_speechfilter



	// AISCRIPTED ENTITIES //

@PointClass base(SBaseLogical, SBaseDiv) color(150 0 200) iconsprite("editor-ficool2/aiscripted_schedule") sphere(m_flRadius) = aiscripted_schedule : "Issues a command to an NPC without taking the NPC out of its AI. This does not seize control of the NPC as a scripted_sequence does." [
	m_iszEntity(target_destination) : "Target NPC" : : "The name or classname of an NPC to use."
	m_flRadius(integer) : "Search Radius" : 0 : "Radius to search within for an NPC to use. 0 searches everywhere."
	graball(choices)  : "All in radius?" : 0: "Whether to grab all matching NPCs in the specified radius, instead of just one." = [
		0 : "No"
		1 : "Yes"
	]
	forcestate(choices) : "AI state to set" : 0 : "Overrides the NPC's current alertness state." = [
		0 : "<None>"
		1 : "Set state to IDLE"
		2 : "Set state to ALERT"
		3 : "Set state to COMBAT"
	]
	schedule(choices) : "Schedule to run" : 1 :"Which AI schedule to run." = [
		0 : "<None>"
		1 : "Walk to Goal Entity"
		2 : "Run to Goal Entity"
		3 : "Set enemy to Goal Entity"
		4 : "Walk Goal Path"
		5 : "Run Goal Path"
		6 : "Set enemy to Goal Entity AND Run to Goal Entity"
	]
	interruptability(choices) : "Interruptability" : 0 = [
		0 : "General"
		1 : "Damage or Death"
		2 : "Death"
	]
	goalent(target_destination) : "Goal Entity" :  : "Provides the name of a schedule-specific goal entity (see 'Schedule to run'.) The entity itself may be used."

	spawnflags(flags) = [
		4 : "Repeatable" : 1
		1024 : "Search Cyclically (Affects all targets at once when triggered instead of selecting 1 random target each trigger)" : 0
		2048 : "Don't Complain (suppresses error messages)" : 0
	] // end spawnflags

	input StartSchedule(void) : "Starts the scripted schedule. This will first locate an NPC that matches the given target, then tell the NPC to run the specified schedule."
	input StopSchedule(void) : "Tells NPC targets to stop running this schedule."
] // end aiscripted_schedule



	// AMBIENT ENTITIES //

// TODO: Parentname keyvalue is explicitly included, does it work?
// Yes, kinda, but it's better if you just set a Source Entity - or use a soundscript instead cause this entity kind of sucks -Brokk
@BaseClass = ambient_generic_keys_1 [
	message(sound) : "Sound Name" :  : "The name of the sound to play. Can either be a soundscript name, a raw MP3 or WAV file, or a scripted sentence. For scripted sentences, type '!' followed by the sentence name. If the sound needs to be recognised as 'music' by the engine, precede the path with a '#'."
	health(integer) : "Volume" : 10 : "Sound volume, expressed as a range from 0 to 10, where 10 is the loudest. Also affects the actual maximum audible distance. Has no effect on soundscripts; use the volume setting in the soundscript file instead."
	radius(string) : "Max Audible Range" : 1024 : "Maximum distance at which this sound is audible. Determines how quickly the sound fades out as the player moves away from the source. The sound may still be audible outside of this range, likely due to DSP; the actual maximum range will be slightly higher than this value. Has no effect on soundscripts; use the soundlevel setting in the soundscript file instead." // the actual max range isn't even consistent across various rounds of the same exact map, like the game just uses a random number generator to figure out what to add to this value... fuck this entity can suck my dick
	SourceEntityName(target_destination) : "Source Entity" :  : "If an entity is specified, sound will come from the specified entity instead of the ambient_generic. If the target is capable of lipsynching, and phoneme data is found within the sound, the target will lip-sync to it. If the source entity is killed (or the ambient_generic, if there is no specified target), the sound will play from the map origin. Entity must exist at spawn or this will not work. If the target moves while sound is playing, the sound's source will not update."
] // end ambient_generic_keys_1
@PointClass base(STargetname, SParentname, SBaseIO, SBaseDiv, ambient_generic_keys_1, SClassDiv1) iconsprite("editor-ficool2/ambient_generic") line(255 255 255, targetname, SourceEntityName) sphere(radius) = ambient_generic : "It plays a sound, either once or on loop, and either from a location in the world or globally. This entity's behavior can be very buggy and sometimes inconsistent." [
	preset(choices) : "Dynamic Presets" : 0 : "Various DSP effects that can be applied." = [
		0 : "None"
		1 : "Huge Machine"
		2 : "Big Machine"
		3 : "Machine"
		4 : "Slow Fade In"
		5 : "Fade In"
		6 : "Quick Fade In"
		7 : "Slow Pulse"
		8 : "Pulse"
		9 : "Quick Pulse"
		10 : "Slow Oscillator"
		11 : "Oscillator"
		12 : "Quick Oscillator"
		13 : "GrungePitch"
		14 : "Very Low Pitch"
		15 : "Low Pitch"
		16 : "High Pitch"
		17 : "Very High Pitch"
		18 : "Screaming Pitch"
		19 : "Oscillate Spinup/Down"
		20 : "Pulse Spinup/Down"
		21 : "Random Pitch"
		22 : "Random Pitch Fast"
		23 : "Incremental Spinup"
		24 : "Alien"
		25 : "Bizzare"
		26 : "Planet X"
		27 : "Haunted"
	] // end preset
	volstart(integer) : "Start Volume" : 0 : "The starting volume of this sound. When the entity is triggered, the volume will either go down to 0 or up to the Full Volume, depending on which input you send the ambient_generic."
	fadeinsecs(integer) : "Fade In time (0-100)" : 0 : "Time taken to fade the sound from 0 volume to 100% volume.  Measured as a percentage of the sound's length."
	fadeoutsecs(integer) : "Fade Out time (0-100)" : 0 : "Time taken to fade the sound from 100% volume to 0 volume.  Measured as a percentage of the sound's length."
	pitch(integer) : "Full Pitch" : 100 : "Sound pitch, expressed as a range from 1 to 255, where 100 is the sound's default pitch."
	pitchstart(integer) : "Start Pitch" : 100 : "The starting pitch of the sound."
	spinup(integer) : "Spin Up time (0-100)" : 0 : "Same as fade in time, but for pitch, not volume."
	spindown(integer) : "Spin Down time (0-100)" : 0 : "Same as fade out time, but for pitch, not volume."
	lfotype(choices) : "LFO type" : 0 : "The type of vibrato to apply to the sound.  (LFO = low-frequency oscillator = vibrato)" = [
		0 : "Off"
		1 : "Square: full up or down, never middle"
		2 : "Triangle:  fade between up and down"
		3 : "Random"
	] // end lfotype
	lforate(integer) : "LFO rate (0-1000)" : 0 : "Rate of pitch changes if an LFO type is specified."
	lfomodpitch(integer) : "LFO mod pitch (0-100)" : 0 : "Amount by which to change the pitch if an LFO type is selected."
	lfomodvol(integer) : "LFO mod volume (0-100)" : 0 : "Amount by which to change the volume if an LFO type is selected."
	cspinup(integer) : "Incremental Spinup Count (1-100)" : 0 : "When nonzero, scales the amount by which the pitch of the sound is increased with each PlaySound input until the pitch reaches the maximum supported."

	spawnflags(flags) = [
		1 : "Play Everywhere - Ignore Max Range, don't fade over distance (no effect on soundscripts)" : 0
		16 : "Start Silent - Automatically checked with nonlooping sounds" : 1
		32 : "Is NOT Looped - Specifies what type of sound is being played, causes bugs if set incorrectly" : 1
	] // end spawnflags

	input Pitch(integer) : "Starts the sound and sets the sound pitch, expressed as a range from 1 to 255, where 100 is the sound's default pitch."
	input Volume(float) : "Starts the sound and sets the sound volume, expressed as a range from 0 to 10, where 10 is the loudest. A value of 0 will cause the sound to stop playing." // TODO: Restarts sound?

	input FadeIn(integer) : "Fades the sound up to full volume over a specified number of seconds, with a range from 0 to 100 seconds."
	input FadeOut(integer) : "Brings up the Volume to 10 and fades the sound to silence over a specified number of seconds, with a range from 0 to 100 seconds."
	input PlaySound(void) : "Starts the sound."
	input StopSound(void) : "Stops the sound if it is playing. Does not stop a non-looping sound, in which case the Volume input can be used with a value of 0 as a workaround."
	input ToggleSound(void) : "Toggles the sound between playing and stopped. Sound can only be stopped with this if it is a looping sound."
] // end ambient_generic



	// ARCHER ENTITIES //

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SBaseDynamicModel) color(150 0 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/weapons/w_models/w_arrow.mdl") = archer_proxy : "A stationary entity that fires Huntsman arrows at players, regardless of team. The entity does not compensate shots for obstacles, distance, or motion. The entity appears as an arrow model in-game." [
] // end archer_proxy



	// ASSAULT ENTITIES //

@PointClass base(SBaseEntity, SBaseDiv) color(150 0 200) iconsprite("editor-ficool2/assault_assaultpoint") line(255 255 255, targetname, nextassaultpoint) sphere (allowdiversionradius) = assault_assaultpoint : "These entities form the body of an assault chain, specifying where the assault should go once it has begun. There can be any number of them in each chain. Naming assault points the same name will cause NPCs to randomly select one. Specifying an assault_rallypoint as the next assault point will crash the game!" [
	assaultgroup(string)  : "Assault Hint Group" :  : "NPC's movements are constrained to this hint group once assault has begun."
	nextassaultpoint(target_destination) : "Next assault point (optional)" :  : "The assault_assaultpoint to move to next."
	assaulttimeout(float) : "Assault time out" : "3.0" : "This point is cleared when no enemies are seen for this long (specified in seconds). The NPC(s) at this assault point will scout for enemies this long before moving on."
	clearoncontact(choices) : "Clear on contact with enemies?" : 0 : "If the assaulting NPC meets enemies on its way to this point, it will consider the assault point cleared and target the next assault point in the chain." = [
		0 : "No"
		1 : "Yes"
	] // end clearoncontact
	allowdiversion(choices) : "Allow Diversion?" : 0 : "If the assault comes into contact with hostiles on the way to this assault point, divert to kill them and resume once the area appears clear. " = [
		0 : "No"
		1 : "Yes"
	] // end allowdiversion
	allowdiversionradius(float) : "Diversion Proximity" : 0 : "If Allow Diversion is set to Yes, NPC will only divert from assault to attack an enemy that is within this distance of the assault point. 0 means no limit."
	nevertimeout(choices) : "Never Timeout?" : 0 : "If set, the assault never ends for NPCs assaulting this point. Useful for forcing NPCs back to a point." = [
		0 : "No"
		1 : "Yes"
	] // end nevertimeout
	strict(choices) : "Strict?" : 0 : "If set, the assault never ends for NPCs assaulting this point. Useful for forcing NPCs back to a point." = [
		0 : "No, NPC may move from point to attack"
		1 : "Yes, NPC may not move to attack"
	] // end strict
	forcecrouch(choices) : "Force Crouch?" : 0 : "NPCs using this assault point are forced into crouching while holding it. Only works for NPCs that have crouching as part of their natural AI." = [
		0 : "No"
		1 : "Yes"
	] // end forcecrouch
	urgent(choices) : "Urgent?" : 0 : "If true, NPCs will consider movement to this assault point as Urgent Navigation." = [
		0 : "No"
		1 : "Yes"
	] // end urgent
	assaulttolerance(choices) : "Attack Tolerance" : 36 : "How far this NPC may move from the assault point to try to attack an enemy." = [
		36 : "Tight (3ft)"
		72 : "Medium (6ft)"
		120 : "Large (10ft)"
	] // end assaulttolerance

	spawnflags(flags) = [
		1 : "Clear this point upon arrival, move to next point unconditionally" : 0
	] // end spawnflags

	input SetAllowDiversion(string) : "Sets the Allow Diversion keyvalue. Accepts 1/0 or Yes/No as parameters."
	input SetClearOnContact(integer) : "Sets the Clear on Contact with enemies keyvalue. Accepts 1/0 or Yes/No as parameters."
	input SetForceClear(integer) : "Set the Force Clear flag. NPCs who are currently running to the assault point will clear it immediately. NPCs who acquire it in the future will clear it automatically."

	output OnArrival(void) : "Fires when the NPC reaches this assault point. Can fire more than once."
	output OnAssaultClear(void) : "Fires when this assault point is cleared of enemies."
] // end assault_assaultpoint

@PointClass base(SBaseEntity, SBaseDiv) color(150 0 200) iconsprite("editor-ficool2/assault_rallypoint") line(255 255 255, targetname, assaultpoint) = assault_rallypoint : "It specifies a point used to rally NPCs for assault behaviour." [
	assaultpoint(target_destination)  : "Assault Point" :  : "The first assault_assaultpoint in the chain to move to as the assault begins."
	assaultdelay(float) : "Assault Delay" : 0 : "The amount of time to wait here once the assault cue has been given, before moving to the first assault_assaultpoint."
	rallysequence(string) : "Rally Sequence" :  : "Set a specific animation sequence for NPCs waiting to begin the assault, overriding the wait activity of the NPC."
	priority(integer) : "Priority" : 1 : "How appealing the rallypoint will be. When an NPC receives the Assault input, it will select a suitable rallypoint from those available to it, preferring the one with the highest Priority value. If the Priority is the same between any rallypoints, the closest one will be chosen."
	forcecrouch(choices) : "Force Crouch?" : 0 : "NPCs using this assault point are forced into crouching while holding it." = [
		0 : "No"
		1 : "Yes"
	]
	urgent(choices) : "Urgent?" : 0 : "If true, NPCs will consider movement to this rally point as Urgent Navigation." = [
		0 : "No"
		1 : "Yes"
	]

	output OnArrival(void) : "Fires when the NPC reaches this rally point."
] // end assault_rallypoint



	// BASE ENTITIES //

@PointClass base(SModel, SBaseEntity, SBaseDiv, SHealth, SHealthMax, SBoss, SEnableDisable, SModelSkin, SModelBodyGroup, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) color(150 0 200) studioprop() = base_boss : "An entity used as a base for several TF2 bosses, such as the MvM Tank, HHH or Merasmus. Drops MvM money upon death. Can be made more useful by bonemerging this entity to a prop_dynamic, allowing for a fake-simulated boss." [
	max_health(integer) : "Max Health" : 10000 : "Maximum health of this entity."
] // end base_boss



	// BOT ENTITIES //
// TODO: hmm. i don't think i've done any actual testing on these, perhaps its time for that...

@PointClass base(SBaseEntity, SBaseDiv) color(150 0 200) iconsprite("editor-ficool2/bot_action_point") line(255 255 255, targetname, next_action_point) sphere(desired_distance) = bot_action_point : "A potential destination for a bot" [
	next_action_point(target_destination) : "Next Action Point" :  : "The next Action Point to approach after performing this one."
	desired_distance(float) : "Desired Distance" : 64 : "The distance to get within when approaching this Action Point before the bot says it has reached it."
	stay_time(float) : "Stay Time" : 0 : "How long the bot should stay at this action point (while perform any commands if applicable)."
	command(choices) : "Command" :  : "Command to give to the bot when it gets within range of this Action Point." = [
		"taunt" : "Taunt"
		"despawn" : "Leave the game"
		"cloak" : "If Spy, Cloak"
		"uncloak" : "If Spy, Uncloak"
		"attack sentry at next action point" : "Attack sentry gun at next action point"
		"disguise" : "If Spy, Disguise"
		"build sentry at nearest sentry hint" : "If Engineer, build a sentry gun at the nearest sentry hint"
	] // end command

	output OnBotReached(void) : "Fires when the bot reaches this point."
] // end bot_action_point

@PointClass base(SBaseEntity, SBaseDiv, STFTeam) color(150 0 200) iconsprite("editor-ficool2/bot_controller")  = bot_controller : "An entity used to create a bot, and then issue commands to it." [
	bot_name(string) : "Bot Name" :  : "Name of the bot. Does not function correctly, can spew out gibberish names."
	bot_class(choices) : "Class" : 0 : "The class the bot will spawn as." = [
		0 : "Random"
		1 : "Scout"
		2 : "Sniper"
		3 : "Soldier"
		4 : "Demoman"
		5 : "Medic"
		6 : "Heavy"
		7 : "Pyro"
		8 : "Spy"
		9 : "Engineer"
	] // end bot_class

	input AddCommandAttackEntity(target_destination) : "Add a command to the bot's queue, telling it to attack the specified entity."
	input AddCommandDefend(float) : "Add a command to the bot's queue, telling it to defend the position it's standing at. The parameter specifies the distance from the point that the Bot is allowed to move to fight enemies."
	input AddCommandMoveToEntity(target_destination) : "Add a command to the bot's queue, telling it to move to the specified entity."
	input AddCommandSwitchWeapon(integer) : "Add a command to the bot's queue, telling it to switch to the specified weapon slot."
	input ClearQueue(void) : "Clear the bot's command queue."
	input CreateBot(void) : "Create the bot for this controller."
	input PreventMovement(integer) : "Set whether or not the Bot is allowed to move. 1 = prevent movement, 0 = allow movement."
	input RespawnBot(void) : "Force the bot to respawn."
	input SetIgnoreHumans(bool) : "Set whether or not the Bot should ignore human players. 1 = ignore, 0 = don't ignore."

	output OnCommandFinished(void) : "Sent when a command finishes."
] // end bot_controller

@PointClass base(SBaseEntity, SBaseDiv) color(150 0 200) iconsprite("editor-ficool2/bot_generator") line(255 255 255, targetname, action_point) = bot_generator : "Entity that spawns <Count> TFBots every <Interval> seconds, with at most <Max Active> active at once." [
	count(integer) : "Count" : 1 : "Number of TFBots to spawn over the lifetime of this bot generator."
	maxActive(integer) : "Max Active" : 1 : "Maximum number of active TFBots spawned at any given time from this generator."
	interval(float) : "Interval" : 0 : "Time (in seconds) between spawns."
	team(choices) : "Team" : "auto" : "Team of the TFBots." = [
		"auto" : "Any"
		"red" : "Red"
		"blue" : "Blue"
	] // end team
	class(choices) : "Class" : "auto" : "Class of the TFBots." = [
		"auto" : "Random"
		"scout" : "Scout"
		"soldier" : "Soldier"
		"pyro" : "Pyro"
		"demoman" : "Demoman"
		"heavyweapons" : "Heavy"
		"engineer" : "Engineer"
		"medic" : "Medic"
		"sniper" : "Sniper"
		"spy" : "Spy"
	] // end class
	difficulty(choices) : "Difficulty" : 0 : "The skill level of bots created by this generator." = [
		-1 : "Default"
		0 : "Easy"
		1 : "Normal"
		2 : "Hard"
		3 : "Expert"
	] // end difficulty
	spawnOnlyWhenTriggered(choices) : "Don't spawn bots unless triggered?" : 0 : "If this is set, you must use the SpawnBot input to have any bots spawn" = [
		0 : "No"
		1 : "Yes"
	] // end spawnOnlyWhenTriggered
	useTeamSpawnPoint(choices) : "Use Team Spawn Point?" : 0 : "TFBots will use their team spawn point, instead of this point if this is set." = [
		0 : "No"
		1 : "Yes"
	] // end useTeamSpawnPoint
	initial_command(choices) : "Initial Command" :  : "Initial command to give this bot, if any." = [
		"goto action point" : "Go to specified Action Point"
		"taunt" : "Taunt"
		"despawn" : "Leave the game"
		"cloak" : "If Spy, Cloak"
		"uncloak" : "If Spy, Uncloak"
		"attack sentry at next action point" : "Attack sentry gun at next action point"
		"disguise" : "If Spy, Disguise"
	] // end initial_command
	action_point(target_destination) : "Action Point" :  : "The name of a bot_action_point which the bot will move to after spawning."
	suppressFire(choices) : "Suppress Fire?" : 0 : "Newly generated TFBots will suppress their fire if this is set." = [
		0 : "No"
		1 : "Yes"
	] // end suppressFire
	disableDodge(choices) : "Disable Dodge?" : 0 : "Newly generated TFBots will not dodge if this is set." = [
		0 : "No"
		1 : "Yes"
	] // end disableDodge
	actionOnDeath(choices) : "Action on Death" : 1 : "When a TFBot dies, they will either respawn like a normal player, remove themselves, or move to the spectator team." = [
		0 : "Respawn as usual"
		1 : "Remove self"
		2 : "Move to Spectator team"
	] // end actionOnDeath
	spectateOnDeath(choices) : "Move to Spectator Team on Death?" : 0 : "TFBots will move to the Spectator team on death. Use this as a pooling mechanism." = [
		0 : "No"
		1 : "Yes"
	] // end spectateOnDeath
	retainBuildings(choices) : "Retain Buildings After Disconnect?" : 0 : "If set, any buildings (sentries, sappers, etc) built by bots from this generator will not be destroyed when their owners are removed." = [
		0 : "No"
		1 : "Yes"
	] // end retainBuildings

	spawnflags(flags) = [
		1 : "Spawned Bots Ignore Enemy Scouts" : 0
		2 : "Spawned Bots Ignore Enemy Soldiers" : 0
		4 : "Spawned Bots Ignore Enemy Pyros" : 0
		8 : "Spawned Bots Ignore Enemy Demomen" : 0
		16 : "Spawned Bots Ignore Enemy Heavies" : 0
		32 : "Spawned Bots Ignore Enemy Medics" : 0
		64 : "Spawned Bots Ignore Enemy Engineers" : 0
		128 : "Spawned Bots Ignore Enemy Snipers" : 0
		256 : "Spawned Bots Ignore Enemy Spies" : 0
		512 : "Spawned Bots Ignore Enemy Sentry Guns" : 0
		1024 : "Spawned Bots Ignore Scenario Goals" : 0
	] // end spawnflags

	input ClearAttentionFocus(target_destination) : "Remove attention focus restrictions from bots spawned by this generator."
	input CommandGotoActionPoint(target_destination) : "Commands all bots spawned by this generator to go to the specified action point by name."
	input SetAttentionFocus(target_destination) : "All bots spawned by this generator will focus exclusively on this entity. If entity is action point, entities within that point's radius will be attended to."
	input SetDifficulty(integer) : "Change the skill level of subsequently generated bots (-1=default, 0=easy, 1=normal, 2=hard, 3=expert)."
	input SetDisableDodge(bool) : "Set whether TFBots should have the dodge ability disabled or not."
	input SetSuppressFire(bool) : "Set whether TFBots should suppress their fire."

	input Disable(void) : "Stop spawning TFBots."
	input Enable(void) : "Begin spawning TFBots."
	input RemoveBots(void) : "Force remove any bots this entity spawned."
	input SpawnBot(void) : "Attempt to spawn a bot within the rules specified."

	output OnBotKilled(void) : "Sent when a bot associated with this bot generator is killed."
	output OnExpended(void) : "Sent when the bot generator has reached its limit of the bots it can create."
	output OnSpawned(void) : "Sent when the TFBot has spawned into the environment."
] // end bot_generator

@PointClass base(SBaseEntity, SBaseDiv, SEnableDisable, STFTeam) color(150 0 200) studioprop("models/bots/engineer/bot_engineer.mdl") = bot_hint_engineer_nest : "A hint for engineer bots to build their nests. This is where the engineer will sit. Useful in conjuction with bot_hint_sentrygun and bot_hint_teleport_exit. These entities should share targetnames to link each other." [
] // end bot_hint_engineer_nest

@BaseClass = bot_hint_sentrygun_keys_1 [
	sticky(choices) : "Sticky?" : 0 : "If set, Engineer bots using this hint will stay here instead of destroying their equipment and moving up as the scenario changes." = [
		0 : "No"
		1 : "Yes"
	] // end sticky
] // end bot_hint_sentrygun_keys_1
@PointClass base(SBaseEntity, SBaseDiv, SEnableDisable, STFTeam, bot_hint_sentrygun_keys_1, SClassDiv1) color(150 0 200) sphere(rangehelper) studioprop("models/buildables/sentry3.mdl") = bot_hint_sentrygun : "Used to show bots a good place to build a sentry.  Useful in conjuction with bot_hint_engineer_nest and bot_hint_teleport_exit. These entities should share targetnames to link each other." [
	rangehelper(choices) : "Sight Radius (Display Only)" : 1100 : "DO NOT CHANGE. Keyvalue to display the range of the sentry gun (1100HU) in Hammer to assist with placement. Changing this value WILL NOT change the range of the sentry; this is for display purposes only." = [
		1100 : "1100"
	] // end rangehelper

	output OnSentryGunDestroyed(void) : "Fired when a sentry gun built on this hint is destroyed."
] // end bot_hint_sentrygun

// TODO: sticky?
@PointClass base(SBaseEntity, SBaseDiv, SEnableDisable, STFTeam) color(150 0 200) studioprop("models/buildables/teleporter_blueprint_exit.mdl") = bot_hint_teleporter_exit : "Used to show bots a good place to build a teleporter exit. Useful in conjuction with bot_hint_engineer_nest and bot_hint_sentrygun. These entities should share targetnames to link each other." [
] // end bot_hint_teleporter_exit

@PointClass base(SBaseEntity, SBaseDiv, SHealth, SHealthMax, STFTeam, SBaseDynamicModel) color(150 0 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/player/sniper.mdl") = bot_npc_archer : "A NextBot entity that wields a Hunstman. This entity will move only if a valid navigation mesh exists, and it is NOT an actual bot. As such, it will not take any player slot. The bot will go into Humiliation unless one of the following entities is present on the map: base_boss, eyeball_boss, headless_hatman, merasmus or tank_boss. The bot will attempt to shoot any BLU player regardless of its own team, and always tries to aim for the head. It will not compensate for gravity at very far distances. The bot can be killed by any player regardless of team. It will show blood for 'enemy' teams, but not show blood for 'friendly' teams. The corpse does not fade out." [
	health(integer) : "Health" : 125 : "Starting health of this bot. Cannot exceed Max Health. Must be changed with AddOutput, as it is overwritten on spawn."
	max_health(integer) : "Max Health" : 125 : "Maximum health of this bot. Must be changed with AddOutput, as it is overwritten on spawn."
] // end bot_npc_archer

@BaseClass = bot_proxy_keys [
	respawn_interval(float) : "Respawn Delay" : 0 : "If non-zero, respawn a bot N seconds after it dies."
] // end bot_proxy_keys
@PointClass base(SBaseEntity, SBaseDiv, bot_proxy_keys, SClassDiv1, SDoesNotFunctionPartial) color(150 0 200) iconsprite("editor-ficool2/bot_proxy") line(255 255 255, targetname, action_point) = bot_proxy : "An entity that spawns a TFBot and relays events to/from it. The TFBots are kicked after death. This entity is very broken/unfinished, use bot_generator instead." [
	bot_name(string) : "Bot Name" : "TFBot" : "Name of the bot. Creates gibberish names if specified."
	team(choices) : "Team" : "auto" : "Team of the bot. Does not function, always picks the red team. SetTeam input works, however." = [
		"auto" : "Any"
		"red" : "Red"
		"blue" : "Blue"
	] // end team
	class(choices) : "Class" : "auto" : "Class of the bot. Does not function, always picks a random class. SetClass input works, however." = [
		"auto" : "Random"
		"scout" : "Scout"
		"soldier" : "Soldier"
		"pyro" : "Pyro"
		"demoman" : "Demoman"
		"heavyweapons" : "Heavy"
		"engineer" : "Engineer"
		"medic" : "Medic"
		"sniper" : "Sniper"
		"spy" : "Spy"
	] // end class
	spawn_on_start(choices) : "Spawn on Start?" : 0 : "Does not function, use the Spawn input instead." = [
		0 : "No"
		1 : "Yes"
	] // end spawn_on_start
	action_point(target_destination) : "Action Point" :  : "Name of a bot_action_point to tell a bot to move to it when it spawns in. Does not function."

	input Delete(void) : "Delete any existing bots from this bot_proxy."
	input Spawn(void) : "Spawn a bot at this bot_proxy."

	input SetClass(string) : "Change the bot's class."
	input SetMovementGoal(target_destination) : "Tell a bot to move to the given goal. Does not function."
	input SetTeam(string) : "Change the bot's team."

	//output OnAttackingEnemy(void) : "Sent when the TFBot has started attacking an enemy. Does not function."
	//output OnInjured(void) : "Sent when the TFBot has been injured. Does not function."
	//output OnKilled(void) : "Sent when the TFBot has been killed. Does not function."
	//output OnKilledEnemy(void) : "Sent when the TFBot has killed an enemy. Does not function."
	output OnSpawned(void) : "Sent when the TFBot has spawned into the environment."
]

@PointClass base(SDoesNotFunction, SPreservedEntity, SBaseLogical, SBaseDiv) color(150 0 200) iconsprite("editor/obsolete") = bot_roster : "An entity that specifies what classes TFBots can choose. Does not function." [ // iconsprite("editor-ficool2/bot_roster")
	team(choices) : "Team" : "auto" : "Allow TFBots to only join this team." = [
		"auto" : "Any"
		"red" : "Red"
		"blue" : "Blue"
	] // end team
	allowClassChanges(choices) : "Allow Class Changes?" : 1 : "Allow TFBots to choose a new class when they respawn." = [
		0 : "No"
		1 : "Yes"
	] // end allowClassChanges
	allowScout(choices) : "Allow Scout?" : 1 : "Allow TFBots to choose Scouts as a class." = [
		0 : "No"
		1 : "Yes"
	] // end allowScout
	allowSoldier(choices) : "Allow Soldier?" : 1 : "Allow TFBots to choose Soldiers as a class." = [
		0 : "No"
		1 : "Yes"
	] // end allowSoldier
	allowPyro(choices) : "Allow Pyro?" : 1 : "Allow TFBots to choose Pyro as a class." = [
		0 : "No"
		1 : "Yes"
	] // end allowPyro
	allowDemoman(choices) : "Allow Demoman?" : 1 : "Allow TFBots to choose Demoman as a class." = [
		0 : "No"
		1 : "Yes"
	] // end allowDemoman
	allowHeavy(choices) : "Allow Heavy?" : 1 : "Allow TFBots to choose Heavy as a class." = [
		0 : "No"
		1 : "Yes"
	] // end allowHeavy
	allowEngineer(choices) : "Allow Engineer?" : 1 : "Allow TFBots to choose Engineer as a class." = [
		0 : "No"
		1 : "Yes"
	] // end allowEngineer
	allowMedic(choices) : "Allow Medics?" : 1 : "Allow TFBots to choose Medics as a class." = [
		0 : "No"
		1 : "Yes"
	] // end allowMedic
	allowSniper(choices) : "Allow Sniper?" : 1 : "Allow TFBots to choose Snipers as a class." = [
		0 : "No"
		1 : "Yes"
	] // end allowSniper
	allowSpy(choices) : "Allow Spy?" : 1 : "Allow TFBots to choose Spy as a class." = [
		0 : "No"
		1 : "Yes"
	] // end allowSpy

	input SetAllowDemoman(bool) : "Sets whether TFBots can choose Demoman as a class. 0 = No, 1 = Yes"
	input SetAllowEngineer(bool) : "Sets whether TFBots can choose Engineer as a class. 0 = No, 1 = Yes"
	input SetAllowHeavy(bool) : "Sets whether TFBots can choose Heavy as a class. 0 = No, 1 = Yes"
	input SetAllowMedic(bool) : "Sets whether TFBots can choose Medics as a class. 0 = No, 1 = Yes"
	input SetAllowPyro(bool) : "Sets whether TFBots can choose Pyro as a class. 0 = No, 1 = Yes"
	input SetAllowScout(bool) : "Sets whether TFBots can choose Scouts as a class. 0 = No, 1 = Yes"
	input SetAllowSniper(bool) : "Sets whether TFBots can choose Snipers as a class. 0 = No, 1 = Yes"
	input SetAllowSoldier(bool) : "Sets whether TFBots can choose Soldiers as a class. 0 = No, 1 = Yes"
	input SetAllowSpy(bool) : "Sets whether TFBots can choose Spy as a class. 0 = No, 1 = Yes"
	input SetTeam(integer) : "Sets what team TFBots can choose. auto = Any, red = RED, blue = BLU."
] // end bot_roster



	// COLOR ENTITIES //

@PointClass base(SBaseEntity, SBaseDiv, SEnableDisable) sphere(minfalloff) sphere(maxfalloff) iconsprite("editor-ficool2/color_correction") = color_correction : "An entity to control the color correction in the map. It loads a color correction lookup table (.raw) and controls its strength. Correction is applied in a sphere surrounding the entity, with a configurable amount of falloff." [
	filename(string) : "Lookup Table Filename" :  : "Path to the .raw file containing the lookup table."
	maxweight(float) : "Maximum Weight" : "1.0" : "This is the maximum weight for this lookup."
	minfalloff(float) : "Lookup Falloff Start Distance" : "0.0" : "Within this range to the entity, the effect will be at full strength. If this is larger than the End Distance, the effect will apply to the entire map."
	maxfalloff(float) : "Lookup Falloff End Distance" : "256.0" : "Maximum distance from the entity that the effect is applied. At this distance, the effect is barely apparent but will strengthen as the viewer approaches the Start Distance."
	fadeInDuration(float) : "Lookup Fade In Duration" : "0.0" : "When the entity becomes Enabled, how long the effect takes to fade in."
	fadeOutDuration(float) : "Lookup Fade out Duration" : "0.0" : "When the entity becomes Disabled, how long the effect takes to fade out."

	input SetFadeInDuration(float) : "Sets the Lookup Fade In Duration."
	input SetFadeOutDuration(float) : "Sets the Lookup Fade out Duration."
] // end color_correction



	// CYCLER ENTITIES //

@BaseClass = cycler_actor_keys [
	Sentence(string) : "Sentence Group" :  : "Unknown function."
	hull_name(choices) : "Hull Type" : "Human" : "Physical size of the entity. Affects navigation capabilities and the bounding box." = [
		"HUMAN_HULL" : "Human"
		"TINY_HULL" : "Tiny"
		"MEDIUM_HULL" : "Medium"
		"LARGE_HULL" : "Large"
		"WIDE_HUMAN_HULL" : "Wide"
	] // end hull_name
] // end cycler_actor_keys
@PointClass base(SModel, SBaseEntity, SBaseDiv, SModelSkin, SModelBodyGroup, cycler_actor_keys, SBaseNPC, SBaseDynamicModel) color(150 0 200) sphere(fademindist) sphere(fademaxdist) studioprop() = cycler_actor : "An entity which creates a testing NPC. Used to test expressions and sentences." [
] // end cycler_actor

@PointClass base(SModel, SBaseEntity, SModelSkin, SModelBodyGroup, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop() = cycler_flex : "An entity used to display a model for testing purposes, specifically flexes. Shooting it will cycle through the model's animations." [
] // end cycler_flex



	// ENTITY ENTITIES //

// "Archimedes, vhat is zhat ticking sound?"
@PointClass base(SBaseEntity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/props_forest/bird.mdl") = entity_bird : "A dove that explodes when touched or shot, dealing no damage to nearby players." [
] // end entity_bird

@PointClass base(SPreservedEntity, SBaseEntity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/soldier_statue/soldier_statue.mdl") = entity_soldier_statue : "Memorial statue for Rick May, the voice of Soldier. Occasionally plays random Soldier voicelines to nearby players." [
] // end entity_soldier_statue

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-abs/entity_spawn_manager") = entity_spawn_manager : "An entity that spawns an entity class at entity_spawn_points." [
	entity_name(choices) : "Entity Class" :  : "Classname of the entity we are supposed to spawn. (Not a targetname or point_template!)" = [
		"_ballplayertoucher" : "_ballplayertoucher"
		"_firesmoke" : "_firesmoke"
		"_plasma" : "_plasma"
		"ai_ally_speech_manager" : "ai_ally_speech_manager"
		"ai_battle_line" : "ai_battle_line"
		"ai_changehintgroup" : "ai_changehintgroup"
		"ai_changetarget" : "ai_changetarget"
		"ai_goal_assault" : "ai_goal_assault"
		"ai_goal_follow" : "ai_goal_follow"
		"ai_goal_lead" : "ai_goal_lead"
		"ai_goal_lead_weapon" : "ai_goal_lead_weapon"
		"ai_goal_standoff" : "ai_goal_standoff"
		"ai_hint" : "ai_hint"
		"ai_network" : "ai_network"
		"ai_relationship" : "ai_relationship"
		"ai_script_conditions" : "ai_script_conditions"
		"ai_sound" : "ai_sound"
		"ai_speechfilter" : "ai_speechfilter"
		"aiscripted_schedule" : "aiscripted_schedule"
		"aitesthull" : "aitesthull"
		"ambient_generic" : "ambient_generic"
		"archer_proxy" : "archer_proxy"
		"assault_assaultpoint" : "assault_assaultpoint"
		"assault_rallypoint" : "assault_rallypoint"
		"base_boss" : "base_boss"
		"beam" : "beam"
		"bot_action_point" : "bot_action_point"
		"bot_controller" : "bot_controller"
		"bot_generator" : "bot_generator"
		"bot_hint_engineer_nest" : "bot_hint_engineer_nest"
		"bot_hint_sentrygun" : "bot_hint_sentrygun"
		"bot_hint_teleporter_exit" : "bot_hint_teleporter_exit"
		"bot_npc_archer" : "bot_npc_archer"
		"bot_npc_decoy" : "bot_npc_decoy"
		"bot_proxy" : "bot_proxy"
		"bot_roster" : "bot_roster"
		"color_correction" : "color_correction"
		"color_correction_volume" : "color_correction_volume"
		"commentary_auto" : "commentary_auto"
		"cycler_actor" : "cycler_actor"
		"cycler_flex" : "cycler_flex"
		"dispenser_touch_trigger" : "dispenser_touch_trigger"
		"dynamic_prop" : "dynamic_prop"
		"entity_bird" : "entity_bird"
		"entity_blocker" : "entity_blocker"
		"entity_carrier" : "entity_carrier"
		"entity_croc" : "entity_croc"
		"entity_medigun_shield" : "entity_medigun_shield"
		"entity_revive_marker" : "entity_revive_marker"
		"entity_rocket" : "entity_rocket"
		"entity_saucer" : "entity_saucer"
		"entity_sign" : "entity_sign"
		"entity_soldier_statue" : "entity_soldier_statue"
		"entity_spawn_manager" : "entity_spawn_manager"
		"entity_spawn_point" : "entity_spawn_point"
		"entityflame" : "entityflame"
		"env_beam" : "env_beam"
		"env_beverage" : "env_beverage"
		"env_blood" : "env_blood"
		"env_bubbles" : "env_bubbles"
		"env_credits" : "env_credits"
		"env_debughistory" : "env_debughistory"
		"env_detail_controller" : "env_detail_controller"
		"env_dustpuff" : "env_dustpuff"
		"env_dusttrail" : "env_dusttrail"
		"env_effectscript" : "env_effectscript"
		"env_embers" : "env_embers"
		"env_entity_dissolver" : "env_entity_dissolver"
		"env_entity_igniter" : "env_entity_igniter"
		"env_entity_maker" : "env_entity_maker"
		"env_explosion" : "env_explosion"
		"env_fade" : "env_fade"
		"env_fire" : "env_fire"
		"env_fire_trail" : "env_fire_trail"
		"env_firesensor" : "env_firesensor"
		"env_firesource" : "env_firesource"
		"env_fog_controller" : "env_fog_controller"
		"env_funnel" : "env_funnel"
		"env_global" : "env_global"
		"env_glow" : "env_glow"
		"env_gunfire" : "env_gunfire"
		"env_hudhint" : "env_hudhint"
		"env_laser" : "env_laser"
		"env_laserdot" : "env_laserdot"
		"env_lightglow" : "env_lightglow"
		"env_message" : "env_message"
		"env_microphone" : "env_microphone"
		"env_movieexplosion" : "env_movieexplosion"
		"env_muzzleflash" : "env_muzzleflash"
		"env_particle_performance_monitor" : "env_particle_performance_monitor"
		"env_particle_trail" : "env_particle_trail"
		"env_particlefire" : "env_particlefire"
		"env_particlelight" : "env_particlelight"
		"env_particlescript" : "env_particlescript"
		"env_particlesmokegrenade" : "env_particlesmokegrenade"
		"env_physexplosion" : "env_physexplosion"
		"env_physimpact" : "env_physimpact"
		"env_physwire" : "env_physwire"
		"env_player_surface_trigger" : "env_player_surface_trigger"
		"env_projectedtexture" : "env_projectedtexture"
		"env_quadraticbeam" : "env_quadraticbeam"
		"env_ragdoll_boogie" : "env_ragdoll_boogie"
		"env_rockettrail" : "env_rockettrail"
		"env_rotorshooter" : "env_rotorshooter"
		"env_screeneffect" : "env_screeneffect"
		"env_screenoverlay" : "env_screenoverlay"
		"env_shake" : "env_shake"
		"env_shooter" : "env_shooter"
		"env_smokestack" : "env_smokestack"
		"env_smoketrail" : "env_smoketrail"
		"env_sniperdot" : "env_sniperdot"
		"env_soundscape" : "env_soundscape"
		"env_soundscape_proxy" : "env_soundscape_proxy"
		"env_soundscape_triggerable" : "env_soundscape_triggerable"
		"env_spark" : "env_spark"
		"env_splash" : "env_splash"
		"env_sporeexplosion" : "env_sporeexplosion"
		"env_sporetrail" : "env_sporetrail"
		"env_sprite" : "env_sprite"
		"env_sprite_oriented" : "env_sprite_oriented"
		"env_spritetrail" : "env_spritetrail"
		"env_steam" : "env_steam"
		"env_steamjet" : "env_steamjet"
		"env_sun" : "env_sun"
		"env_texturetoggle" : "env_texturetoggle"
		"env_tonemap_controller" : "env_tonemap_controller"
		"env_tracer" : "env_tracer"
		"env_viewpunch" : "env_viewpunch"
		"env_wind" : "env_wind"
		"env_zoom" : "env_zoom"
		"event_queue_saveload_proxy" : "event_queue_saveload_proxy"
		"eyeball_boss" : "eyeball_boss"
		"filter_activator_class" : "filter_activator_class"
		"filter_activator_mass_greater" : "filter_activator_mass_greater"
		"filter_activator_name" : "filter_activator_name"
		"filter_activator_team" : "filter_activator_team"
		"filter_activator_tfteam" : "filter_activator_tfteam"
		"filter_base" : "filter_base"
		"filter_damage_type" : "filter_damage_type"
		"filter_enemy" : "filter_enemy"
		"filter_multi" : "filter_multi"
		"filter_tf_bot_has_tag" : "filter_tf_bot_has_tag"
		"filter_tf_class" : "filter_tf_class"
		"filter_tf_condition" : "filter_tf_condition"
		"filter_tf_damaged_by_weapon_in_slot" : "filter_tf_damaged_by_weapon_in_slot"
		"filter_tf_player_can_cap" : "filter_tf_player_can_cap"
		"fish" : "fish"
		"funCBaseFlex" : "funCBaseFlex"
		"func_achievement" : "func_achievement"
		"func_areaportal" : "func_areaportal"
		"func_areaportalwindow" : "func_areaportalwindow"
		"func_breakable" : "func_breakable"
		"func_breakable_surf" : "func_breakable_surf"
		"func_brush" : "func_brush"
		"func_button" : "func_button"
		"func_capturezone" : "func_capturezone"
		"func_changeclass" : "func_changeclass"
		"func_clip_vphysics" : "func_clip_vphysics"
		"func_conveyor" : "func_conveyor"
		"func_croc" : "func_croc"
		"func_door" : "func_door"
		"func_door_rotating" : "func_door_rotating"
		"func_dustcloud" : "func_dustcloud"
		"func_dustmotes" : "func_dustmotes"
		"func_fish_pool" : "func_fish_pool"
		"func_flag_alert" : "func_flag_alert"
		"func_flagdetectionzone" : "func_flagdetectionzone"
		"func_forcefield" : "func_forcefield"
		"func_guntarget" : "func_guntarget"
		"func_illusionary" : "func_illusionary"
		"func_ladderendpoint" : "func_ladderendpoint"
		"func_lod" : "func_lod"
		"func_monitor" : "func_monitor"
		"func_movelinear" : "func_movelinear"
		"func_nav_avoid" : "func_nav_avoid"
		"func_nav_avoidance_obstacle" : "func_nav_avoidance_obstacle"
		"func_nav_blocker" : "func_nav_blocker"
		"func_nav_prefer" : "func_nav_prefer"
		"func_nav_prerequisite" : "func_nav_prerequisite"
		"func_nobuild" : "func_nobuild"
		"func_nogrenades" : "func_nogrenades"
		"func_occluder" : "func_occluder"
		"func_passtime_goal" : "func_passtime_goal"
		"func_passtime_goalie_zone" : "func_passtime_goalie_zone"
		"func_passtime_no_ball_zone" : "func_passtime_no_ball_zone"
		"func_physbox" : "func_physbox"
		"func_physbox_multiplayer" : "func_physbox_multiplayer"
		"func_plat" : "func_plat"
		"func_platrot" : "func_platrot"
		"func_powerupvolume" : "func_powerupvolume"
		"func_precipitation" : "func_precipitation"
		"func_proprrespawnzone" : "func_proprrespawnzone"
		"func_pushable" : "func_pushable"
		"func_reflective_glass" : "func_reflective_glass"
		"func_regenerate" : "func_regenerate"
		"func_respawnflag" : "func_respawnflag"
		"func_respawnroom" : "func_respawnroom"
		"func_respawnroomvisualizer" : "func_respawnroomvisualizer"
		"func_rot_button" : "func_rot_button"
		"func_rotating" : "func_rotating"
		"func_smokevolume" : "func_smokevolume"
		"func_suggested_build" : "func_suggested_build"
		"func_tanktrain" : "func_tanktrain"
		"func_tfbot_hint" : "func_tfbot_hint"
		"func_trackautochange" : "func_trackautochange"
		"func_trackchange" : "func_trackchange"
		"func_tracktrain" : "func_tracktrain"
		"func_train" : "func_train"
		"func_traincontrols" : "func_traincontrols"
		"func_upgradestation" : "func_upgradestation"
		"func_useableladder" : "func_useableladder"
		"func_vehicleclip" : "func_vehicleclip"
		"func_wall" : "func_wall"
		"func_wall_toggle" : "func_wall_toggle"
		"func_water" : "func_water"
		"func_water_analog" : "func_water_analog"
		"func_weight_button" : "func_weight_button"
		"game_end" : "game_end"
		"game_forcerespawn" : "game_forcerespawn"
		"game_gib_manager" : "game_gib_manager"
		"game_intro_viewpoint" : "game_intro_viewpoint"
		"game_player_equip" : "game_player_equip"
		"game_player_team" : "game_player_team"
		"game_ragdoll_manager" : "game_ragdoll_manager"
		"game_round_win" : "game_round_win"
		"game_score" : "game_score"
		"game_text" : "game_text"
		"game_text_tf" : "game_text_tf"
		"game_ui" : "game_ui"
		"game_weapon_manager" : "game_weapon_manager"
		"game_zone_player" : "game_zone_player"
		"generic_actor" : "generic_actor"
		"ghost" : "ghost"
		"gib" : "gib"
		"gibshooter" : "gibshooter"
		"grenade" : "grenade"
		"halloween_fortune_teller" : "halloween_fortune_teller"
		"halloween_souls_pack" : "halloween_souls_pack"
		"halloween_zapper" : "halloween_zapper"
		"hammer_updateignorelist" : "hammer_updateignorelist"
		"handle_dummy" : "handle_dummy"
		"handle_test" : "handle_test"
		"headless_hatman" : "headless_hatman"
		"hightower_teleport_vortex" : "hightower_teleport_vortex"
		"info_camera_link" : "info_camera_link"
		"info_constraint_anchor" : "info_constraint_anchor"
		"info_hint" : "info_hint"
		"info_intermission" : "info_intermission"
		"info_ladder_dismount" : "info_ladder_dismount"
		"info_landmark" : "info_landmark"
		"info_lighting_relative" : "info_lighting_relative"
		"info_mass_center" : "info_mass_center"
		"info_node" : "info_node"
		"info_node_air" : "info_node_air"
		"info_node_air_hint" : "info_node_air_hint"
		"info_node_climb" : "info_node_climb"
		"info_node_hint" : "info_node_hint"
		"info_node_link" : "info_node_link"
		"info_node_link_controller" : "info_node_link_controller"
		"info_npc_spawn_destination" : "info_npc_spawn_destination"
		"info_null" : "info_null"
		"info_observer_point" : "info_observer_point"
		"info_overlay_accessor" : "info_overlay_accessor"
		"info_particle_system" : "info_particle_system"
		"info_passtime_ball_spawn" : "info_passtime_ball_spawn"
		"info_player_deathmatch" : "info_player_deathmatch"
		"info_player_start" : "info_player_start"
		"info_player_teamspawn" : "info_player_teamspawn"
		"info_populator" : "info_populator"
		"info_powerup_spawn" : "info_powerup_spawn"
		"info_projecteddecal" : "info_projecteddecal"
		"info_radial_link_controller" : "info_radial_link_controller"
		"info_target" : "info_target"
		"info_teleport_destination" : "info_teleport_destination"
		"infodecal" : "infodecal"
		"instanced_scripted_scene" : "instanced_scripted_scene"
		"item_ammopack_full" : "item_ammopack_full"
		"item_ammopack_medium" : "item_ammopack_medium"
		"item_ammopack_small" : "item_ammopack_small"
		"item_armor" : "item_armor"
		"item_bonuspack" : "item_bonuspack"
		"item_currencypack_custom" : "item_currencypack_custom"
		"item_currencypack_large" : "item_currencypack_large"
		"item_currencypack_medium" : "item_currencypack_medium"
		"item_currencypack_small" : "item_currencypack_small"
		"item_healthammokit" : "item_healthammokit"
		"item_healthkit_full" : "item_healthkit_full"
		"item_healthkit_medium" : "item_healthkit_medium"
		"item_healthkit_small" : "item_healthkit_small"
		"item_powerup_crit" : "item_powerup_crit"
		"item_powerup_rune" : "item_powerup_rune"
		"item_powerup_rune_temp" : "item_powerup_rune_temp"
		"item_powerup_uber" : "item_powerup_uber"
		"item_sodacan" : "item_sodacan"
		"item_teamflag" : "item_teamflag"
		"item_teamflag_return_icon" : "item_teamflag_return_icon"
		"keyframe_rope" : "keyframe_rope"
		"keyframe_track" : "keyframe_track"
		"light" : "light"
		"light_dynamic" : "light_dynamic"
		"light_environment" : "light_environment"
		"light_glspot" : "light_glspot"
		"light_spot" : "light_spot"
		"logic_active_autosave" : "logic_active_autosave"
		"logic_auto" : "logic_auto"
		"logic_autosave" : "logic_autosave"
		"logic_branch" : "logic_branch"
		"logic_branch_listener" : "logic_branch_listener"
		"logic_case" : "logic_case"
		"logic_choreographed_scene" : "logic_choreographed_scene"
		"logic_collision_pair" : "logic_collision_pair"
		"logic_compare" : "logic_compare"
		"logic_lineto" : "logic_lineto"
		"logic_measure_movement" : "logic_measure_movement"
		"logic_multicompare" : "logic_multicompare"
		"logic_navigation" : "logic_navigation"
		"logic_proximity" : "logic_proximity"
		"logic_relay" : "logic_relay"
		"logic_scene_list_manager" : "logic_scene_list_manager"
		"logic_timer" : "logic_timer"
		"mapobj_cart_dispenser" : "mapobj_cart_dispenser"
		"material_modify_control" : "material_modify_control"
		"math_colorblend" : "math_colorblend"
		"math_counter" : "math_counter"
		"math_remap" : "math_remap"
		"merasmus" : "merasmus"
		"merasmus_dancer" : "merasmus_dancer"
		"momentary_door" : "momentary_door"
		"momentary_rot_button" : "momentary_rot_button"
		"monster_furniture" : "monster_furniture"
		"monster_generic" : "monster_generic"
		"monster_resource" : "monster_resource"
		"move_keyframed" : "move_keyframed"
		"move_rope" : "move_rope"
		"multisource" : "multisource"
		"npc_concussiongrenade" : "npc_concussiongrenade"
		"npc_contactgrenade" : "npc_contactgrenade"
		"npc_furniture" : "npc_furniture"
		"npc_handgrenade" : "npc_handgrenade"
		"npc_maker" : "npc_maker"
		"npc_template_maker" : "npc_template_maker"
		"npc_vehicledriver" : "npc_vehicledriver"
		"obj_attachment_sapper" : "obj_attachment_sapper"
		"obj_dispenser" : "obj_dispenser"
		"obj_sentrygun" : "obj_sentrygun"
		"obj_teleporter" : "obj_teleporter"
		"passtime_ball" : "passtime_ball"
		"passtime_logic" : "passtime_logic"
		"path_corner" : "path_corner"
		"path_corner_crash" : "path_corner_crash"
		"path_track" : "path_track"
		"pd_dispenser" : "pd_dispenser"
		"phys_ballsocket" : "phys_ballsocket"
		"phys_bone_follower" : "phys_bone_follower"
		"phys_constraint" : "phys_constraint"
		"phys_constraintsystem" : "phys_constraintsystem"
		"phys_convert" : "phys_convert"
		"phys_hinge" : "phys_hinge"
		"phys_keepupright" : "phys_keepupright"
		"phys_lengthconstraint" : "phys_lengthconstraint"
		"phys_magnet" : "phys_magnet"
		"phys_motor" : "phys_motor"
		"phys_pulleyconstraint" : "phys_pulleyconstraint"
		"phys_ragdollconstraint" : "phys_ragdollconstraint"
		"phys_ragdollmagnet" : "phys_ragdollmagnet"
		"phys_slideconstraint" : "phys_slideconstraint"
		"phys_spring" : "phys_spring"
		"phys_thruster" : "phys_thruster"
		"phys_torque" : "phys_torque"
		"physics_cannister" : "physics_cannister"
		"physics_entity_solver" : "physics_entity_solver"
		"physics_npc_solver" : "physics_npc_solver"
		"physics_prop" : "physics_prop"
		"physics_prop_ragdoll" : "physics_prop_ragdoll"
		"player" : "player"
		"player_loadsaved" : "player_loadsaved"
		"player_manager" : "player_manager"
		"player_speedmod" : "player_speedmod"
		"player_weaponstrip" : "player_weaponstrip"
		"point_anglesensor" : "point_anglesensor"
		"point_angularvelocitysensor" : "point_angularvelocitysensor"
		"point_bonusmaps_accessor" : "point_bonusmaps_accessor"
		"point_camera" : "point_camera"
		"point_clientcommand" : "point_clientcommand"
		"point_commentary_node" : "point_commentary_node"
		"point_commentary_viewpoint" : "point_commentary_viewpoint"
		"point_devshot_camera" : "point_devshot_camera"
		"point_enable_motion_fixup" : "point_enable_motion_fixup"
		"point_gamestats_counter" : "point_gamestats_counter"
		"point_hurt" : "point_hurt"
		"point_intermission" : "point_intermission"
		"point_message" : "point_message"
		"point_playermoveconstraint" : "point_playermoveconstraint"
		"point_populator_interface" : "point_populator_interface"
		"point_posecontroller" : "point_posecontroller"
		"point_proximity_sensor" : "point_proximity_sensor"
		"point_push" : "point_push"
		"point_servercommand" : "point_servercommand"
		"point_spotlight" : "point_spotlight"
		"point_teleport" : "point_teleport"
		"point_template" : "point_template"
		"point_tesla" : "point_tesla"
		"point_velocitysensor" : "point_velocitysensor"
		"point_viewcontrol" : "point_viewcontrol"
		"populator_internal_spawn_point" : "populator_internal_spawn_point"
		"prop_door_rotating" : "prop_door_rotating"
		"prop_dynamic" : "prop_dynamic"
		"prop_dynamic_ornament" : "prop_dynamic_ornament"
		"prop_dynamic_override" : "prop_dynamic_override"
		"prop_physics" : "prop_physics"
		"prop_physics_multiplayer" : "prop_physics_multiplayer"
		"prop_physics_override" : "prop_physics_override"
		"prop_physics_respawnable" : "prop_physics_respawnable"
		"prop_ragdoll" : "prop_ragdoll"
		"prop_ragdoll_attached" : "prop_ragdoll_attached"
		"prop_soccer_ball" : "prop_soccer_ball"
		"prop_sphere" : "prop_sphere"
		"prop_vehicle" : "prop_vehicle"
		"prop_vehicle_driveable" : "prop_vehicle_driveable"
		"raggib" : "raggib"
		"rd_robot_dispenser" : "rd_robot_dispenser"
		"rope_anchor" : "rope_anchor"
		"scene_manager" : "scene_manager"
		"scripted_scene" : "scripted_scene"
		"scripted_sentence" : "scripted_sentence"
		"scripted_sequence" : "scripted_sequence"
		"scripted_target" : "scripted_target"
		"shadow_control" : "shadow_control"
		"simple_bot" : "simple_bot"
		"simple_physics_brush" : "simple_physics_brush"
		"simple_physics_prop" : "simple_physics_prop"
		"sky_camera" : "sky_camera"
		"soundent" : "soundent"
		"spark_shower" : "spark_shower"
		"spotlight_end" : "spotlight_end"
		"spraycan" : "spraycan"
		"tank_boss" : "tank_boss"
		"tank_destruction" : "tank_destruction"
		"tanktrain_ai" : "tanktrain_ai"
		"tanktrain_aitarget" : "tanktrain_aitarget"
		"target_cdaudio" : "target_cdaudio"
		"target_changegravity" : "target_changegravity"
		"te_tester" : "te_tester"
		"team_control_point" : "team_control_point"
		"team_control_point_master" : "team_control_point_master"
		"team_control_point_round" : "team_control_point_round"
		"team_manager" : "team_manager"
		"team_round_timer" : "team_round_timer"
		"team_train_watcher" : "team_train_watcher"
		"teleport_vortex" : "teleport_vortex"
		"test_effect" : "test_effect"
		"test_proxytoggle" : "test_proxytoggle"
		"test_traceline" : "test_traceline"
		"tf_ammo_pack" : "tf_ammo_pack"
		"tf_base_minigame" : "tf_base_minigame"
		"tf_bonus_duck_pickup" : "tf_bonus_duck_pickup"
		"tf_bot" : "tf_bot"
		"tf_dropped_weapon" : "tf_dropped_weapon"
		"tf_flame" : "tf_flame"
		"tf_flame_manager" : "tf_flame_manager"
		"tf_gamerules" : "tf_gamerules"
		"tf_gas_manager" : "tf_gas_manager"
		"tf_generic_bomb" : "tf_generic_bomb"
		"tf_glow" : "tf_glow"
		"tf_halloween_gift_pickup" : "tf_halloween_gift_pickup"
		"tf_halloween_gift_spawn_location" : "tf_halloween_gift_spawn_location"
		"tf_halloween_minigame" : "tf_halloween_minigame"
		"tf_halloween_minigame_falling_platforms" : "tf_halloween_minigame_falling_platforms"
		"tf_halloween_pickup" : "tf_halloween_pickup"
		"tf_logic_arena" : "tf_logic_arena"
		"tf_logic_bonusround" : "tf_logic_bonusround"
		"tf_logic_competitive" : "tf_logic_competitive"
		"tf_logic_cp_timer" : "tf_logic_cp_timer"
		"tf_logic_holiday" : "tf_logic_holiday"
		"tf_logic_hybrid_ctf_cp" : "tf_logic_hybrid_ctf_cp"
		"tf_logic_koth" : "tf_logic_koth"
		"tf_logic_mann_vs_machine" : "tf_logic_mann_vs_machine"
		"tf_logic_mannpower" : "tf_logic_mannpower"
		"tf_logic_medieval" : "tf_logic_medieval"
		"tf_logic_minigames" : "tf_logic_minigames"
		"tf_logic_multiple_escort" : "tf_logic_multiple_escort"
		"tf_logic_on_holiday" : "tf_logic_on_holiday"
		"tf_logic_player_destruction" : "tf_logic_player_destruction"
		"tf_logic_robot_destruction" : "tf_logic_robot_destruction"
		"tf_logic_training_mode" : "tf_logic_training_mode"
		"tf_mann_vs_machine_stats" : "tf_mann_vs_machine_stats"
		"tf_merasmus_trick_or_treat_prop" : "tf_merasmus_trick_or_treat_prop"
		"tf_objective_resource" : "tf_objective_resource"
		"tf_pda_expansion_dispenser" : "tf_pda_expansion_dispenser"
		"tf_pda_expansion_teleporter" : "tf_pda_expansion_teleporter"
		"tf_player_manager" : "tf_player_manager"
		"tf_point_nav_interface" : "tf_point_nav_interface"
		"tf_point_weapon_mimic" : "tf_point_weapon_mimic"
		"tf_powerup_bottle" : "tf_powerup_bottle"
		"tf_projectile_arrow" : "tf_projectile_arrow"
		"tf_projectile_ball_ornament" : "tf_projectile_ball_ornament"
		"tf_projectile_balloffire" : "tf_projectile_balloffire"
		"tf_projectile_cleaver" : "tf_projectile_cleaver"
		"tf_projectile_energy_ball" : "tf_projectile_energy_ball"
		"tf_projectile_energy_ring" : "tf_projectile_energy_ring"
		"tf_projectile_flare" : "tf_projectile_flare"
		"tf_projectile_grapplinghook" : "tf_projectile_grapplinghook"
		"tf_projectile_healing_bolt" : "tf_projectile_healing_bolt"
		"tf_projectile_jar" : "tf_projectile_jar"
		"tf_projectile_jar_gas" : "tf_projectile_jar_gas"
		"tf_projectile_jar_milk" : "tf_projectile_jar_milk"
		"tf_projectile_lightningorb" : "tf_projectile_lightningorb"
		"tf_projectile_mechanicalarmorb" : "tf_projectile_mechanicalarmorb"
		"tf_projectile_pipe" : "tf_projectile_pipe"
		"tf_projectile_pipe_remote" : "tf_projectile_pipe_remote"
		"tf_projectile_rocket" : "tf_projectile_rocket"
		"tf_projectile_sentryrocket" : "tf_projectile_sentryrocket"
		"tf_projectile_spellbats" : "tf_projectile_spellbats"
		"tf_projectile_spellfireball" : "tf_projectile_spellfireball"
		"tf_projectile_spellkartbats" : "tf_projectile_spellkartbats"
		"tf_projectile_spellkartorb" : "tf_projectile_spellkartorb"
		"tf_projectile_spellmeteorshower" : "tf_projectile_spellmeteorshower"
		"tf_projectile_spellmirv" : "tf_projectile_spellmirv"
		"tf_projectile_spellpumpkin" : "tf_projectile_spellpumpkin"
		"tf_projectile_spellspawnboss" : "tf_projectile_spellspawnboss"
		"tf_projectile_spellspawnhorde" : "tf_projectile_spellspawnhorde"
		"tf_projectile_spellspawnzombie" : "tf_projectile_spellspawnzombie"
		"tf_projectile_spelltransposeteleport" : "tf_projectile_spelltransposeteleport"
		"tf_projectile_stun_ball" : "tf_projectile_stun_ball"
		"tf_projectile_syringe" : "tf_projectile_syringe"
		"tf_projectile_throwable" : "tf_projectile_throwable"
		"tf_projectile_throwable_breadmonster" : "tf_projectile_throwable_breadmonster"
		"tf_projectile_throwable_brick" : "tf_projectile_throwable_brick"
		"tf_projectile_throwable_repel" : "tf_projectile_throwable_repel"
		"tf_pumpkin_bomb" : "tf_pumpkin_bomb"
		"tf_ragdoll" : "tf_ragdoll"
		"tf_robot_destruction_robot" : "tf_robot_destruction_robot"
		"tf_robot_destruction_robot_spawn" : "tf_robot_destruction_robot_spawn"
		"tf_robot_destruction_spawn_group" : "tf_robot_destruction_spawn_group"
		"tf_spawner" : "tf_spawner"
		"tf_spell_meteorshowerspawner" : "tf_spell_meteorshowerspawner"
		"tf_spell_pickup" : "tf_spell_pickup"
		"tf_target_dummy" : "tf_target_dummy"
		"tf_taunt_prop" : "tf_taunt_prop"
		"tf_team" : "tf_team"
		"tf_teleport_location" : "tf_teleport_location"
		"tf_viewmodel" : "tf_viewmodel"
		"tf_weapon_base" : "tf_weapon_base"
		"tf_weapon_bat" : "tf_weapon_bat"
		"tf_weapon_bat_fish" : "tf_weapon_bat_fish"
		"tf_weapon_bat_giftwrap" : "tf_weapon_bat_giftwrap"
		"tf_weapon_bat_wood" : "tf_weapon_bat_wood"
		"tf_weapon_bonesaw" : "tf_weapon_bonesaw"
		"tf_weapon_bottle" : "tf_weapon_bottle"
		"tf_weapon_breakable_sign" : "tf_weapon_breakable_sign"
		"tf_weapon_buff_item" : "tf_weapon_buff_item"
		"tf_weapon_builder" : "tf_weapon_builder"
		"tf_weapon_cannon" : "tf_weapon_cannon"
		"tf_weapon_charged_smg" : "tf_weapon_charged_smg"
		"tf_weapon_cleaver" : "tf_weapon_cleaver"
		"tf_weapon_club" : "tf_weapon_club"
		"tf_weapon_compound_bow" : "tf_weapon_compound_bow"
		"tf_weapon_crossbow" : "tf_weapon_crossbow"
		"tf_weapon_drg_pomson" : "tf_weapon_drg_pomson"
		"tf_weapon_fireaxe" : "tf_weapon_fireaxe"
		"tf_weapon_fists" : "tf_weapon_fists"
		"tf_weapon_flamethrower" : "tf_weapon_flamethrower"
		"tf_weapon_flaregun" : "tf_weapon_flaregun"
		"tf_weapon_flaregun_revenge" : "tf_weapon_flaregun_revenge"
		"tf_weapon_grapplinghook" : "tf_weapon_grapplinghook"
		"tf_weapon_grenadelauncher" : "tf_weapon_grenadelauncher"
		"tf_weapon_handgun_scout_primary" : "tf_weapon_handgun_scout_primary"
		"tf_weapon_handgun_scout_secondary" : "tf_weapon_handgun_scout_secondary"
		"tf_weapon_invis" : "tf_weapon_invis"
		"tf_weapon_jar" : "tf_weapon_jar"
		"tf_weapon_jar_gas" : "tf_weapon_jar_gas"
		"tf_weapon_jar_milk" : "tf_weapon_jar_milk"
		"tf_weapon_katana" : "tf_weapon_katana"
		"tf_weapon_knife" : "tf_weapon_knife"
		"tf_weapon_laser_pointer" : "tf_weapon_laser_pointer"
		"tf_weapon_lunchbox" : "tf_weapon_lunchbox"
		"tf_weapon_lunchbox_drink" : "tf_weapon_lunchbox_drink"
		"tf_weapon_mechanical_arm" : "tf_weapon_mechanical_arm"
		"tf_weapon_medigun" : "tf_weapon_medigun"
		"tf_weapon_minigun" : "tf_weapon_minigun"
		"tf_weapon_parachute" : "tf_weapon_parachute"
		"tf_weapon_parachute_primary" : "tf_weapon_parachute_primary"
		"tf_weapon_parachute_secondary" : "tf_weapon_parachute_secondary"
		"tf_weapon_particle_cannon" : "tf_weapon_particle_cannon"
		"tf_weapon_passtime_gun" : "tf_weapon_passtime_gun"
		"tf_weapon_pda_engineer_build" : "tf_weapon_pda_engineer_build"
		"tf_weapon_pda_engineer_destroy" : "tf_weapon_pda_engineer_destroy"
		"tf_weapon_pda_spy" : "tf_weapon_pda_spy"
		"tf_weapon_pep_brawler_blaster" : "tf_weapon_pep_brawler_blaster"
		"tf_weapon_pipebomblauncher" : "tf_weapon_pipebomblauncher"
		"tf_weapon_pistol" : "tf_weapon_pistol"
		"tf_weapon_pistol_scout" : "tf_weapon_pistol_scout"
		"tf_weapon_raygun" : "tf_weapon_raygun"
		"tf_weapon_revolver" : "tf_weapon_revolver"
		"tf_weapon_robot_arm" : "tf_weapon_robot_arm"
		"tf_weapon_rocketlauncher" : "tf_weapon_rocketlauncher"
		"tf_weapon_rocketlauncher_airstrike" : "tf_weapon_rocketlauncher_airstrike"
		"tf_weapon_rocketlauncher_directhit" : "tf_weapon_rocketlauncher_directhit"
		"tf_weapon_rocketlauncher_fireball" : "tf_weapon_rocketlauncher_fireball"
		"tf_weapon_rocketpack" : "tf_weapon_rocketpack"
		"tf_weapon_sapper" : "tf_weapon_sapper"
		"tf_weapon_scattergun" : "tf_weapon_scattergun"
		"tf_weapon_sentry_revenge" : "tf_weapon_sentry_revenge"
		"tf_weapon_shotgun_building_rescue" : "tf_weapon_shotgun_building_rescue"
		"tf_weapon_shotgun_hwg" : "tf_weapon_shotgun_hwg"
		"tf_weapon_shotgun_primary" : "tf_weapon_shotgun_primary"
		"tf_weapon_shotgun_pyro" : "tf_weapon_shotgun_pyro"
		"tf_weapon_shotgun_soldier" : "tf_weapon_shotgun_soldier"
		"tf_weapon_shovel" : "tf_weapon_shovel"
		"tf_weapon_slap" : "tf_weapon_slap"
		"tf_weapon_smg" : "tf_weapon_smg"
		"tf_weapon_sniperrifle" : "tf_weapon_sniperrifle"
		"tf_weapon_sniperrifle_classic" : "tf_weapon_sniperrifle_classic"
		"tf_weapon_sniperrifle_decap" : "tf_weapon_sniperrifle_decap"
		"tf_weapon_soda_popper" : "tf_weapon_soda_popper"
		"tf_weapon_spellbook" : "tf_weapon_spellbook"
		"tf_weapon_stickbomb" : "tf_weapon_stickbomb"
		"tf_weapon_sword" : "tf_weapon_sword"
		"tf_weapon_syringegun_medic" : "tf_weapon_syringegun_medic"
		"tf_weapon_wrench" : "tf_weapon_wrench"
		"tf_weaponbase_grenade_proj" : "tf_weaponbase_grenade_proj"
		"tf_weaponbase_melee" : "tf_weaponbase_melee"
		"tf_weaponbase_merasmus_grenade" : "tf_weaponbase_merasmus_grenade"
		"tf_wearable" : "tf_wearable"
		"tf_wearable_campaign_item" : "tf_wearable_campaign_item"
		"tf_wearable_demoshield" : "tf_wearable_demoshield"
		"tf_wearable_levelable_item" : "tf_wearable_levelable_item"
		"tf_wearable_razorback" : "tf_wearable_razorback"
		"tf_wearable_robot_arm" : "tf_wearable_robot_arm"
		"tf_wearable_vm" : "tf_wearable_vm"
		"tf_zombie" : "tf_zombie"
		"tf_zombie_spawner" : "tf_zombie_spawner"
		"training_annotation" : "training_annotation"
		"training_prop_dynamic" : "training_prop_dynamic"
		"trigger" : "trigger"
		"trigger_add_or_remove_tf_player_attributes" : "trigger_add_or_remove_tf_player_attributes"
		"trigger_add_tf_player_condition" : "trigger_add_tf_player_condition"
		"trigger_apply_impulse" : "trigger_apply_impulse"
		"trigger_autosave" : "trigger_autosave"
		"trigger_bot_tag" : "trigger_bot_tag"
		"trigger_brush" : "trigger_brush"
		"trigger_capture_area" : "trigger_capture_area"
		"trigger_catapult" : "trigger_catapult"
		"trigger_cdaudio" : "trigger_cdaudio"
		"trigger_changelevel" : "trigger_changelevel"
		"trigger_gravity" : "trigger_gravity"
		"trigger_hurt" : "trigger_hurt"
		"trigger_ignite" : "trigger_ignite"
		"trigger_ignite_arrows" : "trigger_ignite_arrows"
		"trigger_impact" : "trigger_impact"
		"trigger_look" : "trigger_look"
		"trigger_multiple" : "trigger_multiple"
		"trigger_once" : "trigger_once"
		"trigger_particle" : "trigger_particle"
		"trigger_passtime_ball" : "trigger_passtime_ball"
		"trigger_player_respawn_override" : "trigger_player_respawn_override"
		"trigger_playermovement" : "trigger_playermovement"
		"trigger_proximity" : "trigger_proximity"
		"trigger_push" : "trigger_push"
		"trigger_rd_vault_trigger" : "trigger_rd_vault_trigger"
		"trigger_remove" : "trigger_remove"
		"trigger_remove_tf_player_condition" : "trigger_remove_tf_player_condition"
		"trigger_serverragdoll" : "trigger_serverragdoll"
		"trigger_soundscape" : "trigger_soundscape"
		"trigger_stun" : "trigger_stun"
		"trigger_teleport" : "trigger_teleport"
		"trigger_teleport_relative" : "trigger_teleport_relative"
		"trigger_timer_door" : "trigger_timer_door"
		"trigger_togglesave" : "trigger_togglesave"
		"trigger_transition" : "trigger_transition"
		"trigger_vphysics_motion" : "trigger_vphysics_motion"
		"trigger_wind" : "trigger_wind"
		"vgui_screen" : "vgui_screen"
		"vgui_screen_team" : "vgui_screen_team"
		"vgui_slideshow_display" : "vgui_slideshow_display"
		"viewmodel" : "viewmodel"
		"vote_controller" : "vote_controller"
		"water_lod_control" : "water_lod_control"
		"waterbullet" : "waterbullet"
		"weapon_ifm_base" : "weapon_ifm_base"
		"weapon_ifm_base_camera" : "weapon_ifm_base_camera"
		"weapon_ifm_steadycam" : "weapon_ifm_steadycam"
		"wearable_item" : "wearable_item"
		"wheel_of_doom" : "wheel_of_doom"
		"wheel_of_doom_spiral" : "wheel_of_doom_spiral"
		"window_pane" : "window_pane"
		"world_items" : "world_items"
		"worldspawn" : "worldspawn"
	] // end entity_name
	entity_count(integer) : "Max Count" : 0 : "Max number of entities to have spawned at one time, if points are available."
	respawn_time(integer) : "Respawn Time" : 0 : "Time to wait before we spawn a new entity when one is destroyed."
	drop_to_ground(choices) : "Drop to Ground?" : 0 : "Should entities spawn on the ground beneath the entity_spawn_point or float at its location?" = [
		0 : "No"
		1 : "Yes"
	] // end drop_to_ground
	random_rotation(choices) : "Random Rotation?" : 0 : "Should entities be rotated to random angles upon spawn?" = [
		0 : "No"
		1 : "Yes"
	] // end random_rotation
] // end entity_spawn_manager

// TODO: HelperModel?
@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-abs/entity_spawn_point") = entity_spawn_point : "A spawn location associated with an entity_spawn_manager." [
	spawn_manager_name(target_destination) : "Spawn Manager Name" :  : "Name of the entity_spawn_manager entity we are associated with."
] // end entity_spawn_point



	// ENV ENTITIES //

@BaseClass = SSprite [
	scale(float) : "Scale" : "0.25" : "Scale multiplier of the sprite."
	GlowProxySize(float) : "Size of Glow Proxy Geometry" : "2.0" : "Size of the glow to be rendered for visibility testing. Must be larger than the distance from the sprite center to empty space. So if this glow is inside geometry (like a light bulb), set this value to be bigger than the bulb's radius. Any time a sphere of this radius would be visible (poking through any nearby geometry), the glow will be rendered."
	frame(integer) : "Starting Frame" : 0 : "If the sprite is animated, the frame it should start animating on."
	framerate(float) : "Framerate" : "10.0" : "Rate at which the sprite should animate, if at all."
	HDRColorScale(float) : "HDR Color Scale" : "1.0" : "Color multiplier for players using HDR."
] // end SSprite

@BaseClass = env_beam_keys_1 [
	LightningStart(target_destination) : "Start Entity" :  : "Entity that the beam starts at. If omitted the entity will instead use a random position on any surface within its Radius value. A new random position will be appointed for every strike."
	LightningEnd(target_destination) : "Ending Entity" :  : "Entity that the beam ends at. If omitted the entity will instead use a random position on any surface within its Radius value. A new random position will be appointed for every strike."
	filtername(filterclass) : "Filter Name" : : "Filter to use to see if activator triggers me."
	TouchType(choices) : "Touch Type (tripwire)" : 0 : "If you want the beam to fire an output when touched by entities, choose the entity type here." = [
		0 : "Not a tripwire"
		1 : "Player Only"
		2 : "NPC Only"
		3 : "Player or NPC"
		4 : "Player or NPC or Physprop"
	] // end TouchType
] // end env_beam_keys_1
@BaseClass = env_beam_keys_2 [
	Radius(integer) : "Radius" : 0 : "If the Start Entity and/or Ending Entity values are omitted, this radius determines the area within which the endpoints will randomly strike. A new random position will be appointed for every strike."
	life(string) : "Lifetime" : 1 : "Amount of time, in seconds, before the beam dies. 0 will make the beam stay forever."
	StrikeTime(string) : "Strike Again Time" : 1 : "Refire time, in seconds, between random strikes of the beam. Only used if the 'Random Strike' spawnflag is set." // TODO: That last part might be wrong?
	damage(string) : "Damage / Second" : 0 : "How much damage this beam does per second to things it hits when it is continually on, or instantaneously if it strikes. For continuous damage, the value should be greater than 10 or it may not work."
	dissolvetype(choices) : "Dissolve Type" : -1 : "If this beam damages and kills something, effects to show around the object. " = [
		-1 : "None"
		0 : "Energy"
		1 : "Heavy electrical"
		2 : "Light electrical"
	] // end dissolvetype
] // end env_beam_keys_2
@BaseClass = env_beam_keys_3 [
	BoltWidth(float) : "Width (1 - 25.5)" : 2 : "Pixel width of the beam."
	NoiseAmplitude(float) : "Noise (0-64)" : 0 : "The amount of noise in the beam. 0 is a perfectly straight beam."
	texture(sprite) : "Sprite Name" : "sprites/laserbeam.spr" : "The material used to draw the beam."
	TextureScroll(integer) : "Texture Scroll Rate (0-100)" : 35 : "Rate at which the beam texture should scroll along the beam."
	framerate(integer) : "Frames per 10 Seconds" : 0 : "Framerate at which the beam texture should animate, if it has multiple frames."
	framestart(integer) : "Starting Frame" : 0 : "The frame to start the beam texture on."
	decalname(string) : "Decal Name" : "Bigshot" : "Decal to be applied at the end of the beam."
	HDRColorScale(float) : "HDR Color Scale" : "1.0" : "Value to multiply beam color by when running in HDR mode."
] // end env_beam_keys_3
@PointClass base(SBaseLogical, SBaseDiv, env_beam_keys_1, SClassDiv1, env_beam_keys_2, SClassDiv2, env_beam_keys_3, SRenderModes) iconsprite("editor-ficool2/env_beam") line(255 255 255, targetname, LightningStart, targetname, LightningEnd) sphere(radius) = env_beam : "An entity that creates a visible beam between two points. The points can be attached to entities to make the beam move around. NOTE: don't parent the env_beam itself, parent its 2 points instead." [
	spawnflags(flags) = [
		1 : "Start On" : 0
		2 : "Toggle - Obsolete, replaced by the Toggle input." : 0
		4 : "Random Strike - When the beam has died, it will strike again randomly within the time set by Strike again time (secs)." : 0
		8 : "Ring - Uses the starting and ending points as a diameter, drawing a beam ring between them instead of a straight line." : 0
		16 : "Start Sparks - Every time the beam strikes or is turned on, the beam emits a small shower of sparks at its Start Entity." : 0
		32 : "End Sparks - Every time the beam strikes or is turned on, the beam emits a small shower of sparks at its Ending Entity." : 0
		128 : "Shade Start - Fades out toward its Start Entity. Overrides Shade End. Does not work on striking beams or beam rings." : 0
		256 : "Shade End - Fades out toward its Ending Entity. Is overridden by Shade Start. Does not work on striking beams or beam rings." : 0
		64 : "Decal End - Places a decal scorch mark where a damaging beam hits the first solid object (world brush or entity)." : 0
		512 : "Taper Out - Taper out into a point towards its Ending Entity. Does not work on striking beams or beam rings." : 0
	] // end spawnflags

	input ColorRedValue(float) : "Sets the red color channel's value (0 - 255)."
	input ColorGreenValue(float) : "Sets the green color channel's value (0 - 255)."
	input ColorBlueValue(float) : "Sets the blue color channel's value (0 - 255)."
	input Noise(float) : "Set how far away from the middle the beam is allowed to deviate. (0 - 64)"
	input ScrollSpeed(float) : "Set the scroll speed in units per second (0 - 100)."
	input Width(float) : "Set the width of the beam, in pixels (1 - 25.5)."

	input StrikeOnce(void) : "Causes the beam to strike once. It will stay on for its set Life and then turn off (it will never turn off if Life is set to zero)."
	input Toggle(void) : "Toggles the beam between on and off."
	input TurnOff(void) : "Turns the beam off."
	input TurnOn(void) : "Turns the beam on."

	output OnTouchedByEntity(void) : "Fired when an entity touches the beam. Only fired if the entity passes the 'Touch Type' choice."
] // end env_beam

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/env_beverage") = env_beverage : "An entity that dispenses soda cans upon activation. Uses models/can.mdl by default, you will need to provide your own with the map/mod as the model is not present." [
	health(integer) : "Capacity" : 10 : "Number of cans in the dispenser."
	beveragetype(choices) : "Skin (beverage type)" : 6 : "Sets the texture of the beverage using skins embedded into the model." = [
		0 : "0"
		1 : "1"
		2 : "2"
		3 : "3"
		4 : "4"
		5 : "5"
		6 : "Random"
	] // end beveragetype

	input Activate(void) : "Enable this dispenser."
] // end env_beverage

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/env_blood") = env_blood : "An entity used to spawn blood effects." [
	spraydir(angle) : "Spray Direction (Pitch Yaw Roll)" : "0 0 0" : "The general direction that the blood should spray and the direction to trace to apply the decal."
	color(choices) : "Blood Color" : 0 = [
		0 : "Red (Human)"
		1 : "Yellow (Alien)"
	] // end color
	amount(string) : "Amount of blood (damage to simulate)" : "100" : "Intensity of the blood spray."

	spawnflags(flags) = [
		1: "Random Direction" : 0
		2: "Blood Stream" : 0
		4: "Spray onto the activating player" : 0
		8: "Spray decals" : 0
		16: "Cloud - emits larger cloud of blood" : 0
		32: "Drops - splashes large blood drops" : 1
		64: "Gore - similar to Cloud but smaller" : 0
	] // end spawnflags

	input EmitBlood(void) : "Triggers the blood effect."
] // end env_blood

@PointClass base(SDoesNotFunction, SBaseLogical) iconsprite("editor/obsolete") = env_credits : "An entity to control the rolling credits. Crashes the game if used." [ // iconsprite("editor-ficool2/env_credits")
	input RollCredits(void) : "Start the intro credits rolling."
	input RollOutroCredits(void) : "Start the outro credits rolling."
	input ShowLogo(void) : "Show the Half Life 2 logo."

	output OnCreditsDone(void)  : "Fired when the credits having finished rolling."
] // end env_credits

@PointClass iconsprite("editor/env_cubemap") sidelist(sides) size(-1 -1 -64, 1 1 -8) = env_cubemap : "An entity that creates a sample point for cubemap reflections." [
	cubemapsize(choices) : "Cubemap Size" : 0 : "The cubemap size to produce. Attempting to use a cubemap size larger than your monitor will cause cubemap creation to fail completely!" = [
		0 : "Default (32x32 in TF2)"
		1 : "1x1"
		2 : "2x2"
		3 : "4x4"
		4 : "8x8"
		5 : "16x16"
		6 : "32x32"
		7 : "64x64 (18 KB)"
		8 : "128x128 (75 KB)"
		9 : "256x256 (300 KB)"
		10 : "512x512 (1200 KB - 1 MB)"
		11 : "1024x1024 (4800 KB - 5 MB!)"
		12 : "2048x2048 (19100 KB - 19 MB!!)"
		13 : "4096x4096 (76500 KB - 75 MB!!!)"
	] // end cubemapsize
	sides(sidelist) : "Brush Faces" :  : "(Optional) Brushes faces to directly attach to the env_cubemap. Press Pick then click on faces in the 3D View to select them. Use CTRL while clicking to add or remove from the selection."
] // end env_cubemap

@PointClass base(SBaseLogical, SBaseDiv) color(50 50 200) iconsprite("editor-ficool2/env_detail_controller") sphere(fademindist) sphere(fademaxdist) = env_detail_controller : "An entity that overrides the fade distances for all details sprites in the map." [
	fademindist(float) : "Start Fade Dist/Pixels" : 512 : "The distance at which the detail props will start fading away."
	fademaxdist(float) : "End Fade Dist/Pixels" : 1024 : "The distance at which the detail props will stop fading and stop drawing entirely."
] // end env_detail_controller

// NOTE FROM FICOOL2: iconsprite removed due to scale keyvalue affecting it and making it massive
// lmao -Brokk
@PointClass base(SBaseEntity, SBaseDiv) = env_dustpuff : "An entity that emits dust puffs." [
	speed(float) : "Speed" : 16 : "Speed at which the dust particles should move."
	color(color255) : "Dust color" : "128 128 128" : "Color of the dust particles."
	scale(float) : "Scale" : "0.25" : "Size of the dust puff."

	input SpawnDust(void) : "Spawn a dust puff."
] // end env_dustpuff

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/env_dusttrail") sphere(spawnradius) = env_dusttrail : "An entity that emits dust 'trails' upon spawning. Lacks enabling/disabling functionality. To make this an actual trail of dust, it must be parented to something." [
	spawnradius(float) : "Spawn Radius" : 2 : "Spawn radius of dust trails."
	spawnrate(float) : "Spawn Rate" : 10 : "Speed at which the dust trails spawn."
	minspeed(float) : "Min Speed" : 2 : "Minimum speed of the dust trails."
	maxspeed(float) : "Max Speed" : 4 : "Maximum speed of the dust trails."
	mindirectedspeed(float) : "Min Directed Speed" : 0 : "Minimum directed speed of the dust trails."
	maxdirectedspeed(float) : "Max Directed Speed" : 0 : "Maximum directed speed of the dust trails."
	lifetime(float) : "Lifetime" : 5 : "The time before the entity restarts, in seconds."
	startsize(float) : "Start Size" : 35 : "Minimum size of the dust trails."
	endsize(float) : "End Size" : 55 : "Maximum size of the dust trails."
	opacity(float) : "Opacity" : 255 : "The opacity of the dust trails."
] // end env_dusttrail

@BaseClass = env_effectscript_keys [
	model(studio) : "Script Model" : "models/effects/teleporttrail.mdl" : "Model to use for animation sequences."
	scriptfile(string) : "Script File" : "scripts/effects/testeffect.txt" : "Name of the script to use for this model."
] // end env_effectscript_keys
@PointClass base(env_effectscript_keys, SClassDiv1, SBaseEntity, SBaseDiv, SModelSkin, SModelBodyGroup, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop() = env_effectscript : "An entity that allows you to script special visual effects via a script file." [ // iconsprite("editor-ficool2/env_effectscript")
	input SetSequence(string) : "Sets the script model's sequence."
] // end env_effectscript

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/env_entity_dissolver") = env_entity_dissolver : "An entity dissolver that removes a point entity from the map after a few built-in effects. Does not work on brush entities." [
	target(target_destination) : "Target to Dissolve" :  : "The entity to dissolve."
	magnitude(integer) : "Magnitude" : 250 : "How strongly to push away from the center."
	dissolvetype(choices) : "Dissolve Type" : 0 : "Particle effects to be generated when something is dissolved." = [
		0 : "Energy"
		1 : "Heavy electrical"
		2 : "Light electrical"
		3 : "Core Effect"
	] // end dissolvetype

	input Dissolve(string) : "Dissolve the specified target. If no target is passed, it will use the target specified in the Target to Dissolve field."
] // end env_entity_dissolver

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/env_entity_igniter") = env_entity_igniter : "An entity that catches a target entity on fire." [
	target(target_destination) : "Entity to Ignite" :  : "Name of the entity to catch on fire."
	lifetime(integer) : "Lifetime" : 10 : "Duration of flames."

	input Ignite(void) : "Ignite the target entity."
] // end env_entity_igniter

@PointClass base(env_entity_igniter) iconsprite("editor-ficool2/entityflame") = entityflame : "Identical to env_entity_igniter.  It catches a target entity on fire. Brush entities are accepted." [
] // end entityflame

@PointClass base(SHelperModel, SBaseEntity, SBaseDiv) iconsprite("editor-abs/env_entity_maker") studio() = env_entity_maker : "Spawns the specified point_template at its origin. If set to auto-spawn, it will spawn the template whenever there is room and all players are looking elsewhere." [
	EntityTemplate(target_destination) : "Template to Spawn" :  : "Name of the point_template to spawn here."
	PostSpawnSpeed(float) : "Post-Spawn Movement Speed" : "0" : "If specified, all the entities created in the template will move this fast in the specified Post-Spawn Movement Direction."
	PostSpawnDirection(angle) : "Post-Spawn Movement Direction" : "0 0 0" : "If a PostSpawn Movement Speed is specified, all the entities created in the template will move in this direction."
	PostSpawnDirectionVariance(float) : "Post-Spawn Direction Variance" : "0.15" : "This variance is applied to the PostSpawn Movement Direction for each spawned entity in the template. Use it to apply some randomness to the directions."
	PostSpawnInheritAngles(choices) : "Post-Spawn Inherit Angles?" : 0 : "If Yes, offset the spawn angles by the angles of a Parent." = [
		0 : "No"
		1 : "Yes"
	] // end PostSpawnInheritAngles

	spawnflags(Flags) = [
		1 : "Enable AutoSpawn (will spawn whenever there's room)" : 0
		2 : "AutoSpawn: Wait for prior instance destruction" : 0
		4 : "AutoSpawn: Even if a player is looking" : 0
		8 : "ForceSpawn: Only if there's room" : 0
	  	16 : "ForceSpawn: Only if no player is looking at me" : 0
	] // end spawnflags

	input ForceSpawn(void) : "Spawn an instance of the template at this maker's origin and angle."
	input ForceSpawnAtEntityOrigin(target_destination) : "Spawn an instance of the template that the same origin and angle as the specified entity."

	output OnEntityFailedSpawn(void) : "Fired when a ForceSpawn input failed to spawn the template, either due to lack of space or being in player's view, depending on the spawnflags. If spawning failed for any other reason (ie the env_entity_maker couldn't find its template), no output is fired."
	output OnEntitySpawned(void) : "Fired when an instance of the entity template has been spawned."
] // end env_entity_maker

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/env_explosion") sphere(iRadiusOverride) = env_explosion : "An entity that creates an explosion at its origin. Will not do damage when parented, use logic_measure_movement as a workaround for parenting." [
	iMagnitude(integer) : "Magnitude" : 100 : "The amount of damage done by the explosion."
	iRadiusOverride(integer) : "Radius Override" :  : "If specified, the radius in which the explosion damages entities. If unspecified, the radius will be based on the magnitude."
	DamageForce(float) : "Damage Force" :  : "Uncertain. Setting to a non-zero number weakens forces on physics objects."
	ignoredEntity(target_destination) : "Ignored Entity" :  : "Do not harm or affect the named entity."
	fireballsprite(sprite) : "Fireball Sprite" : "sprites/zerogxplode.spr" : "Sprite of the fireball."
	rendermode(choices) : "Render Mode" : 5 : "Render mode of the fireball." = [
		0: "Normal"
		1: "Color"
		2: "Texture"
		3: "Glow"
		4: "Solid/Alphatest"
		5: "Additive"
		7: "Additive Fractional Frame"
		8: "Alpha Add"
		9: "World Space Glow"
		10: "Don't Render"
	] // end rendermode

	spawnflags(flags) = [
		1: "No Damage" : 0
		2: "Repeatable" : 1
		4: "No Fireball" : 0
		8: "No Smoke" : 0
		16: "No Decal" : 0
		32: "No Sparks" : 0
		64: "No Sound" : 0
		128: "Random Orientation for Explosion Sprite" : 0
		256: "No Fireball Smoke" : 0
		512: "No particles" : 0
		1024: "No Light" : 0
		2048: "Don't clamp sprite scale to >= 10" : 0
		4096: "Don't clamp sprite scale to <= 50" : 0
		8192: "Don't damage underwater objects" : 0
		16384: "Generic damage" : 0
	] // end spawnflags

	input Explode(void) : "Triggers the explosion."
] // end env_explosion

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/env_fade") = env_fade : "An entity that controls screen fades to or from a solid color. Add In/Out Time and Hold Time together for the total time this entity will be in effect." [
	duration(string) : "Fade In/Out Time (seconds)" : 2 : "The time that it will take to fade the screen in or out."
	holdtime(string) : "Hold Time (seconds)" : 0 : "The time to hold the faded in/out state."
	rendercolor(color255) : "Fade Color (R G B)" : "0 0 0" : "Color of the fade effect."
	renderamt(integer) : "Fade Alpha" : 255 : "Alpha of the fade effect while holding, where 0 = fully transparent and 255 = fully opaque."

	spawnflags(flags) = [
		1 : "Fade From - Screen fades from the specified color instead of to it." : 0
		2 : "Modulate - Uses attenuation blending for fades. Color of 0 255 0 would mute the red+blue channels = create nightvision effect" : 0 // TODO: Describe in more simplistic terms
		4 : "Triggering (!activator) Player Only - Otherwise all players" : 0
		8 : "Stay - Fade remains indefinitely until another fade deactivates it" : 0
	] // end spawnflags

	input Alpha(integer) : "Changes Fade Alpha."
	input Color(color255) : "Changes Fade Color."

	input Fade(void) : "Start the screen fade."

	output OnBeginFade(void) : "Fired when the fade has begun."
] // end env_fade

@PointClass base(SBaseEntity, SBaseDiv, SEnableDisable) iconsprite("editor-ficool2/env_fire") = env_fire : "An entity that handles a single flame at its origin. The flame causes heat 'damage' to other env_fire entities around it, and will eventually ignite non-flaming env_fire entities nearby, causing the fire to spread. Does not create any light. Note: Plasma fire is invisible." [
	health(integer) : "Duration" : 30 : "Amount of time the fire will burn."
	firesize(integer) : "Size" : 64 : "Height (in world units) of the flame."
	fireattack(integer) : "Attack" : 4 : "Amount of time the fire takes to grow to full strength."
	firetype(choices) : "Type" : 0 = [
		0 : "Natural"
		1 : "Plasma (effects do not exist!)"
	] // end firetype
	damagescale(float) : "Damage Scale" : "1.0" : "Multiplier of the burn damage done by the flame."
	ignitionpoint(float) : "Ignition Point" : 32 : "Amount of heat 'damage' to take before this flame should ignite."

	spawnflags(flags) = [
		1 : "Infinite Duration" : 0
		2 : "Smokeless" : 0
		4 : "Start On" : 0
		8 : "Start Full" : 0
		16 : "Don't drop" : 0
		32 : "No glow" : 0
		128 : "Delete when out" : 0
		256 : "Visible from above" : 0
	] // end spawnflags

	input Extinguish(float) : "Puts out the fire permanently in the number of seconds specified."
	input ExtinguishTemporary(float): "Puts out the fire temporarily in the number of seconds specified."
	input StartFire(void) : "Start the fire."

	output OnExtinguished(void) : "Fires when the fire is fully extinguished."
	output OnIgnited(void) : "Fires when the fire is first ignited."
] // end env_fire

@PointClass base(SBaseEntity) iconsprite("editor-ficool2/env_fire_trail") = env_fire_trail : "An entity that creates a small fire trail. Recommended to be parented." [
] // end env_fire_trail

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/env_firesensor") sphere(fireradius) = env_firesensor : "An entity that detects changes in heat nearby." [
	fireradius(float) : "Radius" : 128 : "The radius around this entity in which to detect heat changes."
	heatlevel(float) : "Heat level" : 32 : "The target heat level to check for. Outputs are fired when the heat moves over this target level (increasing or decreasing)."
	heattime(float) : "Time at level" : 0 : "The amount of time the heat level must spend over the target level before the 'OnHeatLevelStart' output is fired."

	spawnflags(flags) = [
		1 : "Start On" : 1
	] // end spawnflags

	input Disable(void) : "Disable the fire sensor."
	input Enable(void) : "Enable the fire sensor."

	output OnHeatLevelEnd(void) : "Fires when the heat level drops below the target level."
	output OnHeatLevelStart(void) : "Fires when the heat level has been sustained for the specified length of time."
] // end env_firesensor

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/env_firesource") sphere(fireradius) = env_firesource : "An entity that provides heat to all nearby env_fire entities. Cannot be extinguished." [
	fireradius(float) : "Radius" : 128 : "The radius around this entity in which to provide heat."
	firedamage(float) : "Intensity / Damage" : 10 : "Amount of heat 'damage' to apply to env_fire entities within the radius."

	spawnflags(flags) = [
		1 : "Start On" : 0
	] // end spawnflags

	input Disable(void) : "Disable fire source."
	input Enable(void) : "Enable fire source."
] // end env_firesource

// Man I wish Valve would fix fog volumes to work in TF2 -Brokk
@PointClass base(SPreservedEntity, SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/env_fog_controller") = env_fog_controller : "An entity that controls the fog and view distance in the map. Fog may be changed per-player using the SetFogController input on them (requires an !activator)." [
	fogenable(choices) : "Fog enabled on start?" : 1 : "Make fog start active." = [
		0 : "No"
		1 : "Yes"
	] // end fogenable
	fogstart(string) : "Fog Start" : "500.0" : "How far away from the viewer the fog should start."
	fogend(string) : "Fog End" : "2000.0" : "How far away from the viewer the fog reaches Fog Max Density."
	fogmaxdensity(float) : "Fog Max Density" : 1 : "Maximum density the fog may reach. Expressed as a decimal percent, so for 45% put 0.45."
	farz(string) : "Far Z Clip Plane (-1 = disable)" : -1 : "Nothing but sky will be rendered beyond this distance from the camera."
	fogcolor(color255) : "Primary Fog Color" : "255 255 255" : "Primary Fog Color."
	fogcolor2(color255) : "Secondary Fog Color" : "255 255 255" : "Secondary Fog Color. If Fog Blend is disabled, this color will never appear."
	fogblend(choices) : "Fog Blend?" : 0 : "Enables color blending between Primary Fog Color and Secondary Fog Color. When the viewer looks in the Primary Fog Direction, fog will appear as the Primary color. When looking away from the specified direction, fog appears as the Secondary color. If the camera is not pointed directly at or away from the direction, a blend of the two colors will result. Sunlight with a Yaw of 45 degrees and a Pitch of -45 degrees could be enhanced using a Primary Fog Direction of '-1 -1 1', a Primary Fog Color of '120 110 100' and a Secondary Fog Color of '80 70 60'." = [
		0 : "No"
		1 : "Yes"
	] // end fogblend
	fogdir(string) : "Primary Fog Direction" : "1 0 0" : "A vector (given by three space-separated numbers X Y Z) which the viewer camera is checked against to figure out the blend between the primary and secondary fog colors."
	use_angles(choices) : "Use Angles for Fog Direction?" : 0 : "Use Pitch Yaw Roll for the Fog Blend direction instead of Primary Fog Direction. There isn't much use for this unless you want the direction to rotate." = [
		0 : "No"
		1 : "Yes"
	] // end use_angles
	foglerptime(float) : "Interpolate Time" : "0.0" : "Fade time for the StartFogTransition input, in seconds."

	spawnflags(flags) = [
		1 : "Master - If multiple env_fog_controllers are active, this one will always take priority." : 0
	] // end spawnflags

	input StartFogTransition(void) : "When fired, the fog fades to any new values sent through the 'LerpTo' inputs. Fade time is determined by the Interpolate time keyvalue."
	input TurnOff(void) : "Turn the fog off."
	input TurnOn(void) : "Turn the fog on."

	input SetAngles(string) : "Sets the angles to use for the Primary Fog Direction."
	input SetColor(color255) : "Sets the Primary Fog Color."
	input SetColorLerpTo(color255) : "Stores a value for Primary Fog Color that is set once the StartFogTransition input fires."
	input SetColorSecondary(color255) : "Sets the Secondary Fog Color."
	input SetColorSecondaryLerpTo(color255) : "Stores a value for Secondary Fog Color that is set once the StartFogTransition input fires."
	input SetFarZ(integer): "Sets the Far Z Clip Plane distance."
	input SetEndDist(float) : "Set the Fog End distance."
	input SetEndDistLerpTo(float) : "Stores a value for Fog End that is set once the StartFogTransition input fires."
	input SetStartDist(float) : "Set the Fog Start distance."
	input SetStartDistLerpTo(float) : "Stores a value for Fog Start that is set once the StartFogTransition input fires."
] // end env_fog_controller

@PointClass base(SBaseEntity) iconsprite("editor-ficool2/env_funnel") = env_funnel : "Half-Life legacy entity: Creates many sprites which move toward a point (or from a point). The sprite is hardcoded to be sprites/flare6.vmt, but this texture is missing by default. This entity must be activated with the Use input. After it has been Used, it is deleted from the map." [
	spawnflags(flags) = [
		1 : "Reverse - Funnel repels sprites instead of attracting them." : 0
	] // end spawnflags

	input Use(void) : "Triggers the effect."
] // end env_funnel

@PointClass base(SBaseLogical, SBaseDiv, SGlobalStates) color(100 255 100) iconsprite("editor-ficool2/env_global") = env_global : "An entity to control global states. The value of global states persists across rounds and even changelevels. This entity can create and control custom globals, not just listed ones.\n" +
	"BUG: The counter keyvalue and output do not work, due to sharing the same name." [
	initialstate(choices) : "Initial State" : 0 : "What the initial state of this global should be, if the 'Set Initial State' keyvalue is defined." = [
		0 : "Off"
		1 : "On"
		2 : "Dead"
	] // end initialstate
	//counter(integer) : "Counter" : 0 : "An integer counter value associated with this global. Does not function due to sharing a name with an output, resulting in neither working."

	spawnflags(flags) = [
		1 : "Set Initial State - Whether this entity defines the global state when the map starts." : 0
	] // end spawnflags

	input AddToCounter(integer) : "Adds to the counter value of this global. Negative numbers subtract."
	input GetCounter(void) : "Fires this entity's Counter output."
	input SetCounter(integer) : "Sets the counter value of this global."
	input Remove(void) : "Set state of global to DEAD."
	input Toggle(void) : "Toggles state of global between ON and OFF."
	input TurnOff(void) : "Set state of global to OFF."
	input TurnOn(void) : "Set state of global to ON."

	//output Counter(integer) : "Outputs the integer value of this entity. May depend on global state. Does not function due to sharing a name with an output, resulting in neither working."
] // end env_global

@PointClass base(SBaseEntity, SBaseDiv, SEnableDisable) iconsprite("editor-ficool2/env_gunfire") line(255 255 255, targetname, target) = env_gunfire : "This entity creates a gunfire effect which can be dynamically controlled and pointed at a target, to give the illusion of a weapon firing without an actual weapon entity being used. The visual effect will be identical to an actual weapon firing, but causes no damage." [
	target(target_destination) : "Target" :  : "The target to shoot at."
	rateoffire(float) : "Rate of Fire" : 10 : "Expressed as rounds per second."
	spread(choices) : "Bullet Spread" : 5 : "The 'cone of inaccuracy' of the shots fired by this entity." = [
		0 : "Perfect accuracy"
		1 : "1 Degree"
		5 : "5 Degrees"
		10 : "10 Degrees"
		15 : "15 Degrees"
	] // end spread
	bias(choices) : "Bullet distribution should be..." : 1 : "How to distribute bullets within the spread. Even distribution is a true scatter throughout the spread. Biased towards the outside makes the shots 'miss' the target by tending towards the outside of the spread." = [
		1 : "Evenly distributed"
		-1 : "Biased towards the outside"
	] // end bias
	collisions(choices) : "Collision detection" : 0 : "Whether/how to handle bullet collision detection. NOTE: If you select NONE, this entity will be very cheap to use, but all bullets will stop short at their target's position in space and there will be no impact effects. Normal collision detection does the same things NPCs do when they fire their guns (except harm anything)." = [
		0 : "None. Cheap for performance."
		1 : "Normal collision detection."
	] // end collisions
	minburstsize(integer) : "Min Burst Size" : 2 : "Minimum number of rounds in a burst."
	maxburstsize(integer) : "Max Burst Size" : 7 : "Maximum number of rounds in a burst."
	minburstdelay(float) : "Min Delay between Bursts" : 2 : "Minimum delay between bursts, in seconds."
	maxburstdelay(float) : "Max Delay between Bursts" : 5 : "Maximum delay between bursts, in seconds."
	shootsound(sound) : "Shoot Sound" :  : "Sound to make when firing. Must be a soundscript and not a raw filename. A list of suitable gunfire sounds is usually found in scripts/game_sounds_weapons.txt"
	tracertype(string) : "Tracer" :  : "Type of tracer to display."
] // end env_gunfire

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/env_hudhint") = env_hudhint : "An entity to control the display of HUD hints. HUD hints are used to show the player what key is bound to a particular command." [
	message(string) : "Hint Text" :  : "This should be set to match the desired HUD hint entry in the resource\<game>_english.txt. Unlocalized (raw) text can still be used if needed."

	spawnflags(flags) = [
		1 : "All Players - otherwise only activating player" : 0
	] // end spawnflags

	input HideHudHint(void) : "Hides the hint message."
	input ShowHudHint(void) : "Shows the hint message."
] // end env_hudhint

// In Ficool's FGD, he inherited from env_beam but noted that not all the inherited keyvalues/inputs/outputs were used (why the feck would you do that!?). I removed that inheritance and duplicated any missing keyvalues from Valve's FGD. Something might still be missing.
@BaseClass = env_laser_keys [
	LaserTarget(target_destination) : "Target of Laser" :  : "Name of entity, or entities, to strike at. The target is randomly chosen if there are multiple entities matching the given name."
	width(float) : "Width of laser" : 2 : "The width of the laser, in pixels."
	NoiseAmplitude(integer) : "Amount of Noise (0-255)" : 0 : "The amount of noise in the beam. 0 is a perfectly straight beam."
	texture(sprite) : "Sprite Name" : "sprites/laserbeam.spr" : "The material used to draw the laser beam."
	framestart(integer) : "Starting Frame" : 0 : "The frame to start the laser texture on."
	TextureScroll(integer) : "Texture Scroll Rate (0-100)" : 35 : "Rate at which the beam texture should scroll along the beam."
	renderamt(integer) : "Brightness (1 - 255)" : 100 : ""
	rendercolor(color255) : "Beam Color (R G B)" : "255 255 255" : ""
	HDRColorScale(float) : "HDR color scale." : "1.0" : "Value to multiply laser color by when running in HDR mode."
	EndSprite(sprite) : "End Sprite" :  : "If specified, this sprite will be drawn at the end of the laser."
	damage(string) : "Damage / Second" : "0" : "How much damage this laser does, per second, to entities it hits."
	dissolvetype(choices) : "Dissolve Type" : "-1" : "If this laser damages and kills something, effects to show around the object. " = [
		-1 : "None"
		0 : "Energy"
		1 : "Heavy electrical"
		2 : "Light electrical"
	] // end dissolvetype
] // end env_laser_keys
@PointClass base(SBaseEntity, SBaseDiv, env_laser_keys, SRenderModes) iconsprite("editor-ficool2/env_laser") line(255 255 255, targetname, LaserTarget) = env_laser : "An entity that creates a laser beam between itself and a given target. The main difference between this entity and env_beam is that a laser will not travel through anything solid." [
	spawnflags(flags) = [
		1 : "Start On" : 0
		2 : "Toggle - Obsolete, replaced by the Toggle input." : 0
		4 : "Random Strike - When the beam has died, it will strike again randomly within the time set by Strike again time (secs)." : 0
		8 : "Ring - Uses the starting and ending points as a diameter, drawing a beam ring between them instead of a straight line." : 0
		16 : "Start Sparks - Every time the beam strikes or is turned on, the beam emits a small shower of sparks at its Start Entity." : 0
		32 : "End Sparks - Every time the beam strikes or is turned on, the beam emits a small shower of sparks at its Ending Entity." : 0
		128 : "Shade Start - Fades out toward its Start Entity. Overrides Shade End. Does not work on striking beams or beam rings." : 0
		256 : "Shade End - Fades out toward its Ending Entity. Is overridden by Shade Start. Does not work on striking beams or beam rings." : 0
		64 : "Decal End - Places a decal scorch mark where a damaging beam hits the first solid object (world brush or entity)." : 0
		512 : "Taper Out - Taper out into a point towards its Ending Entity. Does not work on striking beams or beam rings." : 0
	] // end spawnflags

	input Toggle(void) : "Toggles the laser between on and off."
	input TurnOff(void) : "Turns the laser off."
	input TurnOn(void) : "Turns the laser on."

	input ColorBlueValue(float) : "Sets the blue color channel's value (0 - 255)."
	input ColorGreenValue(float) : "Sets the green color channel's value (0 - 255)."
	input ColorRedValue(float) : "Sets the red color channel's value (0 - 255)."
	input Noise(float) : "Set how far away from the middle the laser is allowed to deviate (0 - 64)."
	input ScrollSpeed(float) : "Set the scroll speed in units per second (0 - 100)."
	input Width(float) : "Set the width of the laser, in pixels (1 - 25.5)."
] // end env_laser

@PointClass base(SBaseEntity, SBaseDiv) size(-2 -2 -2, 2 2 2) sphere(MinDist) sphere(MaxDist) sphere(OuterMaxDist) sphere(GlowProxySize) sprite("sprites/light_glow01") = env_lightglow : "An entity that puts an additive glow in the world, mostly used over light sources." [
	rendercolor(color255) : "Color (R G B)" : "255 255 255" : "Glow color."
	VerticalGlowSize(integer) : "Vertical Size" : 30 : "Vertical glow size in units."
	HorizontalGlowSize(integer) : "Horizontal Size" : 30 : "Horizontal glow size in units."
	MinDist(integer) : "Close Fade Distance" : 512 : "The distance at which this effect will be fully translucent."
	MaxDist(integer) : "Fully Visible Distance" : 1024 : "The distance at which this effect will be at full intensity."
	OuterMaxDist(integer) : "Far Fade Distance" : 0 : "If larger than the maximum distance, this is the length at which the glow will fade completely out, between the span of the Fully Visible Distance and this length."
	GlowProxySize(float) : "Glow Proxy Geometry Size" : "2.0" : "Size of the glow to be rendered for visibility testing. Must be larger than the distance from the sprite center to empty space. So if this glow is inside geometry (like a light bulb), set this value to be bigger than the bulb's radius. Any time a sphere of this radius would be visible (poking through any nearby geometry), the glow will be rendered."
	HDRColorScale(float) : "HDR color scale." : "1.0" : "Color multiplier for players using HDR."

	spawnflags(flags) = [
		1: "Visible only from front" : 0
	] // end spawnflags

	input Color(color255) : "Change the color of the glow. A value of 0 0 0 will hide the sprite."
] // end env_lightglow

@PointClass base(SBaseEntity, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/env_message") = env_message : "An entity that draws a text message on player's HUDs. Messages and most settings must be predefined in /scripts/titles.txt; raw text cannot be entered. game_text is a much more flexible alternative; use that instead." [
	message(choices) : "Message Text" :  : "Message to be shown, defined in /scripts/titles.txt. Raw text cannot be used. The position and colors of each string is also predefined. The localized strings do not exist in TF2, resulting in the entity displaying the raw nonlocalized version." = [
		"CR1" : "'Testing 1' (bottom left)"
		"CR2" : "'Testing 2' (bottom left)"
		"CR3" : "'Testing 3' (bottom left)"
		"GAMETITLE" : "'Half-Life' (crosshair)"
		"GAMEOVER_ALLY" : "'#HL2_GameOver_Ally' (crosshair)"
		"GAMEOVER_OBJECT" : "'#HL2_GameOver_Object' (crosshair)"
		"GAMEOVER_TIMER" : "'#HL2_GameOver_Timer' (crosshair)"
		"GAMEOVER_STUCK" : "'#HL2_GameOver_Stuck' (crosshair)"
		"CHAPTER1_TITLE" : "'#HL2_Chapter1_Title' (below crosshair)"
		"CHAPTER2_TITLE" : "'#HL2_Chapter2_Title' (below crosshair)"
		"CHAPTER3_TITLE" : "'#HL2_Chapter3_Title' (below crosshair)"
		"CHAPTER4_TITLE" : "'#HL2_Chapter4_Title' (below crosshair)"
		"CHAPTER5_TITLE" : "'#HL2_Chapter5_Title' (below crosshair)"
		"CHAPTER6_TITLE" : "'#HL2_Chapter6_Title' (below crosshair)"
		"CHAPTER7_TITLE" : "'#HL2_Chapter7_Title' (below crosshair)"
		"CHAPTER8_TITLE" : "'#HL2_Chapter8_Title' (below crosshair)"
		"CHAPTER9_TITLE" : "'#HL2_Chapter9_Title' (below crosshair)"
		"CHAPTER9A_TITLE" : "'#HL2_Chapter9a_Title' (below crosshair)"
		"CHAPTER10_TITLE" : "'#HL2_Chapter10_Title' (below crosshair)"
		"CHAPTER11_TITLE" : "'#HL2_Chapter11_Title' (below crosshair)"
		"CHAPTER12_TITLE" : "'#HL2_Chapter12_Title' (below crosshair)"
		"CHAPTER13_TITLE" : "'#HL2_Chapter13_Title' (below crosshair)"
		"GAMESAVED_360" : "'#HL2_Saved' (top left)"
		"GAMESAVED" : "'#HL2_Saved' (below crosshair)"
	] // end message
	messagesound(sound) : "Sound Effect" :  : "When the message is shown, this sound effect will be played, originating from this entity."
	messagevolume(string) : "Volume (0-10)" : "10" : "Volume of the sound effect."
	messageattenuation(Choices) : "Sound Radius" : 0 = [
		0 : "Small Radius"
		1 : "Medium Radius"
		2 : "Large  Radius"
		3 : "Play Everywhere"
	] // end messageattenuation

	spawnflags(flags) = [
		1: "Play Once - Remove self on display" : 0
		2: "All Clients - Otherwise display to activating player only" : 0
	] // end spawnflags

	input ShowMessage(void) : "Shows the message and plays the sound."

	output OnShowMessage(void) : "Fired when the message is activated."
] // end env_message

@PointClass base(SBaseEntity, SBaseDiv, SEnableDisable) iconsprite("editor/env_microphone") line(255 255 255, targetname, target) line(255 255 255, targetname, SpeakerName) sphere(MaxRange) = env_microphone : "An entity that acts as a microphone. It works in one of two modes. If it has a 'Speaker' set, it picks up all sounds within the specified sound range, and rebroadcasts them through the Speaker entity. In this Speaker mode, it ignores the Hears X spawnflags and does not fire the SoundLevel output. If it has no Speaker set, it measures the sound level at a point, and outputs the sound level as a value between 0 and 1. In Measuring mode, it only hears sounds that match the Hear X spawnflags." [
	target(target_destination) : "Measure Target" :  : "If the speaker is in Measuring mode, this is the name of the entity where the sound level is to be measured."
	SpeakerName(target_destination) : "Speaker Target" :  : "The name of an (info_target?) entity through which to play any sounds heard by this microphone. Can be another env_microphone. If specified, the microphone will consider itself in Speaker mode."
	ListenFilter(filterclass) : "Listen Filter" :  : "The name of an filter entity which specifies the only entities the microphone can hear. Sounds emitted by other entities will not be heard."
	speaker_dsp_preset(choices) : "Speaker DSP Preset" : 0 : "Only useful in Speaker mode. If specified, when the microphone is enabled, it'll set the global dsp_speaker preset to this value. Sounds played back through speakers will then be affected by the selected DSP. Only one env_microphone can have a DSP Preset active." = [
 		0 : "Use environment default"
		50 : "No effect"
		55 : "Loud speaker"
		56 : "Very small speaker"
		57 : "Echoing speaker"
		58 : "Small speaker"
		59 : "Tiny speaker"
	] // end speaker_dsp_preset
	Sensitivity(float) : "Sensitivity (0 - 10)" : 1 : "Microphone sensitivity, 0=deaf, 1=default, 10=extremely sensitive). Only applicable in Measuring mode."
	SmoothFactor(float) : "Smoothing (0 - 1)" : 0 : "Smoothing factor, 0=no smoothing, 1=maximum smoothing). Only applicable in Measuring mode."
	MaxRange(float) : "Maximum Hearing Range (0=infinite)" : 240 : "Sounds beyond this range won't be heard, irrelevant of attenuation. "+
		"WARNING: Setting this to zero (or a value > 1024) when the microphone is in Speaker mode can be very bad for performance!"
	SoundMask(integer) : "Sound Mask" : 0 : "Unknown function. Possible alternative to the Hears X spawnflags."

	spawnflags(flags) = [
		1 : "Hears combat sounds" : 1
		2 : "Hears world sounds" : 1
		4 : "Hears player sounds" : 1
		8 : "Hears bullet impacts" : 1
		16 : "Swallows sounds routed through speakers - Does not listen to sounds coming though from any other microphone including itself" : 0
		32 : "Hears explosions" : 0
		64 : "Ignores non-attenuated sounds" : 0
	] // end spawnflags

	input SetSpeakerName(target_destination) : "Set the microphone to output through a different speaker entity."

	output SoundLevel(float) : "Fired in Measuring mode whenever the sound level changes."
	output OnRoutedSound(void) : "Fired whenever a sound is routed out through the specified speaker (if any)."
	output OnHeardSound(void) : "Fired whenever this microphone hears any sound it cares about."
] // end env_microphone

@PointClass base(SBaseEntity) iconsprite("editor-ficool2/env_movieexplosion") = env_movieexplosion : "An entity that creates a small cartoonic bubbles explosion lasting for 5 seconds." [
] // end env_movieexplosion

// scallllle
@PointClass base(SBaseEntity, SBaseDiv) = env_muzzleflash : "An entity that creates the effect of flames leaving a guns barrel when firing." [ // iconsprite("editor-ficool2/env_muzzleflash")
	parentattachment(string) : "Parent Attachment" :  : "The name of an attachment on the parent to hierarchically attach to."
	scale(float) : "Scale" : "1" : "Size of the muzzle flash."

	input Fire(void) : "Fires the effect once."
] // end env_muzzleflash

@PointClass base(SBaseLogical) color(100 150 255) iconsprite("editor-ficool2/env_particle_performance_monitor") = env_particle_performance_monitor : "An entity for turning on and off measuring and display of particle throughput." [
	input TurnOnDisplay(void) : "Turn on display of particle simulation benchmark."
	input TurnOffDisplay(void) : "Turn off display of particle simulation benchmark."
	input StartMeasuring(void) : "Start measuring particle simulation speed."
	input StopMeasuring(void) : "Stop measuring particle simulation speed."
] // end env_particle_performance_monitor

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/env_particle_trail") = env_particle_trail : "An entity which emits a particle trail. Becomes visible when parented to an object, and then emits particle trails from the entity's bounding box." [
	ParticleTrailMaterial(material) : "Particle Trail Material" :  : "Name of a material to use for the particle trail."
	ParticleTrailLifetime(float) : "Particle Trail Lifetime" : 4 : "Lifetime of the particles to emit."
	ParticleTrailStartSize(float) : "Particle Trail Starting Sprite Size" : 2 : "Starting size of the particles to emit."
	ParticleTrailEndSize(float) : "Particle Trail Ending Sprite Size" : 3 : "Ending size of the particles to emit."
] // end env_particle_trail

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/env_particlelight") = env_particlelight : "An entity that can be used to light the particles emitted by env_smokestack entities. Does not light any other particle types." [
	Color(color255) : "Color" : "255 0 0" : "Color emitted by this light."
	Intensity(integer) : "Intensity" : 5000 : "How strong the light is."
	directional(choices) : "Directional?" : 0 : "If this is specified, then this light will use the bump map on the particles. Each particle system can have one ambient and one directional light." = [
		0 : "No"
		1 : "Yes"
	] // end directional
	PSName(string) : "Particle System Entity" :  : "Set this to the name of the env_smokestack that you want this light to affect."
] // end env_particlelight

@PointClass base(SModel, SBaseEntity, SModelSkin, SModelBodyGroup, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop() = env_particlescript : "An entity that has special animation events that can be fired by a model with an animation inside its .QC designed for use by this entity." [
	model(studio) : "Script Model" : "models/ambient_citadel_paths.mdl" : "Model to use for animation sequences."

	input SetSequence(string) : "Sets the script model's sequence."
] // end env_particlescript

@PointClass base(SBaseEntity) iconsprite("editor-ficool2/env_particlesmokegrenade") = env_particlesmokegrenade : "An entity that continuously emits a tiny puff of smoke while it exists." [
] // end env_particlesmokegrenade

// TODO: Test
@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/env_physexplosion") sphere(radius) sphere(inner_radius) = env_physexplosion : "An entity that creates an explosion at its origin. If the no-damage spawnflag is set, the explosion won't be visible, but will apply force to any physics objects within its radius." [
	magnitude(string) : "Magnitude (0 - 100)" : "100" : "Amount of physics force applied by the explosion."
	radius(string) : "Clamp Radius (0 = auto)" : "0" : "If specified, the radius in which the explosion damages entities. If unspecified, the radius will be based on the magnitude."
	inner_radius(float) : "Inner radius" : "0" : "If not zero, the LOS is calculated from a point intersecting this sphere."
	targetentityname(target_destination) : "Limit to Entity" :  : "If specified, the explosion will only affect the matching entity."

	spawnflags(flags) = [
		1 : "No Damage - Only Force" : 1
		2 : "Push players" : 0
		4 : "Push radially - not as a sphere (Radially meaning as a circle/cylinder. No upward or downward force will be generated.)" : 0 // TODO: The fuck does this mean
		8 : "Test LOS before pushing" : 0
		16 : "Disorient player if pushed" : 0
	] // end spawnflags

	input Explode(void) : "Trigger the explosion."

	output OnPushedPlayer(void) : "Fires when the player is pushed by the explosion."
] // end env_physexplosion

// TODO: Does this entity work in TF2?
@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/env_player_surface_trigger") = env_player_surface_trigger : "An entity that monitors the material of the surface the player is standing on, and fires outputs whenever it changes to/from a specific material." [
	gamematerial(choices) : "Game Material to Watch" : 0 : "The material to watch. When the player stands on/off this material, this entity's outputs will be fired." = [
		0 : "None (player's in the air)"
		67 : "Concrete"
		68 : "Dirt"
		70 : "Flesh"
		71 : "Grate"
		73 : "Clip"
		77 : "Metal"
		78 : "Sand"
		79 : "Foliage"
		80 : "Computer"
		83 : "Slosh"
		84 : "Tile"
		86 : "Vent"
		87 : "Wood"
		89 : "Glass"
	] // end gamematerial

	input Disable(void) : "Stop watching the player's surface."
	input Enable(void) : "Start watching the player's surface."

	output OnSurfaceChangedToTarget(void) : "Fired when the player moves onto the specified game material."
	output OnSurfaceChangedFromTarget(void) : "Fired when the player moves off the specified game material."
] // end env_player_surface_trigger

// TODO: Test
// Kinda works in TF2, but only one at a time, and only with some client-side commands enabled. Only used for the player flashlight in HL2. -Brokk
@PointClass base(SBaseEntity, SBaseDiv) color(255 255 255) frustum(lightfov, nearz, farz, lightcolor, -1) lightprop("models/editor/spot.mdl") sphere(nearz) sphere(farz) = env_projectedtexture : "It projects a texture as a dynamic light that affects all objects in the world, optionally with shadow mapping. Only 1 instance of this entity can be enabled at a time. Disabled in Team Fortress 2 by default, requires mp_flashlight 1 to be enabled to function. light_dynamic may be a viable alternative." [ // TODO: Only one in the entire map or only one in the PVS?
	target(target_destination) : "Entity to Point At" :  : "The entity will rotate to point at its target, no matter where it is in the world."
	texturename(string) : "Texture Name" :  : "The texture which this entity projects. Must be a VTF file (not VMT), relative to /materials." // TODO: src-ents indicates this IS a material?
	textureframe(integer) : "Texture Frame" : 0 : "If the texture is animated, this is the frame it should begin on."
	lightfov(float) : "FOV" : "90.0" : "The field of view angle at which the texture is projected. The projection is created in a square shape."
	nearz(float) : "NearZ" : "4.0" : "Objects closer than this will not receive the projection."
	farz(float) : "FarZ" : "768.0" : "Objects beyond this distance will not receive the projection."
	enableshadows(Choices) : "Enable Shadows?" : 0 : "Enables/disables shadows from this projected texture." = [
		0 : "No"
		1 : "Yes"
	] // end enableshadows
	shadowquality(Choices) : "Shadow Quality" : 1 : "Quality of shadows." = [
		0 : "Low"
		1 : "High"
	] // end shadowquality
	lightonlytarget(Choices) : "Light Only Target?" : 0 : "Limit flashlight effect to only effect target entity. The world will still be lit." = [
		0 : "No"
		1 : "Yes"
	] // end lightonlytarget
	lightworld(Choices) : "Light World?" : 1 : "Control whether flashlight effects static world geometry." = [
		0 : "No"
		1 : "Yes"
	] // end lightworld
	lightcolor(color255) : "Light Color" : "255 255 255 200" : "Light Color RGB-Intensity."
	cameraspace(integer) : "Camera Space" : 0 : "Display relative to player's view. Breaks things horribly unless the entity moves with the player." // TODO: Should be a boolean? Also is this actually broken?

	spawnflags(flags) = [
		1 : "Enabled" : 1
	] // end spawnflags

	input Ambient(bool) : "Allows for an ambiance light, much like the shadow color for it."
	input CameraSpace(bool) : "Enable/Disable the 'Camera Space' keyvalue."
	input EnableShadows(bool) : "Enables/disables shadows from this projected texture."
	input LightOnlyTarget(bool) : "Enable/Disable the 'Light Only Target' keyvalue."
	input LightWorld(bool) : "Enable/Disable the 'Light World' keyvalue."
	input SetFOV(float) : "Set the projected texture's FOV." // TODO: src-ents indicates a different input name?
	input SpotlightTexture(string) : "Set the spotlight texture. Must be a VTF file (not VMT), relative to /materials." // TODO: material?
	input Target(target_destination) : "Specify a new target entity to point at."

	input TurnOff(void) : "Turn off the texture"
	input TurnOn(void) : "Turn on the texture."
] // end env_projecteddtexture

@PointClass base(SBaseEntity) iconsprite("editor-ficool2/env_rockettrail") = env_rockettrail : "An entity that emits a rocket trail." [
] // end env_rockettrail

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/env_screenoverlay") = env_screenoverlay : "An entity that can display and control a set of screen overlays, to be displayed over the player's view. Useful for view effects like drunkenness, or teleporter afterimages, etc." [
	OverlayName1(material) : "Overlay Name 1" :  : "Name of the first overlay material to display."
	OverlayTime1(float) : "Overlay Duration 1" : "1.0" : "Amount of time that the first overlay should be displayed for, after which it will begin showing the second overlay. Use -1 for a permanent display."
	OverlayName2(material) : "Overlay Name 2" :  : "Name of the second overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime2(float) : "Overlay Duration 2" : "1.0" : "Amount of time that the second overlay should be displayed for, after which it will begin showing the third overlay. Use -1 for a permanent display."
	OverlayName3(material) : "Overlay Name 3" :  : "Name of the third overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime3(float) : "Overlay Duration 3" : "1.0" : "Amount of time that the third overlay should be displayed for, after which it will begin showing the fourth overlay. Use -1 for a permanent display."
	OverlayName4(material) : "Overlay Name 4" :  : "Name of the fourth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime4(float) : "Overlay Duration 4" : "1.0" : "Amount of time that the fourth overlay should be displayed for, after which it will begin showing the fifth overlay. Use -1 for a permanent display."
	OverlayName5(material) : "Overlay Name 5" :  : "Name of the fifth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime5(float) : "Overlay Duration 5" : "1.0" : "Amount of time that the fifth overlay should be displayed for, after which it will begin showing the sixth overlay. Use -1 for a permanent display."
	OverlayName6(material) : "Overlay Name 6" :  : "Name of the sixth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime6(float) : "Overlay Duration 6" : "1.0" : "Amount of time that the sixth overlay should be displayed for, after which it will begin showing the seventh overlay. Use -1 for a permanent display."
	OverlayName7(material) : "Overlay Name 7" :  : "Name of the seventh overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime7(float) : "Overlay Duration 7" : "1.0" : "Amount of time that the seventh overlay should be displayed for, after which it will begin showing the eighth overlay. Use -1 for a permanent display."
	OverlayName8(material) : "Overlay Name 8" :  : "Name of the eighth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime8(float) : "Overlay Duration 8" : "1.0" : "Amount of time that the eighth overlay should be displayed for, after which it will begin showing the ninth overlay. Use -1 for a permanent display."
	OverlayName9(material) : "Overlay Name 9" :  : "Name of the ninth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime9(float) : "Overlay Duration 9" : "1.0" : "Amount of time that the ninth overlay should be displayed for, after which it will begin showing the tenth overlay. Use -1 for a permanent display."
	OverlayName10(material) : "Overlay Name 10" :  : "Name of the tenth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime10(float) : "Overlay Duration 10" : "1.0" : "Amount of time that the tenth overlay should be displayed for, after which this entity will stop displaying overlays. Use -1 for a permanent display."

	spawnflags(flags) = [
		1: "Allow Suit Zoom" : 0
	] // end spawnflags

	input	StartOverlays(void) : "Start displaying the first overlay."
	input	StopOverlays(void) : "Stop displaying any overlays."
	input	SwitchOverlay(float) : "Switch to displaying a specific overlay. Pass in the desired overlay number in the parameter. Entering -1 as the value will cause the overlay to display indefinitely." // TODO: Huh?
] // end env_screenoverlay

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/env_shake") sphere(radius) = env_shake : "An entity which can be used to control screen shake on players or shake certain objects." [
	amplitude(float) : "Amplitude (0-16)" : "4" : "The amount of noise in the screen shake. Should be a range between 0 and 16."
	frequency(float) : "Frequency" : "2.5" : "The frequency used to apply the screen shake. Should be a value between 0 and 255, where 0.1 = jerk, and 255.0 = rumble."
	duration(float) : "Duration (seconds)" : "1" : "The length of time in which to shake the player's screens."
	radius(float) : "Effect Radius" : "500" : "The radius around this entity in which to affect players."

	spawnflags(flags) = [
		1: "Shake globally" : 1
		2: "Disrupt player control" : 0
		4: "Shake players in air" : 1
		8: "Shake physic objects" : 1
		16: "Shake ropes" : 1
		32: "DON'T shake players" : 0
		64: "DON'T rumble controller" : 0
	] // end spawnflags

	input Amplitude(string) : "Set the amplitude (0-16)"
	input Frequency(string) : "Set the frequence. Should be a value between 0 and 255, where 0.1 = jerk, and 255.0 = rumble."
	input StartShake(void) : "Start the shake."
	input StopShake(void) : "Stop the shake."
] // end env_shake

@BaseClass = env_shooter_keys [
	shootmodel(studio) : "Model" :  : "Thing to shoot out. Can be a .mdl or a .vmt."
	skin(integer) : "Gib Skin" : 0 : "Some models have multiple versions of their textures, called skins. Set this to a number other than 0 to use that skin on all gibs produced by this shooter."
	scale(float) : "Gib Scale" : "1.0" : "Multiplies the size of the gib models. Physics will not be scaled up."
	lightingorigin(target_destination) : "Lighting Origin" :  : "Select an entity to specify a location to sample lighting from for all gibs spawned by this shooter, instead of their own origins."
	nogibshadows(choices) : "Disable Shadows on Gibs" : 0 = [
		0: "No"
		1: "Yes"
	] // end nogibshadows
	m_iGibs(integer) : "Number of Gibs" : 3 : "Total number of gibs to shoot each time it's activated."
	delay(string) : "Delay Between Shots" : "0" : "Delay (in seconds) between shooting each gib. If 0, all gibs shoot at once."
	m_flVelocity(integer) : "Gib Velocity" : 200 : "Speed of the fired gibs."
	m_flVariance(string) : "Course Variance" : "0.15" : "How much variance in the direction gibs are fired."
	m_flGibLife(string) : "Gib Life" : "4" : "Time in seconds for gibs to live +/- 5%"
	gibanglevelocity(string) : "Max Angular Velocity" : "0" : "How fast (degrees/sec) the gib pieces should spin. They will spin on x and y axis at between 10% and 100% of this speed."
	gibgravityscale(float) : "Gib Gravity Scale" : "1" : "Only works for 'Point' type gibs. This field allows you to scale gravity so that gibs fall faster, slower, or not at all."
	shootsounds(choices) : "Material Sound" : -1 = [
		-1 : "None"
		0 : "Glass"
		1 : "Wood"
		2 : "Metal"
		3 : "Flesh"
		4 : "Concrete"
	] // end shootsounds
	simulation(choices) : "Simulate" : 0 = [
		0: "Point"
		1: "Physics"
		2: "Ragdoll"
	] // end simulation
] // end env_shooter_keys
@PointClass base(SBaseEntity, SBaseDiv, env_shooter_keys, SRenderModes) studio("models/editor/cone_helper.mdl") = env_shooter : "An entity that shoots sprites, physically simulated objects or ragdolls out of its origin." [ // iconsprite("editor-ficool2/env_shooter")
	spawnflags(flags) = [
		1 : "Repeatable"  : 1
		2 : "Ignited (does not work with ragdolls)" : 0
		4 : "Strict remove after lifetime (needed if 'Ignited' is checked)" : 1
	] // end spawnflags

	input Shoot(void) : "Force the shooter to create and shoot a gib."
] // end env_shooter

@BaseClass = env_rotorshooter_keys [
	rotortime(float) : "Time Under Rotor" : "1" : "The average time it has to be under the rotor before it shoots a gib."
	rotortimevariance(float) : "Time variance" : "0.3" : "The random amount to vary the time it has to be under the rotor before it shoots a gib."
] // end env_rotorshooter_keys
@PointClass base(SBaseEntity, SBaseDiv, env_rotorshooter_keys, SClassDiv1, env_shooter_keys, SRenderModes, env_shooter) studio("models/editor/cone_helper.mdl") = env_rotorshooter : "An entity that creates gibs when it's within the influence of a npc_helicopter's rotor wash." [ // iconsprite("editor-ficool2/env_rotorshooter")
] // end env_rotorshooter

@PointClass base(env_shooter) studio("models/editor/cone_helper.mdl") = gibshooter : "An entity that shoots out gibs. May not work correctly, use env_shooter instead. Style of body part depends on the language type." [ // iconsprite("editor-ficool2/gibshooter")
] // end gibshooter

@BaseClass = env_smokestack_keys [
	InitialState(choices) : "Initial State" : 0 = [
		0 : "Off"
		1 : "On"
	] // end InitialState
	BaseSpread(integer) : "Spread at the base" : 20 : "Amount of random spread in the origins of the smoke particles when they're spawned."
	SpreadSpeed(integer) : "Spread Speed" : 15 : "Amount of random spread in the velocity of the smoke particles after they're spawned."
	Speed(integer) : "Speed" : 30 : "The speed at which the smoke particles move after they're spawned."
	StartSize(integer) : "Particle start size" : 20 : "Size of the smoke particles when they're first emitted."
	EndSize(integer) : "Particle end size" : 30 : "Size of the smoke particles at the point they fade out completely."
	Rate(integer) : "Emission rate" : 20 : "Rate at which to emit smoke particles (i.e. particles to emit per second)."
	JetLength(integer) : "Length of smoke trail" : 180 : "Length of the smokestack. Lifetime of the smoke particles is derived from this & particle speed."
	WindAngle(integer) : "Wind X/Y Angle" : 0 : "This specifies the wind direction. It is an angle in the XY plane. WindSpeed specifies the strength of the wind."
	WindSpeed(integer) : "Wind Speed" : 0 : "The strength of the wind."
	SmokeMaterial(material) : "Particle material" : "particle/SmokeStack.vmt" : "Material of the smoke particles emitted by this stack."
	twist(integer) : "Twist" : 0 : "The amount, in degrees per second, that the smoke particles twist around the origin."
	roll(float) : "Roll Speed": 0 : "Amount of roll in degrees per second."
] // end env_smokestack_keys
@PointClass base(SBaseEntity, SBaseDiv, env_smokestack_keys, SRenderModes) studio("models/editor/axis_helper_thick.mdl") = env_smokestack : "An entity that spits out a constant stream of particles. You can place up to two env_particlelight entities near the smoke stack to add ambient light to its particles." [
	input TurnOn(void) : "Turn on the smokestack."
	input TurnOff(void) : "Turn off the smokestack."
	input Toggle(void) : "Toggles the smokestack between on and off state."
	input JetLength(integer): "Set the length of the smoke trail."
	input Rate(integer) : "Set the rate at which to emit smoke particles (particles per second)."
	input Speed(integer) : "Set the speed at which the smoke particles move after they're spawned."
	input SpreadSpeed(integer) : "Set the amount of random spread in the velocity of the smoke particles after they're spawned."
	input Color(color255) : "Changes the smoke particle color."
	input Alpha(integer) : "Changes the smoke particle translucency."
] // end env_smokestack

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/env_smoketrail") sphere(spawnradius) = env_smoketrail : "An entity that creates a smoke trail. Must be parented to take effect." [
	opacity(float) : "Sprite Opacity" : "0.75" : "Opacity of the sprites (range from 0 - 1)."
	spawnrate(float) : "Spawn Rate" : "20" : "Number of particles to emit each second."
	lifetime(float) : "Particle Life Time" : "5.0" : "Number of seconds until each particle dies."
	startcolor(color255) : "Start Color" : "192 192 192" : "Starting color of the emitted particles."
	endcolor(color255) : "End Color" : "160 160 160" : "Ending color of the emitted particles."
	emittime(float) : "Emitter Life Time" : "0" : "Number of seconds until the env_smoketrail stops emitting particles. 0 means never stop emitting particles."
	minspeed(float) : "Minimum Random Speed" : "10" : "Minimum randomly-directed speed to use for emitted particles."
	maxspeed(float) : "Maximum Random Speed" : "20" : "Maximum randomly-directed speed to use for emitted particles."
	mindirectedspeed(float) : "Minimum Directed Speed" : "0" : "Minimum speed along the env_smoketrail's forward direction (x axis) to use for emitted particles."
	maxdirectedspeed(float) : "Maximum Directed Speed" : "0" : "Maximum speed along the env_smoketrail's forward direction (x axis) to use for emitted particles."
	startsize(float) : "Starting particle size" : "15" : "Starting particle size."
	endsize(float) : "Ending particle size" : "50" : "Ending particle size."
	spawnradius(float) : "Spawn radius" : "15" : "Distance from env_smoketrail at which particles are emitted."
] // end env_smoketrail

@Pointclass base(SPreservedEntity, STargetname, SParentname, SBaseIO, SBaseDiv, SSoundscapes) iconsprite("editor-ficool2/env_soundscape") line(255 255 255, targetname, position0) line(255 255 255, targetname, position1) line(255 255 255, targetname, position2) line(255 255 255, targetname, position3) line(255 255 255, targetname, position4) line(255 255 255, targetname, position5) line(255 255 255, targetname, position6) line(255 255 255, targetname, position7) sphere(radius) = env_soundscape : "An entity to control sound in an area. The active soundscape at any time is the last one that had line-of-sight to the player, and was within the radius." [
] // end env_soundscape

@PointClass base(SPreservedEntity, STargetname, SParentname, SBaseIO, SBaseDiv) iconsprite("editor-ficool2/env_soundscape_proxy") sphere(radius) = env_soundscape_proxy : "An entity that acts like a soundscape but gets all of its sound parameters from another env_soundscape entity." [
	MainSoundscapeName(target_destination) : "Soundscape Entity" :  : "The soundscape to get all sound parameters from."
	radius(integer) : "Radius" : 128 : "Defines the entity's sphere of influence. Players must also be able to see the entity for it to trigger. -1 means infinite range."
] // end env_soundscape_proxy

// TODO: Does radius do anything?
@PointClass base(SPreservedEntity, STargetname, SParentname, SBaseDiv, SSoundscapes) iconsprite("editor-ficool2/env_soundscape_triggerable") line(255 255 255, targetname, position0) line(255 255 255, targetname, position1) line(255 255 255, targetname, position2) line(255 255 255, targetname, position3) line(255 255 255, targetname, position4) line(255 255 255, targetname, position5) line(255 255 255, targetname, position6) line(255 255 255, targetname, position7) = env_soundscape_triggerable : "An entity that works like env_soundscape except that it can work in conjunction with trigger_soundscape to determine when a player hears it." [
] // end env_soundscape_triggerable

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor/env_spark") studio("models/editor/cone_helper.mdl") = env_spark : "An entity that emits sparks at its origin." [
	MaxDelay(string) : "Max Delay" : "0" : "After emitting sparks, the entity will wait a random amount of seconds before emitting again (unless it was told to SparkOnce). This specifies the longest possible delay between sparks (in seconds). If 0, this entity constantly emits sparks."
	Magnitude(integer) : "Magnitude" : 1 : "Multiplier for the number of sparks to emit at once." //= [
		//1 : "Low"
		//2 : "Medium"
		//5 : "High"
		//8 : "Super High"
	//] // end Magnitude
	TrailLength(choices) : "Spark Trail Length" : 1 : "Length of the spark trails." = [
		1 : "Short"
		2 : "Medium"
		3 : "Long"
	] // end TrailLength

	spawnflags(flags) = [
		64 : "Start ON" : 0
		128 : "Glow Sprite at Origin" : 0
		256 : "Silent" : 0
		512 : "Directional - If unchecked, emit sparks in all directions" : 1
	] // end spawnflags

	input StartSpark(void) : "Start emitting sparks."
	input StopSpark(void) : "Stop emitting sparks."
	input ToggleSpark(void) : "Toggle the on/off state of the spark effect."
	input SparkOnce(void) : "Emit sparks once."

	output OnSpark(void) : "Fired whenever sparks are emitted."
] // end env_spark

@PointClass base(SBaseEntity, SBaseDiv) = env_splash : "An entity that creates a splash effect at its origin, not necessarily in water." [ // iconsprite("editor-ficool2/env_splash")
	scale(float) : "Scale" : "8.0" : "Scale of the splash."

	spawnflags(flags) = [
		1: "Automatically find water surface (entity must be directly above water)" : 0
		2: "Diminish with depth (diminished completely in 10 feet of water)" : 1
	] // end spawnflags

	input Splash(void) : "Create a splash effect."
] // end env_splash

@PointClass base(SBaseEntity, SBaseDiv, SEnableDisable) iconsprite("editor-ficool2/env_sporeexplosion") = env_sporeexplosion : "An entity that emits flying, yellow spores/particles like from Half Life 2's Bugbait." [
	spawnrate(float) : "Spawn Rate (as percentage)" : "25" : "How dense the spore effect is. This percentage is not bound to 100; even values in the thousands are acceptable."
] // end env_sporeexplosion

@PointClass base(SBaseEntity) iconsprite("editor-ficool2/env_sporetrail") = env_sporetrail : "An entity that emits flying, yellow spores/particles like from Half Life 2's Bugbait, but in the form of a trail. Must be parented to take effect." [
] // end env_sporetrail

// TODO: I wanna play around with this...
@BaseClass = env_sprite_keys [
	// TODO: Should/can this be a material? Is spr an actual useful extension?
	model(sprite) : "Sprite Name" : "sprites/glow01.spr" : "Material of the sprite to be drawn."
] // end env_sprite_keys
@PointClass base(SPreservedEntity, SBaseEntity, SBaseDiv, env_sprite_keys, SSprite, SRenderModes) size(-2 -2 -2, 2 2 2) sphere(GlowProxySize) sprite() = env_sprite : "An entity that controls the drawing of a sprite in the world." [
	spawnflags(flags) = [
		1: "Start On" : 1
		2: "Play Once - Used for animated sprites. Texture will animate once, then the sprite will turn off." : 0
	] // end spawnflags

	input ColorBlueValue(float) : "Sets the blue color channel's value (0 - 255)."
	input ColorGreenValue(float) : "Sets the green color channel's value (0 - 255)."
	input ColorRedValue(float) : "Sets the red color channel's value (0 - 255)."
	input HideSprite(void) : "Hide the sprite. Won't be drawn until the 'ShowSprite' input is received."
	input SetScale(float) : "Set the sprite's scale."
	input ShowSprite(void) : "Show the sprite."
	input ToggleSprite(void) : "Toggle the sprite between hidden and shown."
] // end env_sprite

@PointClass base(env_sprite) size(-2 -2 -2, 2 2 2) sphere(GlowProxySize) sprite() = env_glow : "Identical to env_sprite. An entity that controls the drawing of a sprite in the world." [
] // end env_glow

@PointClass base(env_sprite) size(-2 -2 -2, 2 2 2) sphere(GlowProxySize) sprite() = env_sprite_oriented : "A env_sprite that allows orientation. The sprite material needs to use $spriteorientation." [
] // end env_sprite_oriented

@BaseClass = env_spritetrail_keys [
	spritename(sprite) : "Sprite Name" : "sprites/bluelaser1.vmt" : "The material to draw."
	startwidth(float) : "Start Width" : "8.0" : "The width of the beam to the beginning."
	endwidth(float) : "End Width" : "1.0" : "The width of the beam when it has full expanded."
	lifetime(float) : "Lifetime" : "0.5" : "How long the beam is shown."
	animate(choices) : "Animated?" : "0" : "Tells the sprite to animate if it can." = [
		0 : "No"
		1 : "Yes"
	] // end animate
] // end env_spritetrail_keys
@PointClass base(SBaseEntity, SBaseDiv, env_spritetrail_keys, SSprite, SRenderModes) size(-2 -2 -2, 2 2 2) sprite() = env_spritetrail : "Emits a sprite, intended to create a trail effect when moving. Must be parented to something." [
	input ColorBlueValue(float) : "Sets the blue color channel's value (0 - 255)."
	input ColorGreenValue(float) : "Sets the green color channel's value (0 - 255)."
	input ColorRedValue(float) : "Sets the red color channel's value (0 - 255)."
	input HideSprite(void) : "Hide the sprite. Won't be drawn until the 'ShowSprite' input is received."
	input SetScale(float) : "Set the sprite's scale."
	input ShowSprite(void) : "Show the sprite."
	input ToggleSprite(void) : "Toggle the sprite between hidden and shown."
] // end env_spritetrail

@BaseClass = env_steam_keys [
	InitialState(choices) : "Initial State" : 0 = [
		0 : "Off"
		1 : "On"
	] // end InitialState
	type(choices) : "Particle Type" : 0 = [
		0 : "Normal"
		1 : "Heat Wave"
	] // end type
	SpreadSpeed(integer) : "Spread Speed" : 15 : "The amount of random spread in the particle's velocity after they spawn."
	Speed(integer) : "Speed" : 120 : "The default speed at which the particles move after they spawn."
	StartSize(integer) : "Particle Start Size" : 10 : "The initial size of the particles after they spawn."
	EndSize(integer) : "Particle End Size" : 25 : "The size of the particles at the point at which they are removed."
	Rate(integer) : "Emission Rate" : 26 : "The rate of particle emission. i.e. particles per second."
	JetLength(integer) : "Length of Steam Jet" : 80 : "The length of the jet determines the lifetime of each particle."
	rollspeed(float) : "Roll Speed" : 8 : "The speed at which particles spin."
] // end env_steam_keys
@PointClass base(SBaseEntity, SBaseDiv, env_steam_keys, SRenderModes) sphere(JetLength) studio("models/editor/cone_helper.mdl") = env_steam : "An entity used to create a jet of steam, or heat wave distortion." [
	spawnflags(flags) = [
		1 : "Emissive - Uses the value specified in Color. If not checked, color is automatically determined by environmental lighting." : 0
	] // end spawnflags

	input TurnOn(void) : "Turns the steam jet on."
	input TurnOff(void) : "Turns the steam jet off."
	input Toggle(void) : "Toggles the steam jet between on and off."
	input JetLength(integer) : "Sets the length of steam jet."
	input Rate(integer) : "Sets the particle emission rate in particles per second."
	input Speed(integer) : "Sets the default speed of the particles in units per second."
	input SpreadSpeed(integer) : "Sets the spread speed in units per second."
] // end env_steam

// TODO: Verify description, and maybe update model to reflect that
@PointClass base(env_steam) sphere(JetLength) studio("models/editor/spot_cone.mdl") = env_steamjet : "Legacy support: Same as env_steam, although faces left instead of forward." [
] // end env_steamjet

@PointClass base(SPreservedEntity, SBaseAnglesLight, SBaseDiv) iconsprite("editor-abs/env_sun") line(255 255 255, targetname, target) = env_sun : "An entity used to control and draw a sun effect in the sky." [
	use_angles(choices) : "Use Angles?" : 1 : "If set to No, orient the sun by targetting an entity. If set to Yes, orient the sun with defined angles." = [
		0 : "No"
		1 : "Yes"
	] // end use_angles
	target(target_destination) : "Viewer Entity" :  : "Name of an entity used to determine where the sun is in the skybox. The resulting sun sprite will be positioned based on a line starting from the Viewer Entity towards the env_sun." // TODO: Does this update over time?
	//angle(float) : "Yaw" : 0 : "Override for Yaw in Pitch Yaw Roll, similar to Pitch." // FICOOOOOOOOOL THIS CRASHES THE GAME FICOOOOOOOOOL YOU CANT DO THIS FICOOOOOOOOOOOOOL
	material(sprite) : "Material Name" : "sprites/light_glow02_add_noz" : "Material of the inner glow."
	rendercolor(color255) : "Sun Color (R G B)" : "100 80 80" : "Color of the sun. The effect is additive with the sky: a pure yellow sun with a bright blue sky will appear white in-game; change the color to account for this."
	size(integer) : "Size" : 16 : "Size of the sun."
	overlaymaterial(sprite) : "Overlay Material Name" : "sprites/light_glow02_add_noz" : "Material of the overlay glow."
	overlaycolor(color255) : "Overlay Color (R G B)" : "0 0 0" : "Color of the sun overlay."
	overlaysize(integer) : "Overlay Size" : -1 : "A value of -1 means the overlay will act the old way."
	HDRColorScale(float) : "HDR Color Scale" : "1.0" : "Color multiplier when in HDR mode."

	input TurnOff(void) : "Disable sun rendering."
	input SetColor(color255) : "Change the sun's color."
	input TurnOn(void) : "Enable sun rendering."
] // end env_sun

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/env_texturetoggle") = env_texturetoggle : "An entity that allows you to change the animated texture frame on an entity that uses animated textures. Alternatively, you can change the 'texframeindex' keyvalue on an entity with AddOutput, although it will be slower to update." [
	target(target_destination) : "Target" :  : "Name of the entity whose textures will be altered. All ToggleTexture materials on all entities (including sprites and overlays) matching the targetname will be affected."

	input IncrementTextureIndex(void) : "Increments target's current texture frame by one."
	input SetTextureIndex(integer) : "Sets target's texture frame to the specified index."
] // end env_texturetoggle

@PointClass base(SBaseLogical) color(100 150 255) iconsprite("editor-ficool2/env_tonemap_controller") = env_tonemap_controller : "An entity that controls the HDR tonemapping for the player. Think of it as a method of controlling the exposure of the player's eyes." [
	input BlendTonemapScale(string) : "SetTonemapScale performed over a length of time. Parameter should be a value between 0 and 2 followed by a length of time in seconds.  This appears jumpy, as if the TonemapRate fights the transition."
	input SetAutoExposureMax(string) : "Set AutoExposureMax, the maximum amount that the player's pupils are allowed to be open when automatically adjusting."
	input SetAutoExposureMin(string) : "Set AutoExposureMin, the minimum amount that the player's pupils are allowed to be open when automatically adjusting.  Overrides AutoExposureMax if Min>Max."
	input SetBloomScale(string) : "Set BloomScale, a scalar for the size of light bloom effects."
	input SetBloomScaleRange(vector) : "Sets a range for the bloom scale. First number is the maximum, second number is the minimum. "
	input SetTonemapRate(string) : "Set the TonemapRate, the rate at which the player's eyes adjust to light.  Higher values denote faster adjustments."
	input SetTonemapScale(float) : "Set the player's tonemap scale - the openness of his pupils. Parameter should be a value between 0 and 2, where 0 is the eyes fully closed, 1 is the unchanged autoexposure (default), and 2 is the eye fully wide open.  Fades back to 1 via the current TonemapRate."
	input UseDefaultAutoExposure(void) : "Use the default AutoExposureMin and AutoExposureMax values."
	input UseDefaultBloomScale(void) : "Use the default BloomScale."
] // end env_tonemap_controller

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/env_tracer") line(255 255 255, targetname, target) = env_tracer : "An entity that fires a thin tracer between itself and a target, with a specified delay. The tracer does not follow or update the target. The tracer always fires at its original position, even if the target is killed." [
	target(target_destination) : "Target" :  : "The target to fire the tracer at. Must be 256 or more units away from the env_tracer."
	delay(float) : "Delay" : 1 : "How long to wait before firing the tracer again, in seconds."
] // end env_tracer

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/env_viewpunch") sphere(radius) = env_viewpunch : "An entity that applies a view punch on players according to the origin, radius, and angle." [
	// TODO: test
	punchangle(angle) : "Punch Angles" : "0 0 90" : "The punch angles to apply."
	radius(float) : "Effect Radius" : "512" : "The radius around this entity in which to affect players."

	spawnflags(flags) = [
		1: "Punch all players (ignore radius)" : 0
		2: "Punch players in the air" : 1
	] // end spawnflags

	input ViewPunch(void) : "Performs the view punch."
] // end env_viewpunch

//Apparently values set by this entity may sometimes carry over to the next map, if not overriden by another env_wind. Fun. -Brokk
@PointClass base(SPreservedEntity, STargetname, SAngles, SBaseIO, SBaseDiv) iconsprite("editor-ficool2/env_wind") = env_wind : "An entity to control wind in the map. Can be used to control $treesway on models." [
	minwind(integer) : "Min Normal Speed" : 20 : "Minimum speed of the wind while idling."
	maxwind(integer) : "Max Normal Speed" : 50 : "Maximum speed of the wind while idling."
	mingust(integer) : "Min Gust Speed" : 100 : "Minimum speed of wind gusts."
	maxgust(integer) : "Max Gust Speed" : 250 : "Maximum speed of wind gusts."
	mingustdelay(integer) : "Min Gust Delay" : 10 : "Minimum time delay between random gusts."
	maxgustdelay(integer) : "Max Gust Delay" : 20 : "Maximum time delay between random gusts."
	gustduration(integer) : "Gust Duration" : 5 : "How long will the wind gust for."
	gustsound(sound) : "Gust Sound Filename" :  : "Sound to be played to simulate the gusting wind."
	gustdirchange(integer) : "Max Gust Dir Change (degrees)" : 20 : "Maximum amount that the wind's direction changes due to a gust."

	output OnGustStart(void) : "Fired when a wind gust begins."
	output OnGustEnd(void) : "Fired when a wind gust ends."
] // end env_wind



	// EYEBALL ENTITIES //

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SBaseDynamicModel) color(150 0 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/props_halloween/halloween_demoeye.mdl") = eyeball_boss : "The MONOCULUS! boss NextBot. Capable of moving without a navigation file. The following info_targets can be placed to perform functions: spawn_boss_alt - places where MONOCULUS! can teleport, spawn_purgatory - where a player will teleport after leaping into his portal, spawn_loot - where a player will teleport after MONOCULUS! dies." [
	TeamNum(choices) : "Team" : 5 : "Team of the entity. May or may not change the entity's appearance." = [
		0 : "0 - Any/Unassigned"
		1 : "1 - Spectator"
		2 : "2 - RED"
		3 : "3 - BLU"
		5 : "5 - Neutral/Boss"
	] // end TeamNum
] // end eyeball_boss



	// FILTER ENTITIES //

@FilterClass base(SBaseFilter) color(255 100 150) iconsprite("editor-ficool2/filter_activator_class") = filter_activator_class : "A filter that filters by the entity class name of the activator.\n" +
	"NOTE: This filters for entity classes such as trigger_multiple, NOT for player classes like Scout and Heavy. To filter for player classes, use filter_tf_class.\n" +
	"TIP: Entities can have their classnames changed using AddOutput. Beware however, as this can lead to strange behavior and even crashes on a round restart!" [
	filterclass(choices) : "Class to Filter" :  : "The class name to filter by. Wildcards are accepted." = [
		"_ballplayertoucher" : "_ballplayertoucher"
		"_firesmoke" : "_firesmoke"
		"_plasma" : "_plasma"
		"ai_ally_speech_manager" : "ai_ally_speech_manager"
		"ai_battle_line" : "ai_battle_line"
		"ai_changehintgroup" : "ai_changehintgroup"
		"ai_changetarget" : "ai_changetarget"
		"ai_goal_assault" : "ai_goal_assault"
		"ai_goal_follow" : "ai_goal_follow"
		"ai_goal_lead" : "ai_goal_lead"
		"ai_goal_lead_weapon" : "ai_goal_lead_weapon"
		"ai_goal_standoff" : "ai_goal_standoff"
		"ai_hint" : "ai_hint"
		"ai_network" : "ai_network"
		"ai_relationship" : "ai_relationship"
		"ai_script_conditions" : "ai_script_conditions"
		"ai_sound" : "ai_sound"
		"ai_speechfilter" : "ai_speechfilter"
		"aiscripted_schedule" : "aiscripted_schedule"
		"aitesthull" : "aitesthull"
		"ambient_generic" : "ambient_generic"
		"archer_proxy" : "archer_proxy"
		"assault_assaultpoint" : "assault_assaultpoint"
		"assault_rallypoint" : "assault_rallypoint"
		"base_boss" : "base_boss"
		"beam" : "beam"
		"bot_action_point" : "bot_action_point"
		"bot_controller" : "bot_controller"
		"bot_generator" : "bot_generator"
		"bot_hint_engineer_nest" : "bot_hint_engineer_nest"
		"bot_hint_sentrygun" : "bot_hint_sentrygun"
		"bot_hint_teleporter_exit" : "bot_hint_teleporter_exit"
		"bot_npc_archer" : "bot_npc_archer"
		"bot_npc_decoy" : "bot_npc_decoy"
		"bot_proxy" : "bot_proxy"
		"bot_roster" : "bot_roster"
		"color_correction" : "color_correction"
		"color_correction_volume" : "color_correction_volume"
		"commentary_auto" : "commentary_auto"
		"cycler_actor" : "cycler_actor"
		"cycler_flex" : "cycler_flex"
		"dispenser_touch_trigger" : "dispenser_touch_trigger"
		"dynamic_prop" : "dynamic_prop"
		"entity_bird" : "entity_bird"
		"entity_blocker" : "entity_blocker"
		"entity_carrier" : "entity_carrier"
		"entity_croc" : "entity_croc"
		"entity_medigun_shield" : "entity_medigun_shield"
		"entity_revive_marker" : "entity_revive_marker"
		"entity_rocket" : "entity_rocket"
		"entity_saucer" : "entity_saucer"
		"entity_sign" : "entity_sign"
		"entity_soldier_statue" : "entity_soldier_statue"
		"entity_spawn_manager" : "entity_spawn_manager"
		"entity_spawn_point" : "entity_spawn_point"
		"entityflame" : "entityflame"
		"env_beam" : "env_beam"
		"env_beverage" : "env_beverage"
		"env_blood" : "env_blood"
		"env_bubbles" : "env_bubbles"
		"env_credits" : "env_credits"
		"env_debughistory" : "env_debughistory"
		"env_detail_controller" : "env_detail_controller"
		"env_dustpuff" : "env_dustpuff"
		"env_dusttrail" : "env_dusttrail"
		"env_effectscript" : "env_effectscript"
		"env_embers" : "env_embers"
		"env_entity_dissolver" : "env_entity_dissolver"
		"env_entity_igniter" : "env_entity_igniter"
		"env_entity_maker" : "env_entity_maker"
		"env_explosion" : "env_explosion"
		"env_fade" : "env_fade"
		"env_fire" : "env_fire"
		"env_fire_trail" : "env_fire_trail"
		"env_firesensor" : "env_firesensor"
		"env_firesource" : "env_firesource"
		"env_fog_controller" : "env_fog_controller"
		"env_funnel" : "env_funnel"
		"env_global" : "env_global"
		"env_glow" : "env_glow"
		"env_gunfire" : "env_gunfire"
		"env_hudhint" : "env_hudhint"
		"env_laser" : "env_laser"
		"env_laserdot" : "env_laserdot"
		"env_lightglow" : "env_lightglow"
		"env_message" : "env_message"
		"env_microphone" : "env_microphone"
		"env_movieexplosion" : "env_movieexplosion"
		"env_muzzleflash" : "env_muzzleflash"
		"env_particle_performance_monitor" : "env_particle_performance_monitor"
		"env_particle_trail" : "env_particle_trail"
		"env_particlefire" : "env_particlefire"
		"env_particlelight" : "env_particlelight"
		"env_particlescript" : "env_particlescript"
		"env_particlesmokegrenade" : "env_particlesmokegrenade"
		"env_physexplosion" : "env_physexplosion"
		"env_physimpact" : "env_physimpact"
		"env_physwire" : "env_physwire"
		"env_player_surface_trigger" : "env_player_surface_trigger"
		"env_projectedtexture" : "env_projectedtexture"
		"env_quadraticbeam" : "env_quadraticbeam"
		"env_ragdoll_boogie" : "env_ragdoll_boogie"
		"env_rockettrail" : "env_rockettrail"
		"env_rotorshooter" : "env_rotorshooter"
		"env_screeneffect" : "env_screeneffect"
		"env_screenoverlay" : "env_screenoverlay"
		"env_shake" : "env_shake"
		"env_shooter" : "env_shooter"
		"env_smokestack" : "env_smokestack"
		"env_smoketrail" : "env_smoketrail"
		"env_sniperdot" : "env_sniperdot"
		"env_soundscape" : "env_soundscape"
		"env_soundscape_proxy" : "env_soundscape_proxy"
		"env_soundscape_triggerable" : "env_soundscape_triggerable"
		"env_spark" : "env_spark"
		"env_splash" : "env_splash"
		"env_sporeexplosion" : "env_sporeexplosion"
		"env_sporetrail" : "env_sporetrail"
		"env_sprite" : "env_sprite"
		"env_sprite_oriented" : "env_sprite_oriented"
		"env_spritetrail" : "env_spritetrail"
		"env_steam" : "env_steam"
		"env_steamjet" : "env_steamjet"
		"env_sun" : "env_sun"
		"env_texturetoggle" : "env_texturetoggle"
		"env_tonemap_controller" : "env_tonemap_controller"
		"env_tracer" : "env_tracer"
		"env_viewpunch" : "env_viewpunch"
		"env_wind" : "env_wind"
		"env_zoom" : "env_zoom"
		"event_queue_saveload_proxy" : "event_queue_saveload_proxy"
		"eyeball_boss" : "eyeball_boss"
		"filter_activator_class" : "filter_activator_class"
		"filter_activator_mass_greater" : "filter_activator_mass_greater"
		"filter_activator_name" : "filter_activator_name"
		"filter_activator_team" : "filter_activator_team"
		"filter_activator_tfteam" : "filter_activator_tfteam"
		"filter_base" : "filter_base"
		"filter_damage_type" : "filter_damage_type"
		"filter_enemy" : "filter_enemy"
		"filter_multi" : "filter_multi"
		"filter_tf_bot_has_tag" : "filter_tf_bot_has_tag"
		"filter_tf_class" : "filter_tf_class"
		"filter_tf_condition" : "filter_tf_condition"
		"filter_tf_damaged_by_weapon_in_slot" : "filter_tf_damaged_by_weapon_in_slot"
		"filter_tf_player_can_cap" : "filter_tf_player_can_cap"
		"fish" : "fish"
		"funCBaseFlex" : "funCBaseFlex"
		"func_achievement" : "func_achievement"
		"func_areaportal" : "func_areaportal"
		"func_areaportalwindow" : "func_areaportalwindow"
		"func_breakable" : "func_breakable"
		"func_breakable_surf" : "func_breakable_surf"
		"func_brush" : "func_brush"
		"func_button" : "func_button"
		"func_capturezone" : "func_capturezone"
		"func_changeclass" : "func_changeclass"
		"func_clip_vphysics" : "func_clip_vphysics"
		"func_conveyor" : "func_conveyor"
		"func_croc" : "func_croc"
		"func_door" : "func_door"
		"func_door_rotating" : "func_door_rotating"
		"func_dustcloud" : "func_dustcloud"
		"func_dustmotes" : "func_dustmotes"
		"func_fish_pool" : "func_fish_pool"
		"func_flag_alert" : "func_flag_alert"
		"func_flagdetectionzone" : "func_flagdetectionzone"
		"func_forcefield" : "func_forcefield"
		"func_guntarget" : "func_guntarget"
		"func_illusionary" : "func_illusionary"
		"func_ladderendpoint" : "func_ladderendpoint"
		"func_lod" : "func_lod"
		"func_monitor" : "func_monitor"
		"func_movelinear" : "func_movelinear"
		"func_nav_avoid" : "func_nav_avoid"
		"func_nav_avoidance_obstacle" : "func_nav_avoidance_obstacle"
		"func_nav_blocker" : "func_nav_blocker"
		"func_nav_prefer" : "func_nav_prefer"
		"func_nav_prerequisite" : "func_nav_prerequisite"
		"func_nobuild" : "func_nobuild"
		"func_nogrenades" : "func_nogrenades"
		"func_occluder" : "func_occluder"
		"func_passtime_goal" : "func_passtime_goal"
		"func_passtime_goalie_zone" : "func_passtime_goalie_zone"
		"func_passtime_no_ball_zone" : "func_passtime_no_ball_zone"
		"func_physbox" : "func_physbox"
		"func_physbox_multiplayer" : "func_physbox_multiplayer"
		"func_plat" : "func_plat"
		"func_platrot" : "func_platrot"
		"func_powerupvolume" : "func_powerupvolume"
		"func_precipitation" : "func_precipitation"
		"func_proprrespawnzone" : "func_proprrespawnzone"
		"func_pushable" : "func_pushable"
		"func_reflective_glass" : "func_reflective_glass"
		"func_regenerate" : "func_regenerate"
		"func_respawnflag" : "func_respawnflag"
		"func_respawnroom" : "func_respawnroom"
		"func_respawnroomvisualizer" : "func_respawnroomvisualizer"
		"func_rot_button" : "func_rot_button"
		"func_rotating" : "func_rotating"
		"func_smokevolume" : "func_smokevolume"
		"func_suggested_build" : "func_suggested_build"
		"func_tanktrain" : "func_tanktrain"
		"func_tfbot_hint" : "func_tfbot_hint"
		"func_trackautochange" : "func_trackautochange"
		"func_trackchange" : "func_trackchange"
		"func_tracktrain" : "func_tracktrain"
		"func_train" : "func_train"
		"func_traincontrols" : "func_traincontrols"
		"func_upgradestation" : "func_upgradestation"
		"func_useableladder" : "func_useableladder"
		"func_vehicleclip" : "func_vehicleclip"
		"func_wall" : "func_wall"
		"func_wall_toggle" : "func_wall_toggle"
		"func_water" : "func_water"
		"func_water_analog" : "func_water_analog"
		"func_weight_button" : "func_weight_button"
		"game_end" : "game_end"
		"game_forcerespawn" : "game_forcerespawn"
		"game_gib_manager" : "game_gib_manager"
		"game_intro_viewpoint" : "game_intro_viewpoint"
		"game_player_equip" : "game_player_equip"
		"game_player_team" : "game_player_team"
		"game_ragdoll_manager" : "game_ragdoll_manager"
		"game_round_win" : "game_round_win"
		"game_score" : "game_score"
		"game_text" : "game_text"
		"game_text_tf" : "game_text_tf"
		"game_ui" : "game_ui"
		"game_weapon_manager" : "game_weapon_manager"
		"game_zone_player" : "game_zone_player"
		"generic_actor" : "generic_actor"
		"ghost" : "ghost"
		"gib" : "gib"
		"gibshooter" : "gibshooter"
		"grenade" : "grenade"
		"halloween_fortune_teller" : "halloween_fortune_teller"
		"halloween_souls_pack" : "halloween_souls_pack"
		"halloween_zapper" : "halloween_zapper"
		"hammer_updateignorelist" : "hammer_updateignorelist"
		"handle_dummy" : "handle_dummy"
		"handle_test" : "handle_test"
		"headless_hatman" : "headless_hatman"
		"hightower_teleport_vortex" : "hightower_teleport_vortex"
		"info_camera_link" : "info_camera_link"
		"info_constraint_anchor" : "info_constraint_anchor"
		"info_hint" : "info_hint"
		"info_intermission" : "info_intermission"
		"info_ladder_dismount" : "info_ladder_dismount"
		"info_landmark" : "info_landmark"
		"info_lighting_relative" : "info_lighting_relative"
		"info_mass_center" : "info_mass_center"
		"info_node" : "info_node"
		"info_node_air" : "info_node_air"
		"info_node_air_hint" : "info_node_air_hint"
		"info_node_climb" : "info_node_climb"
		"info_node_hint" : "info_node_hint"
		"info_node_link" : "info_node_link"
		"info_node_link_controller" : "info_node_link_controller"
		"info_npc_spawn_destination" : "info_npc_spawn_destination"
		"info_null" : "info_null"
		"info_observer_point" : "info_observer_point"
		"info_overlay_accessor" : "info_overlay_accessor"
		"info_particle_system" : "info_particle_system"
		"info_passtime_ball_spawn" : "info_passtime_ball_spawn"
		"info_player_deathmatch" : "info_player_deathmatch"
		"info_player_start" : "info_player_start"
		"info_player_teamspawn" : "info_player_teamspawn"
		"info_populator" : "info_populator"
		"info_powerup_spawn" : "info_powerup_spawn"
		"info_projecteddecal" : "info_projecteddecal"
		"info_radial_link_controller" : "info_radial_link_controller"
		"info_target" : "info_target"
		"info_teleport_destination" : "info_teleport_destination"
		"infodecal" : "infodecal"
		"instanced_scripted_scene" : "instanced_scripted_scene"
		"item_ammopack_full" : "item_ammopack_full"
		"item_ammopack_medium" : "item_ammopack_medium"
		"item_ammopack_small" : "item_ammopack_small"
		"item_armor" : "item_armor"
		"item_bonuspack" : "item_bonuspack"
		"item_currencypack_custom" : "item_currencypack_custom"
		"item_currencypack_large" : "item_currencypack_large"
		"item_currencypack_medium" : "item_currencypack_medium"
		"item_currencypack_small" : "item_currencypack_small"
		"item_healthammokit" : "item_healthammokit"
		"item_healthkit_full" : "item_healthkit_full"
		"item_healthkit_medium" : "item_healthkit_medium"
		"item_healthkit_small" : "item_healthkit_small"
		"item_powerup_crit" : "item_powerup_crit"
		"item_powerup_rune" : "item_powerup_rune"
		"item_powerup_rune_temp" : "item_powerup_rune_temp"
		"item_powerup_uber" : "item_powerup_uber"
		"item_sodacan" : "item_sodacan"
		"item_teamflag" : "item_teamflag"
		"item_teamflag_return_icon" : "item_teamflag_return_icon"
		"keyframe_rope" : "keyframe_rope"
		"keyframe_track" : "keyframe_track"
		"light" : "light"
		"light_dynamic" : "light_dynamic"
		"light_environment" : "light_environment"
		"light_glspot" : "light_glspot"
		"light_spot" : "light_spot"
		"logic_active_autosave" : "logic_active_autosave"
		"logic_auto" : "logic_auto"
		"logic_autosave" : "logic_autosave"
		"logic_branch" : "logic_branch"
		"logic_branch_listener" : "logic_branch_listener"
		"logic_case" : "logic_case"
		"logic_choreographed_scene" : "logic_choreographed_scene"
		"logic_collision_pair" : "logic_collision_pair"
		"logic_compare" : "logic_compare"
		"logic_lineto" : "logic_lineto"
		"logic_measure_movement" : "logic_measure_movement"
		"logic_multicompare" : "logic_multicompare"
		"logic_navigation" : "logic_navigation"
		"logic_proximity" : "logic_proximity"
		"logic_relay" : "logic_relay"
		"logic_scene_list_manager" : "logic_scene_list_manager"
		"logic_timer" : "logic_timer"
		"mapobj_cart_dispenser" : "mapobj_cart_dispenser"
		"material_modify_control" : "material_modify_control"
		"math_colorblend" : "math_colorblend"
		"math_counter" : "math_counter"
		"math_remap" : "math_remap"
		"merasmus" : "merasmus"
		"merasmus_dancer" : "merasmus_dancer"
		"momentary_door" : "momentary_door"
		"momentary_rot_button" : "momentary_rot_button"
		"monster_furniture" : "monster_furniture"
		"monster_generic" : "monster_generic"
		"monster_resource" : "monster_resource"
		"move_keyframed" : "move_keyframed"
		"move_rope" : "move_rope"
		"multisource" : "multisource"
		"npc_concussiongrenade" : "npc_concussiongrenade"
		"npc_contactgrenade" : "npc_contactgrenade"
		"npc_furniture" : "npc_furniture"
		"npc_handgrenade" : "npc_handgrenade"
		"npc_maker" : "npc_maker"
		"npc_template_maker" : "npc_template_maker"
		"npc_vehicledriver" : "npc_vehicledriver"
		"obj_attachment_sapper" : "obj_attachment_sapper"
		"obj_dispenser" : "obj_dispenser"
		"obj_sentrygun" : "obj_sentrygun"
		"obj_teleporter" : "obj_teleporter"
		"passtime_ball" : "passtime_ball"
		"passtime_logic" : "passtime_logic"
		"path_corner" : "path_corner"
		"path_corner_crash" : "path_corner_crash"
		"path_track" : "path_track"
		"pd_dispenser" : "pd_dispenser"
		"phys_ballsocket" : "phys_ballsocket"
		"phys_bone_follower" : "phys_bone_follower"
		"phys_constraint" : "phys_constraint"
		"phys_constraintsystem" : "phys_constraintsystem"
		"phys_convert" : "phys_convert"
		"phys_hinge" : "phys_hinge"
		"phys_keepupright" : "phys_keepupright"
		"phys_lengthconstraint" : "phys_lengthconstraint"
		"phys_magnet" : "phys_magnet"
		"phys_motor" : "phys_motor"
		"phys_pulleyconstraint" : "phys_pulleyconstraint"
		"phys_ragdollconstraint" : "phys_ragdollconstraint"
		"phys_ragdollmagnet" : "phys_ragdollmagnet"
		"phys_slideconstraint" : "phys_slideconstraint"
		"phys_spring" : "phys_spring"
		"phys_thruster" : "phys_thruster"
		"phys_torque" : "phys_torque"
		"physics_cannister" : "physics_cannister"
		"physics_entity_solver" : "physics_entity_solver"
		"physics_npc_solver" : "physics_npc_solver"
		"physics_prop" : "physics_prop"
		"physics_prop_ragdoll" : "physics_prop_ragdoll"
		"player" : "player"
		"player_loadsaved" : "player_loadsaved"
		"player_manager" : "player_manager"
		"player_speedmod" : "player_speedmod"
		"player_weaponstrip" : "player_weaponstrip"
		"point_anglesensor" : "point_anglesensor"
		"point_angularvelocitysensor" : "point_angularvelocitysensor"
		"point_bonusmaps_accessor" : "point_bonusmaps_accessor"
		"point_camera" : "point_camera"
		"point_clientcommand" : "point_clientcommand"
		"point_commentary_node" : "point_commentary_node"
		"point_commentary_viewpoint" : "point_commentary_viewpoint"
		"point_devshot_camera" : "point_devshot_camera"
		"point_enable_motion_fixup" : "point_enable_motion_fixup"
		"point_gamestats_counter" : "point_gamestats_counter"
		"point_hurt" : "point_hurt"
		"point_intermission" : "point_intermission"
		"point_message" : "point_message"
		"point_playermoveconstraint" : "point_playermoveconstraint"
		"point_populator_interface" : "point_populator_interface"
		"point_posecontroller" : "point_posecontroller"
		"point_proximity_sensor" : "point_proximity_sensor"
		"point_push" : "point_push"
		"point_servercommand" : "point_servercommand"
		"point_spotlight" : "point_spotlight"
		"point_teleport" : "point_teleport"
		"point_template" : "point_template"
		"point_tesla" : "point_tesla"
		"point_velocitysensor" : "point_velocitysensor"
		"point_viewcontrol" : "point_viewcontrol"
		"populator_internal_spawn_point" : "populator_internal_spawn_point"
		"prop_door_rotating" : "prop_door_rotating"
		"prop_dynamic" : "prop_dynamic"
		"prop_dynamic_ornament" : "prop_dynamic_ornament"
		"prop_dynamic_override" : "prop_dynamic_override"
		"prop_physics" : "prop_physics"
		"prop_physics_multiplayer" : "prop_physics_multiplayer"
		"prop_physics_override" : "prop_physics_override"
		"prop_physics_respawnable" : "prop_physics_respawnable"
		"prop_ragdoll" : "prop_ragdoll"
		"prop_ragdoll_attached" : "prop_ragdoll_attached"
		"prop_soccer_ball" : "prop_soccer_ball"
		"prop_sphere" : "prop_sphere"
		"prop_vehicle" : "prop_vehicle"
		"prop_vehicle_driveable" : "prop_vehicle_driveable"
		"raggib" : "raggib"
		"rd_robot_dispenser" : "rd_robot_dispenser"
		"rope_anchor" : "rope_anchor"
		"scene_manager" : "scene_manager"
		"scripted_scene" : "scripted_scene"
		"scripted_sentence" : "scripted_sentence"
		"scripted_sequence" : "scripted_sequence"
		"scripted_target" : "scripted_target"
		"shadow_control" : "shadow_control"
		"simple_bot" : "simple_bot"
		"simple_physics_brush" : "simple_physics_brush"
		"simple_physics_prop" : "simple_physics_prop"
		"sky_camera" : "sky_camera"
		"soundent" : "soundent"
		"spark_shower" : "spark_shower"
		"spotlight_end" : "spotlight_end"
		"spraycan" : "spraycan"
		"tank_boss" : "tank_boss"
		"tank_destruction" : "tank_destruction"
		"tanktrain_ai" : "tanktrain_ai"
		"tanktrain_aitarget" : "tanktrain_aitarget"
		"target_cdaudio" : "target_cdaudio"
		"target_changegravity" : "target_changegravity"
		"te_tester" : "te_tester"
		"team_control_point" : "team_control_point"
		"team_control_point_master" : "team_control_point_master"
		"team_control_point_round" : "team_control_point_round"
		"team_manager" : "team_manager"
		"team_round_timer" : "team_round_timer"
		"team_train_watcher" : "team_train_watcher"
		"teleport_vortex" : "teleport_vortex"
		"test_effect" : "test_effect"
		"test_proxytoggle" : "test_proxytoggle"
		"test_traceline" : "test_traceline"
		"tf_ammo_pack" : "tf_ammo_pack"
		"tf_base_minigame" : "tf_base_minigame"
		"tf_bonus_duck_pickup" : "tf_bonus_duck_pickup"
		"tf_bot" : "tf_bot"
		"tf_dropped_weapon" : "tf_dropped_weapon"
		"tf_flame" : "tf_flame"
		"tf_flame_manager" : "tf_flame_manager"
		"tf_gamerules" : "tf_gamerules"
		"tf_gas_manager" : "tf_gas_manager"
		"tf_generic_bomb" : "tf_generic_bomb"
		"tf_glow" : "tf_glow"
		"tf_halloween_gift_pickup" : "tf_halloween_gift_pickup"
		"tf_halloween_gift_spawn_location" : "tf_halloween_gift_spawn_location"
		"tf_halloween_minigame" : "tf_halloween_minigame"
		"tf_halloween_minigame_falling_platforms" : "tf_halloween_minigame_falling_platforms"
		"tf_halloween_pickup" : "tf_halloween_pickup"
		"tf_logic_arena" : "tf_logic_arena"
		"tf_logic_bonusround" : "tf_logic_bonusround"
		"tf_logic_competitive" : "tf_logic_competitive"
		"tf_logic_cp_timer" : "tf_logic_cp_timer"
		"tf_logic_holiday" : "tf_logic_holiday"
		"tf_logic_hybrid_ctf_cp" : "tf_logic_hybrid_ctf_cp"
		"tf_logic_koth" : "tf_logic_koth"
		"tf_logic_mann_vs_machine" : "tf_logic_mann_vs_machine"
		"tf_logic_mannpower" : "tf_logic_mannpower"
		"tf_logic_medieval" : "tf_logic_medieval"
		"tf_logic_minigames" : "tf_logic_minigames"
		"tf_logic_multiple_escort" : "tf_logic_multiple_escort"
		"tf_logic_on_holiday" : "tf_logic_on_holiday"
		"tf_logic_player_destruction" : "tf_logic_player_destruction"
		"tf_logic_robot_destruction" : "tf_logic_robot_destruction"
		"tf_logic_training_mode" : "tf_logic_training_mode"
		"tf_mann_vs_machine_stats" : "tf_mann_vs_machine_stats"
		"tf_merasmus_trick_or_treat_prop" : "tf_merasmus_trick_or_treat_prop"
		"tf_objective_resource" : "tf_objective_resource"
		"tf_pda_expansion_dispenser" : "tf_pda_expansion_dispenser"
		"tf_pda_expansion_teleporter" : "tf_pda_expansion_teleporter"
		"tf_player_manager" : "tf_player_manager"
		"tf_point_nav_interface" : "tf_point_nav_interface"
		"tf_point_weapon_mimic" : "tf_point_weapon_mimic"
		"tf_powerup_bottle" : "tf_powerup_bottle"
		"tf_projectile_arrow" : "tf_projectile_arrow"
		"tf_projectile_ball_ornament" : "tf_projectile_ball_ornament"
		"tf_projectile_balloffire" : "tf_projectile_balloffire"
		"tf_projectile_cleaver" : "tf_projectile_cleaver"
		"tf_projectile_energy_ball" : "tf_projectile_energy_ball"
		"tf_projectile_energy_ring" : "tf_projectile_energy_ring"
		"tf_projectile_flare" : "tf_projectile_flare"
		"tf_projectile_grapplinghook" : "tf_projectile_grapplinghook"
		"tf_projectile_healing_bolt" : "tf_projectile_healing_bolt"
		"tf_projectile_jar" : "tf_projectile_jar"
		"tf_projectile_jar_gas" : "tf_projectile_jar_gas"
		"tf_projectile_jar_milk" : "tf_projectile_jar_milk"
		"tf_projectile_lightningorb" : "tf_projectile_lightningorb"
		"tf_projectile_mechanicalarmorb" : "tf_projectile_mechanicalarmorb"
		"tf_projectile_pipe" : "tf_projectile_pipe"
		"tf_projectile_pipe_remote" : "tf_projectile_pipe_remote"
		"tf_projectile_rocket" : "tf_projectile_rocket"
		"tf_projectile_sentryrocket" : "tf_projectile_sentryrocket"
		"tf_projectile_spellbats" : "tf_projectile_spellbats"
		"tf_projectile_spellfireball" : "tf_projectile_spellfireball"
		"tf_projectile_spellkartbats" : "tf_projectile_spellkartbats"
		"tf_projectile_spellkartorb" : "tf_projectile_spellkartorb"
		"tf_projectile_spellmeteorshower" : "tf_projectile_spellmeteorshower"
		"tf_projectile_spellmirv" : "tf_projectile_spellmirv"
		"tf_projectile_spellpumpkin" : "tf_projectile_spellpumpkin"
		"tf_projectile_spellspawnboss" : "tf_projectile_spellspawnboss"
		"tf_projectile_spellspawnhorde" : "tf_projectile_spellspawnhorde"
		"tf_projectile_spellspawnzombie" : "tf_projectile_spellspawnzombie"
		"tf_projectile_spelltransposeteleport" : "tf_projectile_spelltransposeteleport"
		"tf_projectile_stun_ball" : "tf_projectile_stun_ball"
		"tf_projectile_syringe" : "tf_projectile_syringe"
		"tf_projectile_throwable" : "tf_projectile_throwable"
		"tf_projectile_throwable_breadmonster" : "tf_projectile_throwable_breadmonster"
		"tf_projectile_throwable_brick" : "tf_projectile_throwable_brick"
		"tf_projectile_throwable_repel" : "tf_projectile_throwable_repel"
		"tf_pumpkin_bomb" : "tf_pumpkin_bomb"
		"tf_ragdoll" : "tf_ragdoll"
		"tf_robot_destruction_robot" : "tf_robot_destruction_robot"
		"tf_robot_destruction_robot_spawn" : "tf_robot_destruction_robot_spawn"
		"tf_robot_destruction_spawn_group" : "tf_robot_destruction_spawn_group"
		"tf_spawner" : "tf_spawner"
		"tf_spell_meteorshowerspawner" : "tf_spell_meteorshowerspawner"
		"tf_spell_pickup" : "tf_spell_pickup"
		"tf_target_dummy" : "tf_target_dummy"
		"tf_taunt_prop" : "tf_taunt_prop"
		"tf_team" : "tf_team"
		"tf_teleport_location" : "tf_teleport_location"
		"tf_viewmodel" : "tf_viewmodel"
		"tf_weapon_base" : "tf_weapon_base"
		"tf_weapon_bat" : "tf_weapon_bat"
		"tf_weapon_bat_fish" : "tf_weapon_bat_fish"
		"tf_weapon_bat_giftwrap" : "tf_weapon_bat_giftwrap"
		"tf_weapon_bat_wood" : "tf_weapon_bat_wood"
		"tf_weapon_bonesaw" : "tf_weapon_bonesaw"
		"tf_weapon_bottle" : "tf_weapon_bottle"
		"tf_weapon_breakable_sign" : "tf_weapon_breakable_sign"
		"tf_weapon_buff_item" : "tf_weapon_buff_item"
		"tf_weapon_builder" : "tf_weapon_builder"
		"tf_weapon_cannon" : "tf_weapon_cannon"
		"tf_weapon_charged_smg" : "tf_weapon_charged_smg"
		"tf_weapon_cleaver" : "tf_weapon_cleaver"
		"tf_weapon_club" : "tf_weapon_club"
		"tf_weapon_compound_bow" : "tf_weapon_compound_bow"
		"tf_weapon_crossbow" : "tf_weapon_crossbow"
		"tf_weapon_drg_pomson" : "tf_weapon_drg_pomson"
		"tf_weapon_fireaxe" : "tf_weapon_fireaxe"
		"tf_weapon_fists" : "tf_weapon_fists"
		"tf_weapon_flamethrower" : "tf_weapon_flamethrower"
		"tf_weapon_flaregun" : "tf_weapon_flaregun"
		"tf_weapon_flaregun_revenge" : "tf_weapon_flaregun_revenge"
		"tf_weapon_grapplinghook" : "tf_weapon_grapplinghook"
		"tf_weapon_grenadelauncher" : "tf_weapon_grenadelauncher"
		"tf_weapon_handgun_scout_primary" : "tf_weapon_handgun_scout_primary"
		"tf_weapon_handgun_scout_secondary" : "tf_weapon_handgun_scout_secondary"
		"tf_weapon_invis" : "tf_weapon_invis"
		"tf_weapon_jar" : "tf_weapon_jar"
		"tf_weapon_jar_gas" : "tf_weapon_jar_gas"
		"tf_weapon_jar_milk" : "tf_weapon_jar_milk"
		"tf_weapon_katana" : "tf_weapon_katana"
		"tf_weapon_knife" : "tf_weapon_knife"
		"tf_weapon_laser_pointer" : "tf_weapon_laser_pointer"
		"tf_weapon_lunchbox" : "tf_weapon_lunchbox"
		"tf_weapon_lunchbox_drink" : "tf_weapon_lunchbox_drink"
		"tf_weapon_mechanical_arm" : "tf_weapon_mechanical_arm"
		"tf_weapon_medigun" : "tf_weapon_medigun"
		"tf_weapon_minigun" : "tf_weapon_minigun"
		"tf_weapon_parachute" : "tf_weapon_parachute"
		"tf_weapon_parachute_primary" : "tf_weapon_parachute_primary"
		"tf_weapon_parachute_secondary" : "tf_weapon_parachute_secondary"
		"tf_weapon_particle_cannon" : "tf_weapon_particle_cannon"
		"tf_weapon_passtime_gun" : "tf_weapon_passtime_gun"
		"tf_weapon_pda_engineer_build" : "tf_weapon_pda_engineer_build"
		"tf_weapon_pda_engineer_destroy" : "tf_weapon_pda_engineer_destroy"
		"tf_weapon_pda_spy" : "tf_weapon_pda_spy"
		"tf_weapon_pep_brawler_blaster" : "tf_weapon_pep_brawler_blaster"
		"tf_weapon_pipebomblauncher" : "tf_weapon_pipebomblauncher"
		"tf_weapon_pistol" : "tf_weapon_pistol"
		"tf_weapon_pistol_scout" : "tf_weapon_pistol_scout"
		"tf_weapon_raygun" : "tf_weapon_raygun"
		"tf_weapon_revolver" : "tf_weapon_revolver"
		"tf_weapon_robot_arm" : "tf_weapon_robot_arm"
		"tf_weapon_rocketlauncher" : "tf_weapon_rocketlauncher"
		"tf_weapon_rocketlauncher_airstrike" : "tf_weapon_rocketlauncher_airstrike"
		"tf_weapon_rocketlauncher_directhit" : "tf_weapon_rocketlauncher_directhit"
		"tf_weapon_rocketlauncher_fireball" : "tf_weapon_rocketlauncher_fireball"
		"tf_weapon_rocketpack" : "tf_weapon_rocketpack"
		"tf_weapon_sapper" : "tf_weapon_sapper"
		"tf_weapon_scattergun" : "tf_weapon_scattergun"
		"tf_weapon_sentry_revenge" : "tf_weapon_sentry_revenge"
		"tf_weapon_shotgun_building_rescue" : "tf_weapon_shotgun_building_rescue"
		"tf_weapon_shotgun_hwg" : "tf_weapon_shotgun_hwg"
		"tf_weapon_shotgun_primary" : "tf_weapon_shotgun_primary"
		"tf_weapon_shotgun_pyro" : "tf_weapon_shotgun_pyro"
		"tf_weapon_shotgun_soldier" : "tf_weapon_shotgun_soldier"
		"tf_weapon_shovel" : "tf_weapon_shovel"
		"tf_weapon_slap" : "tf_weapon_slap"
		"tf_weapon_smg" : "tf_weapon_smg"
		"tf_weapon_sniperrifle" : "tf_weapon_sniperrifle"
		"tf_weapon_sniperrifle_classic" : "tf_weapon_sniperrifle_classic"
		"tf_weapon_sniperrifle_decap" : "tf_weapon_sniperrifle_decap"
		"tf_weapon_soda_popper" : "tf_weapon_soda_popper"
		"tf_weapon_spellbook" : "tf_weapon_spellbook"
		"tf_weapon_stickbomb" : "tf_weapon_stickbomb"
		"tf_weapon_sword" : "tf_weapon_sword"
		"tf_weapon_syringegun_medic" : "tf_weapon_syringegun_medic"
		"tf_weapon_wrench" : "tf_weapon_wrench"
		"tf_weaponbase_grenade_proj" : "tf_weaponbase_grenade_proj"
		"tf_weaponbase_melee" : "tf_weaponbase_melee"
		"tf_weaponbase_merasmus_grenade" : "tf_weaponbase_merasmus_grenade"
		"tf_wearable" : "tf_wearable"
		"tf_wearable_campaign_item" : "tf_wearable_campaign_item"
		"tf_wearable_demoshield" : "tf_wearable_demoshield"
		"tf_wearable_levelable_item" : "tf_wearable_levelable_item"
		"tf_wearable_razorback" : "tf_wearable_razorback"
		"tf_wearable_robot_arm" : "tf_wearable_robot_arm"
		"tf_wearable_vm" : "tf_wearable_vm"
		"tf_zombie" : "tf_zombie"
		"tf_zombie_spawner" : "tf_zombie_spawner"
		"training_annotation" : "training_annotation"
		"training_prop_dynamic" : "training_prop_dynamic"
		"trigger" : "trigger"
		"trigger_add_or_remove_tf_player_attributes" : "trigger_add_or_remove_tf_player_attributes"
		"trigger_add_tf_player_condition" : "trigger_add_tf_player_condition"
		"trigger_apply_impulse" : "trigger_apply_impulse"
		"trigger_autosave" : "trigger_autosave"
		"trigger_bot_tag" : "trigger_bot_tag"
		"trigger_brush" : "trigger_brush"
		"trigger_capture_area" : "trigger_capture_area"
		"trigger_catapult" : "trigger_catapult"
		"trigger_cdaudio" : "trigger_cdaudio"
		"trigger_changelevel" : "trigger_changelevel"
		"trigger_gravity" : "trigger_gravity"
		"trigger_hurt" : "trigger_hurt"
		"trigger_ignite" : "trigger_ignite"
		"trigger_ignite_arrows" : "trigger_ignite_arrows"
		"trigger_impact" : "trigger_impact"
		"trigger_look" : "trigger_look"
		"trigger_multiple" : "trigger_multiple"
		"trigger_once" : "trigger_once"
		"trigger_particle" : "trigger_particle"
		"trigger_passtime_ball" : "trigger_passtime_ball"
		"trigger_player_respawn_override" : "trigger_player_respawn_override"
		"trigger_playermovement" : "trigger_playermovement"
		"trigger_proximity" : "trigger_proximity"
		"trigger_push" : "trigger_push"
		"trigger_rd_vault_trigger" : "trigger_rd_vault_trigger"
		"trigger_remove" : "trigger_remove"
		"trigger_remove_tf_player_condition" : "trigger_remove_tf_player_condition"
		"trigger_serverragdoll" : "trigger_serverragdoll"
		"trigger_soundscape" : "trigger_soundscape"
		"trigger_stun" : "trigger_stun"
		"trigger_teleport" : "trigger_teleport"
		"trigger_teleport_relative" : "trigger_teleport_relative"
		"trigger_timer_door" : "trigger_timer_door"
		"trigger_togglesave" : "trigger_togglesave"
		"trigger_transition" : "trigger_transition"
		"trigger_vphysics_motion" : "trigger_vphysics_motion"
		"trigger_wind" : "trigger_wind"
		"vgui_screen" : "vgui_screen"
		"vgui_screen_team" : "vgui_screen_team"
		"vgui_slideshow_display" : "vgui_slideshow_display"
		"viewmodel" : "viewmodel"
		"vote_controller" : "vote_controller"
		"water_lod_control" : "water_lod_control"
		"waterbullet" : "waterbullet"
		"weapon_ifm_base" : "weapon_ifm_base"
		"weapon_ifm_base_camera" : "weapon_ifm_base_camera"
		"weapon_ifm_steadycam" : "weapon_ifm_steadycam"
		"wearable_item" : "wearable_item"
		"wheel_of_doom" : "wheel_of_doom"
		"wheel_of_doom_spiral" : "wheel_of_doom_spiral"
		"window_pane" : "window_pane"
		"world_items" : "world_items"
		"worldspawn" : "worldspawn"
	] // end filterclass
] // end filter_activator_class

@FilterClass base(SBaseFilter) color(255 100 150) iconsprite("editor-ficool2/filter_activator_mass_greater") = filter_activator_mass_greater : "A filter that filters by the mass of the activator." [
	Negated(choices) : "Filter Mode" : 0 : "Whether the activator's mass must be greater than or less than the specified value." = [
		0 : "Allow if Greater Than"
		1 : "Allow if Less Than" // TODO: Which of these is equal to?
	] // end Negated

	filtermass(float) : "Mass Amount" : "0.0" : "The mass amount to compare against."
] // end filter_activator_mass_greater

@FilterClass base(SBaseFilter) color(255 100 150) iconsprite("editor-ficool2/filter_activator_name") = filter_activator_name : "A filter that filters by the name of the activator.\n" +
	"TIP: Entities can have their targetname changed with AddOutput, which can be used to alter their eligibility against this filter." [
	filtername(target_destination) : "Name to Filter" :  : "The name to filter by. Wildcards are accepted. If blank, filters for entities with no targetname. If set to !player, filters for players."
] // end filter_activator_name

@FilterClass base(SBaseFilter) color(255 100 150) iconsprite("editor-ficool2/filter_activator_team") = filter_activator_team : "A filter that filters by the team of the activator. Functions as a more rudimentary version of filter_activator_tfteam." [
	filterteam(choices) : "Team" : 2 : "The team number to filter for." = [
		0 : "0 - Any/Unassigned"
		1 : "1 - Spectator"
		2 : "2 - RED"
		3 : "3 - BLU"
		5 : "5 - Neutral/Boss"
	] // end filterteam
] // end filter_activator_team

@FilterClass base(SBaseFilter, STFTeam, SControlPoint) color(255 100 150) iconsprite("editor-ficool2/filter_activator_tfteam") = filter_activator_tfteam : "A filter that filters by the team of the activator.\n" +
	"NOTE: During the humiliation period, the winning team will ALWAYS pass this filter, even if the team number does not match or the filter is Negated. filter_activator_team does not exhibit this behavior." + [
	//input RoundSpawn(void) : "Forces this entity to spawn. Fired automatically at the start of a round."
	//input RoundActivate(void) : "Forces this entity to activate. Fired automatically at the start of a round."
] // end filter_activator_tfteam

@FilterClass base(SBaseFilter) color(255 100 150) iconsprite("editor-ficool2/filter_base") = filter_base : "This filter defines the common functionality shared by all filter types. This entity technically can't filter anything on its own, instead always giving a constant result regardless of what is tested against it.\n" +
	"TIP: By changing this entity's Negated keyvalue with AddOutput and combining it with other filters via filter_multi, this entity can be used to 'turn on' or 'turn off' other filters, which can be used to dynamically change a trigger's filter criteria at runtime." [
	Negated(choices) : "Filter Mode" : 0 : "What result will be returned when an entity is tested against this filter." = [
		0 : "Always Pass"
		1 : "Always Fail"
	] // end Negated
] // end filter_base

// "Does not function in Team Fortress 2" my fall-damage-immune ASS, ficool!
// TODO: If multiple damage types are combined, are they combined in an AND gate or OR gate?
@FilterClass base(SBaseFilter, SDamageTypes) color(255 100 150) iconsprite("editor-abs/filter_damage_type")  = filter_damage_type : "A damage filter that filters by the type of damage inflicted. This can only be used as a damage filter, not as an activator filter." [
]

@FilterClass base(SBaseFilter) color(255 100 150) iconsprite("editor-ficool2/filter_enemy") sphere(filter_radius) sphere(filter_outer_radius) = filter_enemy : "A filter that filters an entity by various criteria.\n" +
	"BUG: Due to poor coding, negating the filter does not actually negate it's results, but instead invokes various other, strange behaviors (documented below). To properly negate this entity's criteria, include this entity in a filter_multi.\n" +
	"TIP: Despite it's name, this entity can be used as a normal filter. However, it CANNOT be used as a damage filter. When this entity is used as a trigger filter, the !caller is the trigger itself." [
	Negated(choices) : "Filter Mode" : 0 : "How this entity should combine the results of its tests. Some other things also behave slightly differently based on whether this filter is in 'OR-AND' mode or 'AND-OR' mode." = [
		0 : "Name OR (Proximity AND Squadmates)"
		1 : "Name AND (Proximity OR Squadmates)"
	] // end Negated

	filtername(target_name_or_class) : "Name/Class to Exclude" :  : "If not blank, entities with matching classnames or targetnames will FAIL the Name test. '!player' is also accepted. The Name test always passes if this is blank."
	filter_radius(float) : "Radius 1" : "0.0" : "If nonzero, tested entity must be within the specified distance of the !caller's origin to PASS the Proximity test. If the entity is already the !caller's enemy OR this filter is in AND-OR mode (but NOT BOTH), the larger of the two range values is used. Otherwise, the smaller of these two is used. The Proximity test always passes if this is zero."
	filter_outer_radius(float) : "Radius 2" : "0.0" : "If Radius 1 is nonzero, tested entity must be within range of the !caller to PASS the Proximity test. If this is zero and the filter is in OR-AND mode, this defaults to Radius 1 doubled. If this is zero and the filter is in AND-OR mode, this defaults to half of Radius 1."
	filter_max_per_enemy(integer) : "Max Squadmates per Enemy" : 0 : "If at least this many of the !caller's squadmates currently consider the tested entity to be their enemy, the Squadmates test will FAIL. The Squadmates test always passes if this is zero."

	spawnflags(flags) = [
		1 : "Do Not Lose Target - Always pass (or fail, if in AND-OR mode) if the tested entity is already the !caller's enemy" : 0
	] // end spawnflags
] // end filter_enemy

@FilterClass base(SBaseFilter) color(255 100 150) iconsprite("editor-ficool2/filter_multi") = filter_multi : "A filter that tests against multiple filters. This allows you to build more complex filters, such as 'Allow anyone on Red team who is also an Engineer', or 'Allow everyone except classes npc_zombie and npc_headcrab'." [
	Negated(choices) : "Negate Outcome?" : 0 : "Whether to negate the result of this filter, AFTER testing all specified filters and comparing them with the Logic Type. Negating the outcome using the AND logic type means that ANY specified filter must fail for this filter to pass. Negating the outcome using the OR logic type means that ALL specified filters must fail for this filter to pass." = [
		0 : "No"
		1 : "Yes"
	] // end Negated

	filtertype(choices) : "Logic Type" : 0 : " How this entity should combine the results of each specified filter. If AND, all specified filters must pass for this filter to pass. If OR, at least one of the specified filters must pass for this filter to pass." = [
		0 : "AND (all filters must pass)"
		1 : "OR (any filter must pass)"
	] // end filtertype
	Filter01(filterclass) : "Filter 1" :  : "Filter to test."
	Filter02(filterclass) : "Filter 2" :  : "Filter to test."
	Filter03(filterclass) : "Filter 3" :  : "Filter to test."
	Filter04(filterclass) : "Filter 4" :  : "Filter to test."
	Filter05(filterclass) : "Filter 5" :  : "Filter to test."
] // end filter_multi

@FilterClass base(SBaseFilter) color(255 100 150) iconsprite("editor-ficool2/filter_tf_bot_has_tag")= filter_tf_bot_has_tag : "A filter that filters based on a bot having specific tags." [
	tags(string) : "Tags" :  : "Space-delimited list of tags to filter by. This entity does not check automatic tags (see func_nav_avoid); this entity only reads tags that were explicitly added in the popfile or using trigger_bot_tag."
	require_all_tags(choices) : "Require All Tags?" : 1 : "Does this filter require all specified tags to match or just one of them? If set to No while in Disallow mode, then the filter passes if the bot has none of these tags. If set to Yes while in Disallow mode, then the filter passes if the bot is missing at least one tag." = [
		0 : "No"
		1 : "Yes"
	] // end require_all_tags
] // end filter_tf_bot_has_tag

@FilterClass base(SBaseFilter) color(255 100 150) iconsprite("editor-ficool2/filter_tf_class") = filter_tf_class : "A filter that filters by the player class of the activating player.\n" +
	"NOTE: This filters for player classes such as Scout and Heavy, NOT for entity classes like trigger_multiple. To filter for entity classes, use filter_activator_class." [
	tfclass(choices) : "Class to Filter" :  : "The player class to filter for." = [
		//wtf is this class order -Brokk
		1 : "Scout"
		3 : "Soldier"
		7 : "Pyro"
		4 : "Demoman"
		6 : "Heavy"
		9 : "Engineer"
		5 : "Medic"
		2 : "Sniper"
		8 : "Spy"
	] // end tfclass
] // end filter_tf_class

@FilterClass base(SBaseFilter, STFConditions) color(255 100 150) iconsprite("editor-ficool2/filter_tf_condition") = filter_tf_condition : "A filter that filters by conditions on a player." [
] // end filter_tf_condition

@FilterClass base(SBaseFilter) color(255 100 150) iconsprite("editor-ficool2/filter_tf_damaged_by_weapon_in_slot") = filter_tf_damaged_by_weapon_in_slot : "A filter that filters damage by the weapon slot used by the player to deal the damage." [
	weaponSlot(choices) : "Weapon Slot" : 0 : "Weapon slot to filter for." = [
		0 : "Primary"
		1 : "Secondary"
		2 : "Melee"
		3 : "Grenade"
		4 : "Building"
		5 : "PDA"
		6 : "Item 1"
		7 : "Item 2"
	] // end weaponSlot
] // end filter_tf_damaged_by_weapon_in_slot

@FilterClass base(SBaseFilter, STFTeam) color(255 100 150) iconsprite("editor-ficool2/filter_tf_player_can_cap")  = filter_tf_player_can_cap : "A filter that filters for players allowed to capture objectives. The criteria for such is as follows:\n" +
	"-The player is not disguised (TF_COND_DISGUISING or TF_COND_DISGUISED).\n" +
	"-The player is not cloaked (TF_COND_STEALTHED, TF_COND_STEALTHED_USER_BUFF, or TF_COND_STEALTHED_USER_BUFF_FADING).\n" +
	"-The player is not ubercharged (TF_COND_INVULNERABLE, TF_COND_INVULNERABLE_WEARINGOFF, TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED, TF_COND_INVULNERABLE_USER_BUFF, or TF_COND_INVULNERABLE_CARD_EFFECT).\n" +
	"If the Filter Mode is Allow, only players whose team matches the filter's team (if specified) and do NOT have any of the above conditions will be allowed. If the Filter Mode is Disallow, all entities EXCEPT those players will be allowed." [
] // end filter_tf_player_can_cap



	// FUNC ENTITIES //

@PointClass base(SModel, SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/func_fish_pool") sphere(max_range) studioprop() = func_fish_pool : "Creates a school of interactive fish that swim near this entity on the Y axis only. Killing the func_fish_pool does not delete the fish, the fish entity can be killed as a workaround. However, killing the fish entity before killing the func_fish_pool entity crashes the game; the func_fish_pool entity must be killed first." [
	model(studio) : "Fish Model" :  : "The model used by fish entities."

	fish_count(integer) : "Fish Count" : 10 : "Number of fish in this pool."
	max_range(float) : "Max Range (1 - 255)" : 150 : "How far away a fish can wander, maximum is 255 units."
] // end func_fish_pool

// NOTE FROM FICOOL2: valve... valve!!!!!!!!!
// Yea, that's literally all he wrote. Thanks ficool, sure would like to know what that means but eh, hopefully its not important.. right?
@PointClass base(SClassDiv1, SAngles, SBaseDiv) color(200 200 0) instance() size(-8 -8 -8, 8 8 8) = func_instance : "An entity for placing an instance of another map inside your current map. You may translate and rotate this entity, and (most) objects in the instance will be translated accordingly. Any parameters in the instance VMF will automatically appear at the top of this entity's kevalues to be filled in." [
	file(instance_file) : "VMF Filename" :  : "The map file (VMF) to insert as an instance. By default, this looks for VMFs relative to your gameinfo.txt's InstancePath. The Browse option will only fill in this keyvalue if the selected VMF is within your InstancePath folder or in a subfolder of such. VMFs can also be manually specified relative to the base map file's location, or an absolute path can be specified."
	fixup_style(Choices) : "Entity Name Fix-Up Style" : 2 : "Fixup style for instanced entity names. 'Prefix' means the Fix Up Name will be added to the beginning of each targetname. 'Postfix' means the Fix Up Name will be appended to the end of each targetname. 'None' means no name fix-up will occur." = [
		2 : "None"
		0 : "Prefix"
		1 : "Postfix"
	] // end fixup_style
	targetname(target_source) : "Fix-Up Name" :  : "The name that all entities will be fixed up with based upon the fix up style. Uses 'InstanceAutoXX' if unspecified, where XX is replaced with a unique integer."
	replace01(instance_variable) : "Replace" :  : "This is a replacement parameter.  It goes in the form of $variable value  All entities inside of this instance that have $variable somewhere will be replaced with the value contents. Example: $color 255 0 0"
	replace02(instance_variable) : "Replace" :  : "This is a replacement parameter.  It goes in the form of $variable value. All entities inside of this instance that have $variable somewhere will be replaced with the value contents. Example: $color 255 0 0"
	replace03(instance_variable) : "Replace" :  : "This is a replacement parameter.  It goes in the form of $variable value. All entities inside of this instance that have $variable somewhere will be replaced with the value contents. Example: $color 255 0 0"
	replace04(instance_variable) : "Replace" :  : "This is a replacement parameter.  It goes in the form of $variable value. All entities inside of this instance that have $variable somewhere will be replaced with the value contents. Example: $color 255 0 0"
	replace05(instance_variable) : "Replace" :  : "This is a replacement parameter.  It goes in the form of $variable value. All entities inside of this instance that have $variable somewhere will be replaced with the value contents. Example: $color 255 0 0"
	replace06(instance_variable) : "Replace" :  : "This is a replacement parameter.  It goes in the form of $variable value. All entities inside of this instance that have $variable somewhere will be replaced with the value contents. Example: $color 255 0 0"
	replace07(instance_variable) : "Replace" :  : "This is a replacement parameter.  It goes in the form of $variable value. All entities inside of this instance that have $variable somewhere will be replaced with the value contents. Example: $color 255 0 0"
	replace08(instance_variable) : "Replace" :  : "This is a replacement parameter.  It goes in the form of $variable value. All entities inside of this instance that have $variable somewhere will be replaced with the value contents. Example: $color 255 0 0"
	replace09(instance_variable) : "Replace" :  : "This is a replacement parameter.  It goes in the form of $variable value. All entities inside of this instance that have $variable somewhere will be replaced with the value contents. Example: $color 255 0 0"
	replace10(instance_variable) : "Replace" :  : "This is a replacement parameter.  It goes in the form of $variable value. All entities inside of this instance that have $variable somewhere will be replaced with the value contents. Example: $color 255 0 0"
] // end func_instance

@PointClass iconsprite("editor-ficool2/func_instance_parms") color(200 200 0) = func_instance_parms : "A list of $variable parameters available when using this VMF as an instance in another VMF. Place one copy of this entity inside of the instance VMF. Whenever you add a $variable to an entity's properties, it will automatically appear in here." [
	parm1(instance_parm) : "Parm" :  : "This is a parameter. It goes in the form of $variable type."
	parm2(instance_parm) : "Parm" :  : "This is a parameter. It goes in the form of $variable type."
	parm3(instance_parm) : "Parm" :  : "This is a parameter. It goes in the form of $variable type."
	parm4(instance_parm) : "Parm" :  : "This is a parameter. It goes in the form of $variable type."
	parm5(instance_parm) : "Parm" :  : "This is a parameter. It goes in the form of $variable type."
	parm6(instance_parm) : "Parm" :  : "This is a parameter. It goes in the form of $variable type."
	parm7(instance_parm) : "Parm" :  : "This is a parameter. It goes in the form of $variable type."
	parm8(instance_parm) : "Parm" :  : "This is a parameter. It goes in the form of $variable type."
	parm9(instance_parm) : "Parm" :  : "This is a parameter. It goes in the form of $variable type."
	parm10(instance_parm) : "Parm" :  : "This is a parameter. It goes in the form of $variable type."
] // end func_instance_parms

@PointClass color(200 200 0) = func_instance_origin : "Slartibarty compile tools only. This is used as the center of an instance for positioning and rotation, overriding the actual origin of the instance." [
] // end func_instance_origin



	// GAME ENTITIES //

//Does this actually work? Let's do a little trolling -Brokk
@PointClass base(SBaseLogical) color(100 150 255) iconsprite("editor-ficool2/game_end") = game_end : "An entity that ends a multiplayer game. In Team Fortress 2, this freezes all players, shows the scoreboard, and after a few seconds, forces a map change. To end a round normally with a winner, use game_round_win." [
	//master(string) : "Master" :  : "Half-Life legacy support: The name of a multisource entity. If the master hasn't been activated, this entity will not activate."

	input EndGame(void) : "End the multiplayer game."
] // end game_end

@PointClass base(SBaseLogical) color(100 150 255) iconsprite("editor-abs/game_forcerespawn")  = game_forcerespawn : "Removes buildings, grenades, etc., from the world and forces all players to respawn, without being killed." [
	input ForceRespawn(void) : "Force players to respawn and remove buildings, grenades, etc., from the world."
	input ForceRespawnSwitchTeams(void) : "Switch all players to the opposite team, and then respawn all players (and remove buildings, grenades, etc., from the world)."
	input ForceTeamRespawn(integer) : "Force players on a specific team to respawn, but only if they are currently dead. 2 for Red, 3 for Blue. This does NOT remove buildings, grenades, etc., from the world..."

	output OnForceRespawn(void) : "Sent when the entity respawns players."
] // end game_forcerespawn

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/game_gib_manager") = game_gib_manager : "An entity to control the number of gibs in the world, for performance reasons." [
	maxpieces(integer) : "Max Gib Count" : -1 : "Sets the max number of gib that can be spawned at a time (-1 = no limit)."
	maxpiecesdx8(integer) : "Max Gib Count On DirectX 8" : -1 : "Sets the max number of gib that can be spawned at a time under DirectX 8 (-1 = use Max Gib Count setting)."
	allownewgibs(choices) : "Allow New Gibs To Spawn?" : 0 : "If true, when the max gib count is reached, oldest gibs are removed as new gibs spawn. If false, new gibs will not be spawned once the gib limit is reached." = [
		0 : "No"
		1 : "Yes"
	] // end allownewgibs

	input SetMaxPieces(integer) : "Set the max gib count."
	input SetMaxPiecesDX8(integer) : "Set the max gib count under DirectX 8."
] // end game_gib_manager

@PointClass base(SDoesNotFunction, SBaseEntity, SBaseDiv, STFTeam) iconsprite("editor/obsolete") = game_intro_viewpoint : "Creates a camera from whose perspective you get images displayed as long as you have no team joined. With several game_intro_viewpoints, all appear for a certain time in turn. Does not work correctly, use info_observer_point instead." [ // studioprop("models/editor/camera.mdl")
	step_number(integer) : "Step Number. Intro starts at 1." : 1 : "The number of viewpoints in the series of all game_intro_viewpoints. These are displayed in sequence."
	time_delay(float) : "Time to spend here." : 12 : "The time that the image should be displayed before the next one comes."
	hint_message(string) : "Hint Message here." :  : "A message appears with the image."
	event_to_fire(string) : "Game Event to Fire" :  : ""
	event_delay(float) : "Game Event fire Delay" : 3 : ""
	event_data_int(integer) : "Game Event Data" : 0 : ""
	fov(float) : "FOV" : 0 : "Maximum angle between the peripherals of the camera's vision."
] // end game_intro_viewpoint

@PointClass base(SBaseLogical) color(100 150 255) iconsprite("editor-ficool2/game_player_equip") = game_player_equip : "An entity which spawns other entities at a player's location. To use this entity, disable SmartEdit to add new keyvalues to this entity. The key name should be the classname of the entity to spawn, and the value is the number of times to spawn that item. If the 'Use Only' spawnflag is not checked, the entities will be spawned at a player every time they spawn into the game.\n" +
	"TIP: This entity can be used to spawn any entity class, not just weapons or equippables." [
	//"NOTE: obj_sentrygun, obj_dispenser and obj_teleporter can be given to players with this entity, and possibly other entities such as projectiles."
	spawnflags(flags) = [
		1 : "Use Only - Don't spawn these entities every time a player spawns" : 1
	] // end spawnflags

	input Use(void) : "Causes this entity to give the activating player weapons. BUG: Crashes the game if the !activator is null."
] // end game_player_equip

// TODO: Test
@PointClass base(SDoesNotFunction, SBaseLogical) color(100 150 255) iconsprite("editor/obsolete") = game_player_team : "An entity that changes the team of the player who activates it. An alternative is firing SetTeam <team number> on the !activator." [ // iconsprite("editor-ficool2/game_player_team")
	//master(string) : "Master (Obsolete)" : : "Half-Life legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."

	// entity does not exist so this can't be used
	//target(string) : "game_team_master to use"

	spawnflags(flags) = [
		1 : "Remove on Fire" : 0
		2 : "Kill Player" : 0
		4 : "Gib Player" : 0
	] // end spawnflags
] // end game_player_team

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/game_ragdoll_manager") = game_ragdoll_manager : "An entity to control the number of ragdolls in the world, for performance reasons." [
	MaxRagdollCount(integer) : "Max Ragdoll Count" : -1 : "Sets the max number of ragdolls that can be in the world at a time (if they are flagged to fade). Set to -1 to use the value in the convar g_ragdoll_maxcount (defaults to 8)."
	MaxRagdollCountDX8(integer) : "Max Ragdoll Count DX8" : -1 : "Sets the max number of ragdolls that can be in the world at a time on DirectX 8 hardware (if they are flagged to fade). Set to -1 to use the 'Max Ragdoll Count' value."
	//SaveImportant(choices) : "Save Important Ragdolls?" : 0 : "Should the ragdoll manager make sure ally ragdolls aren't deleted?" = [
	//	0 : "No"
	//	1 : "Yes"
	//] // end SaveImportant

	input SetMaxRagdollCount(integer) : "Set the Max Ragdoll Count."
	input SetMaxRagdollCountDX8(integer) : "Set the Max Ragdoll Count on DirectX 8 hardware."
] // end game_ragdoll_manager

@PointClass base(SBaseLogical, SBaseDiv, STFTeam) color(100 150 255) iconsprite("editor-abs/game_round_win") = game_round_win : "Used to manually tell the game rules that the round has either been won (if a team is assigned) or to enter Sudden Death mode (if no team is assigned)." [
	win_reason(choices) : "Win Reason" : 4 : "Sets the reason for the win, which is localized and displayed on the HUD. Some win reasons may trigger special behavior. For stalemates, the win reason is always 'You're all losers' regardless of this setting. Only win reasons listed in the dropdown are usable; custom text or other localized strings do not work." = [
		0 : "(blank)" // WINREASON_NONE
		5 : "You're all losers" // WINREASON_STALEMATE
		1 : "'<TEAM> captured all control points' / '<TEAM> won the payload race'" // WINREASON_ALL_POINTS_CAPTURED
		4 : "<TEAM> successfully defended until time ran out" // WINREASON_DEFEND_UNTIL_TIME_LIMIT
		3 : "<TEAM> captured the enemy intelligence <captures> time(s)" // WINREASON_FLAG_CAPTURE_LIMIT
		2 : "<TEAM> killed all opponents during sudden death" // WINREASON_OPPONENTS_DEAD
		6 : "<TEAM> had more points when the time limit was reached" // WINREASON_TIMELIMIT
		7 : "<TEAM> had more points when the win limit was reached" // WINREASON_WINLIMIT
		8 : "<TEAM> was ahead by the required difference to win" // WINREASON_WINDIFFLIMIT
		9 : "<TEAM> won by capturing the enemy reactor core" // WINREASON_RD_REACTOR_CAPTURED
		10 : "<TEAM> won by destroying robots and collecting power cores" // WINREASON_RD_CORES_COLLECTED
		11 : "<TEAM> won by defending their reactor core until it returned" // WINREASON_RD_REACTOR_RETURNED
		12 : "<TEAM> won by collecting enough points" // WINREASON_PD_POINTS
		13 : "<TEAM> won by scoring [<score> times]" // WINREASON_SCORED
		14 : "<TEAM 1> continues to set the pace in the next round! Can <TEAM 2> stop them?!" // WINREASON_STOPWATCH_WATCHING_ROUNDS
		15 : "Now <TEAM 2> gets their chance! Can they do better than <TEAM 1>?!" // WINREASON_STOPWATCH_WATCHING_FINAL_ROUND
		16 : "<TEAM 1> advances to the next round while they challenge the performance set by <TEAM 2>!" // WINREASON_STOPWATCH_PLAYING_ROUNDS
	] // end win_reason

	force_map_reset(choices) : "Force Map Reset?" : 1 : "Whether to reset the map between rounds. If set to No, all entity states will be preserved from this round into the next, and logic_auto will not fire any outputs on the start of the new round. BUG: If set to No, and this entity receives RoundWin while its team does not own all the control points, the game will crash." = [
		0 : "No"
		1 : "Yes"
	] // end force_map_reset
	switch_teams(choices) : "Switch Teams?" : 0 : "Whether to switch the teams after the round restart. Has no effect if Force Map Reset is set to No." = [
		0 : "No"
		1 : "Yes"
	] // end switch_teams

	input RoundWin(void) : "Win the round for this entity's team."

	output OnRoundWin(void) : "Fired when this entity receives the RoundWin input."
] // end game_round_win

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/game_score") = game_score : "An entity that awards/deducts points from the player who activates it. If the Team Points spawnflag is unchecked, the points are added to the !activator's kill count without affecting their actual score." [
	points(integer) : "Points to Add" : 1 : "Number of points to add/remove to/from the player."
	//master(string) : "Master" : : "Half-Life legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."

	spawnflags(flags) = [
		1: "Allow Negative" : 1
		2: "Team Points" : 0
	] // end spawnflags

	input ApplyScore(void) : "Add score to the !activator (or the !activator's team, if Team Points is selected)."
] // end game_score

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/game_text") = game_text : "An entity that displays text on player's screens." [
	message(string) : "Message Text" :  : "Message to display onscreen, can be either raw text or a localized string. Can be changed with AddOutput. A backslash followed by the letter 'n' signifies a new line in the text."
	x(string) : "X (0.0 - 1.0 = left - right)" : "-1" : "Horizontal position on the player's screens to draw the text. The value should be between 0 and 1, where 0 is the far left of the screen and 1 is the far right. -1 centers the text."
	y(string) : "Y (0.0 - 1.0 = top - bottom)" : "-1" : "Vertical position on the player's screens to draw the text. The value should be between 0 and 1, where 0 is the top of the screen and 1 is the bottom. -1 centers the text."
	effect(Choices) : "Text Effect" : 0 : "Effect to use when showing/hiding text. Scan In causes each character to be faded in one-by-one." = [
		0 : "Fade In/Out"
		//1 : "Credits (nonfunctional; functions identically to Fade In/Out)"
		2 : "Scan In/Fade Out"
	] // end effect
	color(color255) : "Text Color" : "255 0 0" : "Color that the text is displayed in. Text is displayed additively, so dark text colors may be difficult to see while black is fully invisible."
	color2(color255) : "Text Scan Color" : "240 110 0" : "Color used by the 'Scan In' effect. Each character will initially fade in as this color, then crossfade to the Text Color over the course of the Scan Time."
	fadein(float) : "Fade in Time" : "0.5" : "The time it should take for the text to fade in. If using the 'Scan In' effect, this is the time it takes for each individual character to fade in."
	fxtime(float) : "Scan Time" : "0.25" : "'Scan In' effect only. This is the time it takes for each individual character to crossfade from the Text Scan Color to the Text Color. The crossfade does not start until the character has fully faded in."
	holdtime(float) : "Hold Time" : "5" : "The time the text should stay onscreen, after fading in, before it begins to fade out. This does not take into account the Scan Time; if the 'Scan In' effect is set, this timer starts once the Fade in Time has expired for the last character."
	fadeout(float) : "Fade Out Time" : "0.5" : "The time it should take for the text to fade out, after the Hold Time has expired."
	channel(choices) : "Text Channel" : 1 : "You can have up to six individual game_text messages onscreen at once, stored in channels. Select which channel this text should be placed in. When told to Display, this entity will overwrite any active message already in that channel." = [
		0 : "Channel 0"
		1 : "Channel 1"
		2 : "Channel 2"
		3 : "Channel 3"
		4 : "Channel 4"
		5 : "Channel 5"
	] // end channel
	//master(string) : "Master" : : "Half-Life legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."

	spawnflags(flags) = [
		1: "Display to All Players - Otherwise just the !activator" : 1
	] // end spawnflags

	input Display(void) : "Display the message text. If the All Players spawnflag is not checked, this will only display to the !activator."
] // end game_text

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-abs/game_text_tf") = game_text_tf : "An entity that displays text on player's screens, in the TF2 HUD style.\n" +
	"BUG: This entity will not display to players using the TF2 minimal HUD mode." [
	message(string) : "Message Text" :  : "Message to display onscreen."
	icon(string) : "HUD Icon" :  : "HUD icon (from mod_textures.res) to display." // TODO: List these
	display_to_team(Choices) : "Audience" : 0 : "Which team this should display to." = [
		0 : "Everyone"
		2 : "RED Team Only"
		3 : "BLU Team Only"
	] // end display_to_team
	background(Choices) : "Background Panel Color" : 0 : "Color of the HUD panel." = [
		0 : "Grey"
		2 : "Red"
		3 : "Blue"
	] // end background

	input Display(void) : "Display the message text."
] // end game_text_tf

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/game_ui") = game_ui : "An entity used to detect player input, optionally only when the player is looking at it. The controlling player is always the !activator of this entity's outputs.\n" +
	"BUG: Causes client prediciton errors if the 'Freeze Player' spawnflag is unchecked; clients will always think the flag is checked and expect to be incapable of moving, resulting in delayed/jittery movement as the client is continuously corrected by the server." [
	FieldOfView(float) : "Field Of View" : "-1.0" : "The amount of tolerance in the view checking when determining whether the player's input is still under control. 1.0 = straight ahead, 0.0 = +/- 90 degrees, -1.0 = all directions. If the player isn't within the tolerance, the player regains control."

	spawnflags(flags) = [
		32 : "Freeze Player - Player cannot perform any actions freely" : 1
		64 : "Hide Weapon - Will put the player in reference pose" : 0
		128 : "+USE Deactivates" : 1
		256 : "Jump Deactivates" : 1
	] // end spawnflags

	input Activate(string) : "Take control of a player. If a player entity is specified as the parameter, then the specified player will control this game_ui. Otherwise, the !activator will control this game_ui."
	input Deactivate(void) : "Return control of the used player. Crashes the game if the last player to control this entity cannot be found (no player has controlled this entity since the last round restart, or the last controlling player has left the server)."

	output PlayerOff(void) : "Fired whenever this entity stops controlling the player's input. Does not fire if the controlling player disconnects from the server. If the controlling player disconnected, the Deactivate input does not need to be called (in fact, doing so will crash the server)."
	output PlayerOn(void) : "Fired whenever this entity starts controlling the player's input."

	output PressedAttack(void) : "Fired whenever the player presses the primary attack key (+attack)."
	output PressedAttack2(void) : "Fired whenever the player presses the secondary attack key (+attack2)."
	output PressedBack(void) : "Fired whenever the player presses the move backward key (+back)."
	output PressedForward(void) : "Fired whenever the player presses the move forward key (+forward)."
	output PressedMoveLeft(void) : "Fired whenever the player presses the move left key (+moveleft)."
	output PressedMoveRight(void) : "Fired whenever the player presses the move right key (+moveright)."
	output UnpressedAttack(void) : "Fired whenever the player releases the primary attack key (-attack)."
	output UnpressedAttack2(void) : "Fired whenever the player releases the secondary attack key (-attack2)."
	output UnpressedBack(void) : "Fired whenever the player releases the move backward key (-back)."
	output UnpressedForward(void) : "Fired whenever the player releases the move forward key (-forward)."
	output UnpressedMoveLeft(void) : "Fired whenever the player releases the move left key (-moveleft)."
	output UnpressedMoveRight(void) : "Fired whenever the player releases the move right key (-moveright)."

	output AttackAxis(integer) : "An output that fires whenever the state of the player's primary attack changes. 1 when the player has the primary attack (+attack) key down, 0 otherwise."
	output Attack2Axis(integer) : "An output that fires whenever the state of the player's secondary attack changes. 1 when the player has the secondary attack key (+attack2) down, 0 otherwise."
	output XAxis(string) : "An output that fires whenever the state of the player's strafing movement changes. -1 when the player has move left key (+moveleft) down, 1 when the player has move right key (+moveright) down, and 0 if neither."
	output YAxis(string) : "An output that fires whenever the state of the player's forward/backward movement changes. -1 when the player has backward key (+back) down, 1 when the player has the forward key (+forward) down, and 0 if neither."
] // end game_ui

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/game_weapon_manager") = game_weapon_manager : "An entity used to limit the number of a particular weapon type in the world. Useful in places where NPCs are spawning rapidly, dying, and dropping weapons. Does not function in multiplayer." [
	weaponname(string) : "Weapon Classname" :  : "Classname of the weapon type to limit."
	maxpieces(integer) : "Max Allowed in Level"	: 0 : "The maximum amount of the specified weapon type allowed in the world."
	ammomod(float)	   : "Ammo modifier" : 1 : 	"Modifier for ammount of ammo dropped by a weapon."

	input SetAmmoModifier(float): "Adjust the ammo modifier."
	input SetMaxPieces(integer): "Set the maximum amount of the specified weapon type allowed."
] // end game_weapon_manager



	// GENERIC ENTITIES //

@BaseClass = generic_actor_keys [

	hull_name(choices) : "Hull type" : "Human" : "Physical size of the entity. Affects navigation capabilities and the bounding box." = [
		"HUMAN_HULL" : "Human"
		"WIDE_HUMAN_HULL" : "Wide"
		"TINY_HULL" : "Tiny"
		"MEDIUM_HULL" : "Medium"
		"LARGE_HULL" : "Large"
	] // end hull_name
] // end generic_actor_keys
@PointClass base(SModel, SBaseEntity, SBaseDiv, SModelSkin, SModelBodyGroup, generic_actor_keys, SBaseNPC, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) color(150 0 200) studioprop() = generic_actor : "A generic NPC purely made for scripted sequence work." [
] // end generic_actor



	// GHOST ENTITIES //

// TODO: What uses this?
// Funnily enough the harvest_event ghost is just a tracktrain and does NOT use this
@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/props_halloween/ghost_no_hat.mdl") = ghost : "Creates a ghost that will move in the direction it is facing then delete itself after a random amount of time. It will spook any players that go near it and will change direction to avoid collision with walls or props." [
] // end ghost



	// HALLOWEEN ENTITIES //

@BaseClass = halloween_fortune_teller_keys [
	red_teleport(string) : "Red Teleport Entity" :  :  "Where to teleport the red team?"
	blue_teleport(string) : "Blue Teleport Entity" :  : "Where to teleport the blue team?"
] // end halloween_fortune_teller_keys
@PointClass base(SBaseEntity, SBaseDiv, halloween_fortune_teller_keys, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/bots/merasmus/merasmas_misfortune_teller.mdl") = halloween_fortune_teller : "Halloween Fortune Teller." [ // TODO: What does this actually do?
	input DisableFortuneTelling(void) : "Disable fortune telling."
	input EnableFortuneTelling(void) : "Enable fortune telling."
	input EndFortuneTelling(void) : "Stop the current fortune."
	input StartFortuneTelling(void) : "Start fortune telling."

	output OnFortuneCurse(void) : "Sent when a fortune curse all players."
	output OnFortuneEnd(void) : "Sent when a fortune is ended."
	output OnFortuneTold(void) : "Sent when a fortune is told."
	output OnFortuneWarning(void) : "Sent before a fortune will be told."
] // end halloween_fortune_teller

@PointClass base(SBaseEntity) iconsprite("editor-ficool2/halloween_souls_pack") = halloween_souls_pack : "Halloween Soul Packs, usually obtained from dead players on Halloween events." [
] // end halloween_souls_pack

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/halloween_zapper") = halloween_zapper : "Halloween Hell Zapper, always starts Enabled. Emits a specified particle effect between itself and players within a specified volume. This entity does not actually deal any damage upon 'zapping' a target." [
	touch_trigger(target_destination) : "Zap Trigger Zone" :  : "REQUIRED: dispenser_touch_trigger to associate with this zapper. Only players in this volume will be zapped. This entity will NOT create a default trigger if this is unspecified."
	ZapperType(choices) : "Zapper Type" : 0 : "When should players be zapped? If set to Zap on Touch, this entity will repeatedly zap all players in the volume every 0.25 seconds until they leave the volume or this entity is Disabled." = [
		0 : "Zap on Touch"
		1 : "Zap Only on Input"
	] // end ZapperType
	ParticleEffect(string)	: "Particle Effect"	: "underworld_skull_zap" : "The particle effect to be used to zap players."

	input Disable(void) : "Stop automatically zapping players in the trigger zone."
	input Enable(void) : "If this entity's Zapper Type is Zap on Touch, it will begin zapping all players in its trigger every 0.25 seconds."
	input ZapTouching(void) : "Zap all touching players once. Can still be fired while this entity is Disabled."
] // end halloween_zapper



	// HAMMER ENTITIES //

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/hammer_updateignorelist") = hammer_updateignorelist : "Specifies entities that are to be ignored by the hammer_update_safe_entities console command. Enter the targetnames of entities that you want to exclude into the list of fields here. Several of these may exist in a map." [
	IgnoredName01(target_destination) : "Ignored Name 01" :  : "Do not send this entity's information back to Hammer during hammer_update_safe_entities."
	IgnoredName02(target_destination) : "Ignored Name 02" :  : "Do not send this entity's information back to Hammer during hammer_update_safe_entities."
	IgnoredName03(target_destination) : "Ignored Name 03" :  : "Do not send this entity's information back to Hammer during hammer_update_safe_entities."
	IgnoredName04(target_destination) : "Ignored Name 04" :  : "Do not send this entity's information back to Hammer during hammer_update_safe_entities."
	IgnoredName05(target_destination) : "Ignored Name 05" :  : "Do not send this entity's information back to Hammer during hammer_update_safe_entities."
	IgnoredName06(target_destination) : "Ignored Name 06" :  : "Do not send this entity's information back to Hammer during hammer_update_safe_entities."
	IgnoredName07(target_destination) : "Ignored Name 07" :  : "Do not send this entity's information back to Hammer during hammer_update_safe_entities."
	IgnoredName08(target_destination) : "Ignored Name 08" :  : "Do not send this entity's information back to Hammer during hammer_update_safe_entities."
	IgnoredName09(target_destination) : "Ignored Name 09" :  : "Do not send this entity's information back to Hammer during hammer_update_safe_entities."
	IgnoredName10(target_destination) : "Ignored Name 10" :  : "Do not send this entity's information back to Hammer during hammer_update_safe_entities."
	IgnoredName11(target_destination) : "Ignored Name 11" :  : "Do not send this entity's information back to Hammer during hammer_update_safe_entities."
	IgnoredName12(target_destination) : "Ignored Name 12" :  : "Do not send this entity's information back to Hammer during hammer_update_safe_entities."
	IgnoredName13(target_destination) : "Ignored Name 13" :  : "Do not send this entity's information back to Hammer during hammer_update_safe_entities."
	IgnoredName14(target_destination) : "Ignored Name 14" :  : "Do not send this entity's information back to Hammer during hammer_update_safe_entities."
	IgnoredName15(target_destination) : "Ignored Name 15" :  : "Do not send this entity's information back to Hammer during hammer_update_safe_entities."
	IgnoredName16(target_destination) : "Ignored Name 16" :  : "Do not send this entity's information back to Hammer during hammer_update_safe_entities."
] // end hammer_updateignorelist



	// HEADLESS ENTITIES //

@PointClass base(SBaseEntity, SBaseDynamicModel) color(150 0 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/bots/headless_hatman.mdl") = headless_hatman : "Creates the Horseless Headless Horsemann, a boss NextBot. He will not work without a .nav file and won't respawn after death." [
	TeamNum(choices) : "Team" : 5 : "Team of the entity. May or may not change the entity's appearance." = [
		0 : "0 - Any/Unassigned"
		1 : "1 - Spectator"
		2 : "2 - RED"
		3 : "3 - BLU"
		5 : "5 - Neutral/Boss"
	] // end TeamNum
] // end headless_hatman



	// HIGHTOWER ENTITIES //

// This thing is hardcoded to only work on maps exactly named plr_hightower_event. Sadge -Brokk
@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/hightower_teleport_vortex")  = hightower_teleport_vortex : "An entity that creates a vortex, visualised with MONOCULUS vortex particles. By default, players will be sent to entities suffixed with _loser. The team which has the advantage set (with SetAdvantageTeam) will be teleported to entities suffixed with _winner instead. Spawned instantly on map load, therefore a point_template is recommended." [ // TODO elaborate
	target_base_name(target_destination) : "Destination Base Name" :  : "The base name of the destination.  (ie. If using 'hell_winner' and 'hell_loser', then 'hell' is the base name.)"
	lifetime(float) : "Lifetime" : 0 : "How long the portal should stay open."

	input SetAdvantageTeam(integer) : "Set which team has the advantage."
] // end hightower_teleport_vortex



	// INFO ENTITIES //

@BaseClass = SNodeID [
	nodeid(integer) readonly : "Node ID" :  : "Identifies the ID of the node, generated automatically."
] // end SNodeID

@PointClass base(SBaseEntity, SBaseDiv) color(150 50 50) iconsprite("editor-ficool2/info_constraint_anchor") = info_constraint_anchor : "An entity used to attach constraints to a local position on an entity. Usually constraints will attach to the center of mass of an object. Attach the desired constraint to this entity, and then parent this entity to the entity you want the constraint to apply to." [
	massScale(float) : "Mass Scale" : 1 : "Amount to scale the mass of this body in the constraint solver."
] // end info_constraint_anchor

// Hey ficool, mind explaining why you literally copy-pasted your base Node class into here, despite also inheriting from it? Are you stupid or am I stupid? I feel like one of us is stupid.
@PointClass base(SBaseLogical, SNodeID, SBaseDiv) color(150 0 200) studioprop("models/editor/node_hint.mdl") = info_hint : "A hint that is not used for navigation. They don't go into the nodegraph, nor do they fall to the ground. Use these to provide some spatial context for NPCs, such as 'look here if you can't find the player' or 'throw rocks at this spot'." [
	Group(string) : "Hint Group" :  : "If specified, gives the hint a specific group name.  Useful for hint nodes that need to be logically grouped together. NPCs may also refuse to use hint nodes that don't match their hint group."
	TargetNode(node_dest) : "Target node" : -1 : "The node ID of an associated target node, if any."
	StartHintDisabled(choices) : "Start Hint Disabled" : 0 = [
		0 : "No"
		1 : "Yes"
	] // end StartHintDisabled
	hinttype(choices) : "Hint" : 0 = [
		0 : "None"

		2 : "World: Window"
		12 : "World: Act Busy Hint"
		13 : "World: Visually Interesting"
		14 : "World: Visually Interesting (Don't aim at)"
		15 : "World: Inhibit Combine Mines within 15 feet"
		16 : "World: Visually Interesting (Stealth mode)"

		100 : "Crouch Cover Medium"
		101 : "Crouch Cover Low"
		102 : "Waste Scanner Spawn"
		103	: "Entrance / Exit Pinch"
		104	: "Guard Point"
		105	: "Enemy Disadvantage Point"
		106	: "Health Kit"

		400	: "Antlion: Burrow Point"
		401	: "Antlion: Thumper Flee Point"

		450 : "Headcrab: Burrow Point"
		451 : "Headcrab: Exit Pod Point"

		500 : "Roller: Patrol Point"
		501 : "Roller: Cleanup Spot"

		700 : "Crow: Fly to point"
		701 : "Crow: Perch point"

		900 : "Follower: Wait point"
		901 : "Override jump permission"
		902 : "Player squad transition point"
		903 : "NPC exit point"
		904 : "Strider node"

		950 : "Player Ally: Push away destination"
		951 : "Player Ally: Fear withdrawal destination"

		1000 : "HL1 World: Machinery"
		1001 : "HL1 World: Blinking Light"
		1002 : "HL1 World: Human Blood"
		1003 : "HL1 World: Alien Blood"

		1100 : "CS Hostage: Escape Point"
	] // end hinttype
	hintactivity(string) : "Hint Activity" :  : "Activity associated with this hint node. Various parts of the NPC AI play this activity at times. i.e. Actbusy nodes will play this activity when an NPC acts busy on the node."
	MinimumState(choices) : "Minimum State" : 1 : "Require an NPC have a minimum state to use the hint." = [
		1 : "Idle"
		2 : "Alert"
		3 : "Combat"
	] // end MinimumState
	MaximumState(choices) : "Maximum State" : 3 : "Require an NPC have a maximum state to use the hint." = [
		1 : "Idle"
		2 : "Alert"
		3 : "Combat"
	] // end MaximumState
	IgnoreFacing(choices) : "Ignore Facing" : 2 : "Don't pay attention to the facing of the node. May not apply to a given hint type." = [
		0 : "No"
		1 : "Yes"
		2 : "Default"
	] // end IgnoreFacing
	nodeFOV(choices) : "Node FOV" : 180 : "Imagine this node requires that an NPC be in the node's field of view in order to use this hint." = [
		45 : "45 Degrees"
		90 : "90 Degrees"
		180 : "180 Degrees"
		360 : "360 Degrees"
	] // end nodeFOV

	spawnflags(flags) = [
		65536: "Allow jump up" : 0
	] // end spawnflags

	input DisableHint(void) : "Disable hint."
	input EnableHint(void) : "Enable hint."
] // end info_hint

@PointClass base(SPreservedEntity, info_hint) color(150 0 200) studioprop("models/editor/ground_node_hint.mdl") = info_node_hint : "A navigation node for ground moving NPCs that includes some context information for NPCs that are interested in it. The hint might indicate a window that could be looked out of, or an item of interest that could be commented on. Many hint nodes are NPC-specific. The angles of a hint node indicate what direction the NPC should face to perform the hint behavior.\n" +
	"NOTE: It's important to understand the distinction between scripts, such as scripted_sequence and scripted_schedule, and info_hint entities. Scripts summon NPCs to specific cue points to play their parts, while hints provide context information to the AI that they use to perform their behaviors. Hints require code support in the NPC, while scripts are generic and may require only animations to play. Use a hint if the behavior is driven by the AI, use a script if the behavior is driven by the map." [
	output OnNPCStartedUsing(string) : "Fired when an NPC has reached this node and started using it. Passes along the NPC."
	output OnNPCStoppedUsing(string) : "Fired when an NPC has stopped using this node. Passes along the NPC."
] // end info_node_hint

@PointClass base(STargetname, SAngles, SBaseIO) iconsprite("editor-ficool2/info_landmark") = info_landmark : "An entity that acts as a landmark for transitions to another level. There should be a corresponding info_landmark entity in the next map. Entities will be transitioned to the next level relative to the info_landmark entities." [
] // end info_landmark

@PointClass base(STargetname) iconsprite("editor-ficool2/info_lighting") = info_lighting : "An internal entity that can be used to change the lighting origin of a prop_static, and no other purpose. Set the prop_static's Lighting Origin to point at this entity to make the prop_static light as if it was at the info_lighting's origin. Good for prop_static entities that are embedded in world geometry (like rocks/windows/etc)." [
] // end info_lighting

@PointClass base(SDoesNotFunction, SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/info_lighting_relative") = info_lighting_relative : "Intended to be used with the Lighting Origin Offset (LightingOriginHack) on dynamic models, but the keyvalue does not function. Use Lighting Origin instead. This can still be used as a generic target entity." [
	LightingLandmark(target_destination) : "Lighting Landmark" :  : "Entity at which the lighting origin to reference is contained. If empty, the info_lighting_relative's origin will be used. Only has an effect when this entity is used as a Lighting Origin Offset."
] // end info_lighting_relative

@PointClass iconsprite("editor-ficool2/info_mass_center") = info_mass_center : "An entity that overrides the mass center of the target physics prop, or func_physbox, by moving it to the info_mass_center's location. Removed on map spawn." [
	target(target_destination) : "Target Object" :  : "The entity whose mass center will be overridden."
] // end info_mass_center

@PointClass iconsprite("editor-ficool2/info_no_dynamic_shadow") sidelist(sides) = info_no_dynamic_shadow : "Use this entity to mark surfaces that shouldn't receive dynamic shadows. Useful to apply to walls and floors where shadows are drawn improperly, giving away the location of enemies. This is an internal entity; it does not exist in-game." [
	sides(sidelist) : "Brush face(s)" :  : "The brush face(s) which will not receive dynamic shadows."
] // end info_no_dynamic_shadow

@PointClass base(SNodeID) color(150 0 200) studioprop("models/editor/ground_node.mdl") = info_node : "A navigation node for ground moving NPCs. Navigation nodes are baked into the nodegraph so that NPCs can move to them. Ground nodes fall to the ground when they spawn." [
	spawnflags(Flags) = [
		1 : "Force human permission" : 0
		2 : "Force small_centered permission" : 0
		4 : "Force wide_human permission" : 0
		8 : "Force tiny permission" : 0
		16 : "Force wide_short permission" : 0
		32 : "Force medium permission" : 0
		64 : "Force tiny_centered permission" : 0
		128 : "Force large permission" : 0
		256 : "Force large_centered permission" : 0
		512 : "Keep editor position" : 0
	] // end spawnflags
] // end info_node

@PointClass base (SNodeID, SBaseDiv) color(150 0 200) studioprop("models/editor/air_node.mdl") = info_node_air : "A navigation node for flying NPCs. Air navigation nodes are baked into the nodegraph so that NPCs can move to them. Air nodes do not fall to the ground when they spawn." [
	nodeheight(integer) : "Node Height" : 0 : ""
] // end info_node_air

@PointClass base(info_hint, info_node_air) color(150 0 200) line(255 255 255, nodeid, TargetNode) studioprop("models/editor/air_node_hint.mdl") = info_node_air_hint : "A navigation node for flying NPCs that includes some context information for NPCs that are interested in it. The hint might indicate a window that could be looked into, or an item of interest that could be commented on. Many hint nodes are NPC-specific. The angles of a hint node indicate what direction the NPC should face to perform the hint behavior." [
] // end info_node_air_hint

@PointClass base(SBaseEntity, SBaseDiv) color(150 0 200) line(255 255 255, nodeid, StartNode, nodeid, EndNode) size(-8 -8 -8, 8 8 8) = info_node_link : "A dynamic connection between two navigation nodes. You specify the node IDs of the start and end nodes, and then you can use entity I/O to turn on and off the connection. This could be used to create or destroy a connection in the nodegraph because of some event in your map (a bridge being created/destroyed, etc)." [
    StartNode(node_dest) : "Start Node ID" : : "The node ID of one end of the node connection."
    EndNode(node_dest) : "End Node ID" : : "The node ID of one end of the node connection."
	initialstate(choices) : "Initial State?" : 1 = [
		0 : "Off"
		1 : "On"
	] // end initialstate
	linktype(choices) : "Type of Connection" : 1 = [
		1 : "Ground"
		2 : "Jump"
		4 : "Fly"
		8 : "Climb"
	] // end linktype
	AllowUse(string) : "Allow Pass When Off" : : "Entity or class to allow passage even when node is off"
	InvertAllow(choices) : "Invert exclusion rules" : 0 : "Allowed entity is the only entity NOT allowed when this is set to 'yes'" = [
		0 : "No"
		1 : "Yes"
	] // end InvertAllow

	spawnflags( Flags ) = [
		1 : "Force human connect" : 0
		2 : "Force small_centered connect" : 0
		4 : "Force wide_human connect" : 0
		8 : "Force tiny connect" : 0
		16 : "Force wide_short connect" : 0
		32 : "Force medium connect" : 0
		64 : "Force tiny_centered connect" : 0
		128 : "Force large connect" : 0
		256 : "Force large_centered connect" : 0
		512 : "Force medium_tall connect" : 0
	] // end spawnflags

	input TurnOff(void) : "Turn the link off."
	input TurnOn(void) : "Turn the link on."
] // end info_node_link

@PointClass base(SBaseEntity, SNodeID, SBaseDiv) color(150 0 200) wirebox(mins, maxs) = info_node_link_controller : "An entity that controls all connections between nodes that intersect the controller's volume. This allows for mass enabling/disabling of all node connections through a volume." [
	mins(vector) : "Mins" : "-8 -32 -36" : "Minimum size of the box."
	maxs(vector) : "Maxs" : "8 32 36" : "Maximum size of the box."
	initialstate(choices) : "Initial State?" : 1 = [
		0 : "Off"
		1 : "On"
	] // end initialstate
	useairlinkradius(choices) : "Use Larger Radius (for air links)?" : 0 : "Set this to 'Yes' if this controller is intended to control air links. Air links connect using a larger search radius so leaving this at 'No' might miss some air links." = [
		0 : "No"
		1 : "Yes"
	] // end useairlinkradius
	AllowUse(string) : "Allow Pass When Off" : : "Entity or class to allow passage even when node is off"
	InvertAllow(choices) : "Invert exclusion rules?" : 0 : "Allowed entity is the only entity NOT allowed when this is set to 'yes'" = [
		0 : "No"
		1 : "Yes"
	] // end InvertAllow

	input SetAllowed(string) : "Change the allowed pass when off"
	input SetInvert(bool) : "Change the invert exclusion rule"

	input TurnOn(void) : "Turn the link on."
	input TurnOff(void) : "Turn the link off."
] // end info_node_link_controller

@PointClass base(SBaseEntity, SBaseDiv) color(150 0 200) iconsprite("editor-ficool2/info_npc_spawn_destination") = info_npc_spawn_destination : "NPC spawn destination. An npc_template_maker can optionally have these set as the destination where the NPC will spawn." [
	ReuseDelay(float) : "Reuse Delay" : "1.0" : "After an NPC is spawned at this destination, the delay before this destination is eligible for selection again."
	RenameNPC(string) : "New NPC Name" :  : "If an NPC spawns at this destination, change that NPC's targetname to this."

	output OnSpawnNPC(void) : "Fired when an NPC spawns at this destination."
] // end info_npc_spawn_destination

@PointClass base(SHelperModel, SBaseEntity) color(255 50 50) iconsprite("editor-ficool2/info_null") studio() = info_null : "An entity that's immediately removed on spawning. Useful as a spotlight target or for leaving comments in the VMF file.\n" +
	"NOTE: When using this entity to leave comments in a VMF for other mappers to find, the Helper Model will only appear for other mappers who are also using this FGD (or another FGD with an analogous feature)." [
] // end info_null

//Why the hell does this use the toolsinvisibledisplacement icon???? -Brokk
@PointClass base(SBaseEntity, SBaseDiv, SEnableDisable, STFTeam) iconsprite("tools/toolsinvisibledisplacement") studioprop("models/editor/camera.mdl") = info_observer_point : "Marks a camera location for Team Fortress 2 players. Any spectating players (due to selecting the Spectator team or being unable to respawn at the time) have the ability to select this camera location to observe, as long as they match the camera's team." [
	// TODO: Does the TeamNum keyvalue actually do anything? It doesn't seem to in code...
	associated_team_entity(target_destination) : "Associated Team Entity" :  : "An entity associated with this point that can be owned by a team (such as a flag or control point). Players will only be able to use this observer point if their team owns the associated team entity."
	fov(float) : "FOV" : 0 : "Specifies the field-of-view angle. Larger numbers allow the camera to see more of the playing field. Default is 70. Note that changing this may cause the FOV to carry over when switching away from the camera. Not recommended."
	defaultwelcome(choices) : "Welcome Point?" : 0 :  "Set whether this camera is among the ones players may see when they first join the server. If no cameras have this set to 'No', the game will pick from all cameras that are not team-bound." = [
		0 : "No"
		1 : "Yes"
	] // end defaultwelcome
	match_summary(choices) : "Match Summary?" : 0 :  "Marks this point as a camera for the match summary." = [ // TODO: Causes the entity to be disabled on spawn if set. What's the primary effect exactly?
		0 : "No"
		1 : "Yes"
	] // end match_summary
] // end info_observer_point

@BaseClass = info_overlay_keys_1 [
	material(material) : "Material" :  : "The material to overlay."
	sides(sidelist) : "Brush faces" :  : "Faces on which the overlay will be applied."
	RenderOrder(choices) : "Render Priority" : 0 : "Higher values render after lower values (on top)." = [
		0 : "0: Bottom"
		1 : "1: Low"
		2 : "2: Mid"
		3 : "3: Top"
	] // end RenderOrder
	fademindist(float) : "Start Fade Dist" : -1 : "Distance at which the overlay starts to fade (<0 = use fademaxdist)."
	fademaxdist(float) : "End Fade Dist" : 0 : "Maximum distance at which the overlay is visible (0 = don't fade out)."
] // end info_overlay_keys_1
@BaseClass = info_overlay_keys_2 [
	StartU(float) : "U Start" : "0.0" : "Texture coordinates for the image X-axis. This normally starts at zero (left) and goes to 1 (right). Adjust values to change position and scaling."
	EndU(float) : "U End" : "1.0" : "Texture coordinates for the image X-axis. This normally starts at zero (left) and goes to 1 (right). Adjust values to change position and scaling."
	StartV(float) : "V Start" : "0.0" : "Texture coordinates for the image Y-axis. This normally starts at zero (top) and goes to 1 (bottom). Adjust values to change position and scaling."
	EndV(float) : "V End" : "1.0" : "Texture coordinates for the image Y-axis. This normally starts at zero (top) and goes to 1 (bottom). Adjust values to change position and scaling."
] // end info_overlay_keys_2
@PointClass base(STargetname, SAngles, SBaseDiv, info_overlay_keys_1, SClassDiv1, info_overlay_keys_2, SClassDiv2) size(-1 -1 0, 1 1 1) color(255 200 100) overlay() studioprop("models/editor/overlay_helper.mdl") sphere(fademindist) sphere(fademaxdist) = info_overlay : "An entity that places an overlay on the world." [
	BasisOrigin(Vector) readonly : "Basis Origin (Read-Only)" :  : "Offset of the surface from the position of the overlay entity."
	BasisU(Vector) readonly : "Basis U (Read-Only)" :  : "Direction of the material's X-axis."
	BasisV(Vector) readonly : "Basis V (Read-Only)" :  : "Direction of the material's Y-axis."
	BasisNormal(Vector) readonly : "Basis Normal (Read-Only)"
	uv0(vector) readonly : "Point 1 (Read-Only)"
	uv1(vector) readonly : "Point 2 (Read-Only)"
	uv2(vector) readonly : "Point 3 (Read-Only)"
	uv3(vector) readonly : "Point 4 (Read-Only)"
] // end info_overlay

@PointClass base(SBaseEntity, SBaseDiv) size(-1 -1 0, 1 1 1) color(255 200 100) overlay_transition() sidelist(sides) sidelist(sides2) studioprop("models/editor/overlay_helper.mdl") = info_overlay_transition : "Overlay Transition. Creates a scrolling texture between a brush or displacement and a water brush, commonly used for a 'Wave' effect." [
	material(material) : "Material" :  : "The material to overlay."
	sides(sidelist) : "Brush faces" :  : "Brush faces on which the overlay will be applied."
	sides2(sidelist) : "Water faces" :  : "Water Faces on which the overlay will be applied."
	LengthTexcoordStart(float) : "Texcoord Length Start" : "0.0"
	LengthTexcoordEnd(float) : "Texcoord Length End" : "1.0"
	WidthTexcoordStart(float) : "Texcoord Width Start" : "0.0"
	WidthTexcoordEnd(float) : "Texcoord Width End" : "1.0"
	Width1(float) : "Width Land" : "25.0"
	Width2(float) : "Width Water" : "25.0"
	DebugDraw(choices) : "Force Draw? (Debug)" : 0 : "Force the overlay to draw for debugging." = [
		0 : "No"
		1 : "Yes"
	] // end DebugDraw
] // end info_overlay_transition

@PointClass base(SBaseEntity, SBaseDiv) line(255 255 255, targetname, cpoint1) line(255 255 255, targetname, cpoint2) line(255 255 255, targetname, cpoint3) line(255 255 255, targetname, cpoint4) line(255 255 255, targetname, cpoint5) line(255 255 255, targetname, cpoint6) line(255 255 255, targetname, cpoint7) line(255 255 255, targetname, cpoint8) line(255 255 255, targetname, cpoint9) line(255 255 255, targetname, cpoint10) line(255 255 255, targetname, cpoint11) line(255 255 255, targetname, cpoint12) line(255 255 255, targetname, cpoint13) line(255 255 255, targetname, cpoint14) line(255 255 255, targetname, cpoint15) line(255 255 255, targetname, cpoint16) line(255 255 255, targetname, cpoint17) line(255 255 255, targetname, cpoint18) line(255 255 255, targetname, cpoint19) line(255 255 255, targetname, cpoint20) line(255 255 255, targetname, cpoint21) line(255 255 255, targetname, cpoint22) line(255 255 255, targetname, cpoint23) line(255 255 255, targetname, cpoint24) line(255 255 255, targetname, cpoint25) line(255 255 255, targetname, cpoint26) line(255 255 255, targetname, cpoint27) line(255 255 255, targetname, cpoint28) line(255 255 255, targetname, cpoint29) line(255 255 255, targetname, cpoint30) line(255 255 255, targetname, cpoint31) line(255 255 255, targetname, cpoint32) line(255 255 255, targetname, cpoint33) line(255 255 255, targetname, cpoint34) line(255 255 255, targetname, cpoint35) line(255 255 255, targetname, cpoint36) line(255 255 255, targetname, cpoint37) line(255 255 255, targetname, cpoint38) line(255 255 255, targetname, cpoint39) line(255 255 255, targetname, cpoint40) line(255 255 255, targetname, cpoint41) line(255 255 255, targetname, cpoint42) line(255 255 255, targetname, cpoint43) line(255 255 255, targetname, cpoint44) line(255 255 255, targetname, cpoint45) line(255 255 255, targetname, cpoint46) line(255 255 255, targetname, cpoint47) line(255 255 255, targetname, cpoint48) line(255 255 255, targetname, cpoint49) line(255 255 255, targetname, cpoint50) line(255 255 255, targetname, cpoint51) line(255 255 255, targetname, cpoint52) line(255 255 255, targetname, cpoint53) line(255 255 255, targetname, cpoint54) line(255 255 255, targetname, cpoint55) line(255 255 255, targetname, cpoint56) line(255 255 255, targetname, cpoint57) line(255 255 255, targetname, cpoint58) line(255 255 255, targetname, cpoint59) line(255 255 255, targetname, cpoint60) line(255 255 255, targetname, cpoint61) line(255 255 255, targetname, cpoint62) line(255 255 255, targetname, cpoint63) studio("models/editor/cone_helper.mdl") = info_particle_system : "An entity that spawns a particle system built using the particle editor." [
	effect_name(string) : "Particle System Name" :  : "The name of the particle system to spawn. NOT the name of a PCF file!"
	start_active(choices) : "Start Active?" : 1 : "Whether the particle system should begin as soon as the entity spawns." = [
		0 : "No"
		1 : "Yes"
	] // end start_active
	flag_as_weather(choices) : "Flag as Weather?" : 0 : "Is this particle system going to be used as a weather effect? If so, the particle system will not be rendered if the user has disabled weather effects." = [
		0 : "No"
		1 : "Yes"
	] // end flag_as_weather
	cpoint1(target_destination) : "Control Point 1" :  : "If set, control point 1 of the effect will be at this entity's location."
	cpoint2(target_destination) : "Control Point 2" :  : "If set, control point 2 of the effect will be at this entity's location. If control point 1 is not set, this will be ignored."
	cpoint3(target_destination) : "Control Point 3" :  : "If set, control point 3 of the effect will be at this entity's location. If control point 2 is not set, this will be ignored."
	cpoint4(target_destination) : "Control Point 4" :  : "If set, control point 4 of the effect will be at this entity's location. If control point 3 is not set, this will be ignored."
	cpoint5(target_destination) : "Control Point 5" :  : "If set, control point 5 of the effect will be at this entity's location. If control point 4 is not set, this will be ignored."
	cpoint6(target_destination) : "Control Point 6" :  : "If set, control point 6 of the effect will be at this entity's location. If control point 5 is not set, this will be ignored."
	cpoint7(target_destination) : "Control Point 7" :  : "If set, control point 7 of the effect will be at this entity's location. If control point 6 is not set, this will be ignored."
	cpoint8(target_destination) : "Control Point 8" :  : "If set, control point 8 of the effect will be at this entity's location. If control point 7 is not set, this will be ignored."
	cpoint9(target_destination) : "Control Point 9" :  : "If set, control point 9 of the effect will be at this entity's location. If control point 8 is not set, this will be ignored."
	cpoint10(target_destination) : "Control Point 10" :  : "If set, control point 10 of the effect will be at this entity's location. If control point 9 is not set, this will be ignored."
	cpoint11(target_destination) : "Control Point 11" :  : "If set, control point 11 of the effect will be at this entity's location. If control point 10 is not set, this will be ignored."
	cpoint12(target_destination) : "Control Point 12" :  : "If set, control point 12 of the effect will be at this entity's location. If control point 11 is not set, this will be ignored."
	cpoint13(target_destination) : "Control Point 13" :  : "If set, control point 13 of the effect will be at this entity's location. If control point 12 is not set, this will be ignored."
	cpoint14(target_destination) : "Control Point 14" :  : "If set, control point 14 of the effect will be at this entity's location. If control point 13 is not set, this will be ignored."
	cpoint15(target_destination) : "Control Point 15" :  : "If set, control point 15 of the effect will be at this entity's location. If control point 14 is not set, this will be ignored."
	cpoint16(target_destination) : "Control Point 16" :  : "If set, control point 16 of the effect will be at this entity's location. If control point 15 is not set, this will be ignored."
	cpoint17(target_destination) : "Control Point 17" :  : "If set, control point 17 of the effect will be at this entity's location. If control point 16 is not set, this will be ignored."
	cpoint18(target_destination) : "Control Point 18" :  : "If set, control point 18 of the effect will be at this entity's location. If control point 17 is not set, this will be ignored."
	cpoint19(target_destination) : "Control Point 19" :  : "If set, control point 19 of the effect will be at this entity's location. If control point 18 is not set, this will be ignored."
	cpoint20(target_destination) : "Control Point 20" :  : "If set, control point 20 of the effect will be at this entity's location. If control point 19 is not set, this will be ignored."
	cpoint21(target_destination) : "Control Point 21" :  : "If set, control point 21 of the effect will be at this entity's location. If control point 10 is not set, this will be ignored."
	cpoint22(target_destination) : "Control Point 22" :  : "If set, control point 22 of the effect will be at this entity's location. If control point 21 is not set, this will be ignored."
	cpoint23(target_destination) : "Control Point 23" :  : "If set, control point 23 of the effect will be at this entity's location. If control point 22 is not set, this will be ignored."
	cpoint24(target_destination) : "Control Point 24" :  : "If set, control point 24 of the effect will be at this entity's location. If control point 23 is not set, this will be ignored."
	cpoint25(target_destination) : "Control Point 25" :  : "If set, control point 25 of the effect will be at this entity's location. If control point 24 is not set, this will be ignored."
	cpoint26(target_destination) : "Control Point 26" :  : "If set, control point 26 of the effect will be at this entity's location. If control point 25 is not set, this will be ignored."
	cpoint27(target_destination) : "Control Point 27" :  : "If set, control point 27 of the effect will be at this entity's location. If control point 26 is not set, this will be ignored."
	cpoint28(target_destination) : "Control Point 28" :  : "If set, control point 28 of the effect will be at this entity's location. If control point 27 is not set, this will be ignored."
	cpoint29(target_destination) : "Control Point 29" :  : "If set, control point 29 of the effect will be at this entity's location. If control point 28 is not set, this will be ignored."
	cpoint30(target_destination) : "Control Point 30" :  : "If set, control point 30 of the effect will be at this entity's location. If control point 29 is not set, this will be ignored."
	cpoint31(target_destination) : "Control Point 31" :  : "If set, control point 31 of the effect will be at this entity's location. If control point 30 is not set, this will be ignored."
	cpoint32(target_destination) : "Control Point 32" : : "If set, control point 32 of the effect will be at this entity's location. If control point 31 is not set, this will be ignored."
	cpoint33(target_destination) : "Control Point 33" :  : "If set, control point 33 of the effect will be at this entity's location. If control point 32 is not set, this will be ignored."
	cpoint34(target_destination) : "Control Point 34" :  : "If set, control point 34 of the effect will be at this entity's location. If control point 33 is not set, this will be ignored."
	cpoint35(target_destination) : "Control Point 35" :  : "If set, control point 35 of the effect will be at this entity's location. If control point 34 is not set, this will be ignored."
	cpoint36(target_destination) : "Control Point 36" :  : "If set, control point 36 of the effect will be at this entity's location. If control point 35 is not set, this will be ignored."
	cpoint37(target_destination) : "Control Point 37" :  : "If set, control point 37 of the effect will be at this entity's location. If control point 36 is not set, this will be ignored."
	cpoint38(target_destination) : "Control Point 38" :  : "If set, control point 38 of the effect will be at this entity's location. If control point 37 is not set, this will be ignored."
	cpoint39(target_destination) : "Control Point 39" :  : "If set, control point 39 of the effect will be at this entity's location. If control point 38 is not set, this will be ignored."
	cpoint40(target_destination) : "Control Point 40" :  : "If set, control point 40 of the effect will be at this entity's location. If control point 39 is not set, this will be ignored."
	cpoint41(target_destination) : "Control Point 41" :  : "If set, control point 41 of the effect will be at this entity's location. If control point 40 is not set, this will be ignored."
	cpoint42(target_destination) : "Control Point 42" :  : "If set, control point 42 of the effect will be at this entity's location. If control point 41 is not set, this will be ignored."
	cpoint43(target_destination) : "Control Point 43" :  : "If set, control point 43 of the effect will be at this entity's location. If control point 42 is not set, this will be ignored."
	cpoint44(target_destination) : "Control Point 44" :  : "If set, control point 44 of the effect will be at this entity's location. If control point 43 is not set, this will be ignored."
	cpoint45(target_destination) : "Control Point 45" :  : "If set, control point 45 of the effect will be at this entity's location. If control point 44 is not set, this will be ignored."
	cpoint46(target_destination) : "Control Point 46" :  : "If set, control point 46 of the effect will be at this entity's location. If control point 45 is not set, this will be ignored."
	cpoint47(target_destination) : "Control Point 47" :  : "If set, control point 47 of the effect will be at this entity's location. If control point 46 is not set, this will be ignored."
	cpoint48(target_destination) : "Control Point 48" :  : "If set, control point 48 of the effect will be at this entity's location. If control point 47 is not set, this will be ignored."
	cpoint49(target_destination) : "Control Point 49" :  : "If set, control point 49 of the effect will be at this entity's location. If control point 48 is not set, this will be ignored."
	cpoint50(target_destination) : "Control Point 50" :  : "If set, control point 50 of the effect will be at this entity's location. If control point 49 is not set, this will be ignored."
	cpoint51(target_destination) : "Control Point 51" :  : "If set, control point 51 of the effect will be at this entity's location. If control point 50 is not set, this will be ignored."
	cpoint52(target_destination) : "Control Point 52" :  : "If set, control point 52 of the effect will be at this entity's location. If control point 51 is not set, this will be ignored."
	cpoint53(target_destination) : "Control Point 53" :  : "If set, control point 53 of the effect will be at this entity's location. If control point 52 is not set, this will be ignored."
	cpoint54(target_destination) : "Control Point 54" :  : "If set, control point 54 of the effect will be at this entity's location. If control point 53 is not set, this will be ignored."
	cpoint55(target_destination) : "Control Point 55" :  : "If set, control point 55 of the effect will be at this entity's location. If control point 54 is not set, this will be ignored."
	cpoint56(target_destination) : "Control Point 56" :  : "If set, control point 56 of the effect will be at this entity's location. If control point 55 is not set, this will be ignored."
	cpoint57(target_destination) : "Control Point 57" :  : "If set, control point 57 of the effect will be at this entity's location. If control point 56 is not set, this will be ignored."
	cpoint58(target_destination) : "Control Point 58" :  : "If set, control point 58 of the effect will be at this entity's location. If control point 57 is not set, this will be ignored."
	cpoint59(target_destination) : "Control Point 59" :  : "If set, control point 59 of the effect will be at this entity's location. If control point 58 is not set, this will be ignored."
	cpoint60(target_destination) : "Control Point 60" :  : "If set, control point 60 of the effect will be at this entity's location. If control point 59 is not set, this will be ignored."
	cpoint61(target_destination) : "Control Point 61" :  : "If set, control point 61 of the effect will be at this entity's location. If control point 60 is not set, this will be ignored."
	cpoint62(target_destination) : "Control Point 62" :  : "If set, control point 62 of the effect will be at this entity's location. If control point 61 is not set, this will be ignored."
	cpoint63(target_destination) : "Control Point 63" :  : "If set, control point 63 of the effect will be at this entity's location. If control point 62 is not set, this will be ignored."
	cpoint1_parent(integer) : "Control Point 1's Parent" : 0 : "If set and nonzero, control point 1 of the effect will use this point for its parent." // TODO: What do these do?
	cpoint2_parent(integer) : "Control Point 2's Parent" : 0 : "If set and nonzero, control point 2 of the effect will use this point for its parent."
	cpoint3_parent(integer) : "Control Point 3's Parent" : 0 : "If set and nonzero, control point 3 of the effect will use this point for its parent."
	cpoint4_parent(integer) : "Control Point 4's Parent" : 0 : "If set and nonzero, control point 4 of the effect will use this point for its parent."
	cpoint5_parent(integer) : "Control Point 5's Parent" : 0 : "If set and nonzero, control point 5 of the effect will use this point for its parent."
	cpoint6_parent(integer) : "Control Point 6's Parent" : 0 : "If set and nonzero, control point 6 of the effect will use this point for its parent."
	cpoint7_parent(integer) : "Control Point 7's Parent" : 0 : "If set and nonzero, control point 7 of the effect will use this point for its parent."

	input Start(void) : "Tell the particle system to start emitting."
	input Stop(void) : "Tell the particle system to stop emitting."
] // end info_particle_system

@PointClass base(SBaseEntity, SBaseDiv, STFTeam) iconsprite("editor-ficool2/info_passtime_ball_spawn") = info_passtime_ball_spawn : "Marks a PASStime ball spawnpoint. Spawnpoint enabling/disabling doesn't seem to work." [
	output OnSpawnBall(void) : "A ball just spawned here. Might be useful when using randomly selected spawn points."
] // end info_passtime_ball_spawn

@PointClass base(SDoesNotFunction, SBaseEntity) studio("models/editor/playerstart.mdl") = info_player_start : "This entity indicates the position and facing direction at which the player will spawn. Is not used in TF2: Use info_player_teamspawn instead." [ //iconsprite("editor/obsolete")
	spawnflags(flags) = [
		1: "Master (Has priority if multiple info_player_starts exist)" : 0
	] // end spawnflags
] // end info_player_start

@PointClass base(SBaseEntity, SBaseDiv, SEnableDisable, STFTeam, SControlPoint, STeamSpawnAppearance) studio("") = info_player_teamspawn : "This entity marks a spawn point for Team Fortress 2 players. Cannot touch any world geometry. Optimally, you should have at least 16 of these active per team at any given moment so players will never spawn inside one another." [
	SpawnMode(choices) : "Spawn Mode" : 0 : "How the game decides when a player can spawn here. Triggered mode will only allow players sent via a trigger_player_respawn_override (in which case this spawn must be named and specified in the trigger)." = [
		0 : "Normal"
		1 : "Triggered"
	] // end SpawnMode
	MatchSummary(choices) : "Match Summary Mode" :  : "After a competitive matchmaking game is completed, players on the winning team will spawn at 'Winner' spawnpoints and players on the losing team will spawn at 'Loser' spawnpoints for the match summary." = [
		"" : "Normal"
		1 : "Loser"
		2 : "Winner"
	] // end MatchSummary
	round_redspawn(target_destination) : "Red Spawn for Round" :  : "Red spawn point when the specified team_control_point_round is being played. IMPORTANT: If you have ANY team_control_point_round entities in your map, you MUST set this value."
	round_bluespawn(target_destination) : "Blue Spawn for Round" :  : "Blue spawn point when the specified team_control_point_round is being played. IMPORTANT: If you have ANY team_control_point_round entities in your map, you MUST set this value."

	spawnflags(flags) = [
		1 : "Scouts can spawn here" : 1
		4 : "Soldiers can spawn here" : 1
		64 : "Pyros can spawn here" : 1
		8 : "Demomen can spawn here" : 1
		32 : "Heavies can spawn here" : 1
		256 : "Engineers can spawn here" : 1
		16 : "Medics can spawn here" : 1
		2 : "Snipers can spawn here" : 1
		128 : "Spies can spawn here" : 1
	] // end spawnflags
] // end info_player_teamspawn

@PointClass base(SBaseEntity, SBaseDiv, SEnableDisable) studioprop("models/pickups/pickup_powerup_regen.mdl")= info_powerup_spawn : "Powerup spawn location. Only one of each type of Powerup will spawn in a game, so some Powerup spawn locations may not be used in some rounds. Locations and Powerup types are chosen at random. Will only spawn if tf_powerup_mode is set." [
	team(choices) : "Owner Team" : -2 : "Teams can own spawn points. When Powerups are dropped, they resposition themselves after timing out. They will try to pick a spawn point based on what team designation they had when they repositioned. Set to Everyone to have no team bias in spawn positioning." = [
		-2 : "Everyone"
		2 : "RED"
		3 : "BLU"
	] // end team
] // end info_powerup_spawn

@PointClass base(SBaseEntity, SBaseDiv) decal() sphere(Distance) studio("models/editor/cone_helper.mdl") = info_projecteddecal : "An entity that projects a decal onto the world (or props). If the decal has no target name, it will immediately apply itself when the level is loaded. If it has a name specified, it won't apply until it receives the 'Activate' input and will count towards the edict limit." [
	texture(decal) : "Texture" :  : "The image to apply as a decal."
	Distance(float) : "Distance" : 64 : "Distance from the origin to project the decal."

	input Activate(void) : "Force the decal to apply itself to the world."
] // end info_projecteddecal

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/info_radial_link_controller") sphere(radius) = info_radial_link_controller : "This entity automatically severs node connections that pass through its radius. If it moves, it will restore those connections." [
	radius(float) : "Radius" : 120 : "Range at which node connections will be affected."
] // end info_radial_link_controller

@PointClass base(SPreservedEntity, SHelperModel, SBaseEntity) iconsprite("editor-ficool2/info_target") studio() = info_target : "An entity that does nothing and simply exists to be referenced by other entities. Very useful as a positioning entity for other entities to refer to (i.e. the endpoint of an env_beam)" [ // TODO: Why does this entity behave so wonkily?
	spawnflags(flags) = [
		1 : "Transmit to client (respect PVS)" : 0
	] // end spawnflags
] // end info_target

@PointClass base(SPlayerHelper, SBaseEntity) studio() = info_teleport_destination : "An entity that does nothing and simply exists to be referenced by other entities. Intended to be used as a teleport destination by trigger_teleport." [
] // end info_teleport_destination



	// INFODECAL ENTITIES //

@PointClass base(SBaseEntity, SBaseDiv) color(255 200 100) decal() studio("models/editor/axis_helper_thick.mdl") = infodecal : "An entity that places a decal onto a single entity (the world is one big entity). If the decal has no target name, it will immediately apply itself when the level is loaded. If it has a name specified, it won't apply until it receives the 'Activate' input and will count towards the edict limit." [
	texture(decal) : "Texture" :  : "The image to apply as a decal."
	LowPriority(choices) : "Low Priority (can be replaced)?" : 0 = [ // TODO: Test, under what conditions can this be replaced?
		0 : "No"
		1 : "Yes"
	] // end LowPriority

	input Activate(void) : "Force the decal to apply itself to the world. The decal entity is deleted after applying itself." // TODO: Is this correct?
] // end infodecal



	// ITEM ENTITIES //

@PointClass base(SPowerupModel, SBaseEntity, SBaseItem, SModelSkin, SModelBodyGroup, SBaseDynamicModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/items/ammopack_large.mdl") = item_ammopack_full : "Full ammo pack for players. Restores 100% of ammo and metal when picked up. Respawns after 10 seconds when picked up." [
] // end item_ammopack_full

@PointClass base(SPowerupModel, SBaseEntity, SBaseItem, SModelSkin, SModelBodyGroup, SBaseDynamicModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/items/ammopack_medium.mdl") = item_ammopack_medium : "Medium ammo pack for players. Restores 50% of ammo and metal when picked up. Respawns after 10 seconds when picked up." [
] // end item_ammopack_medium

@PointClass base(SPowerupModel, SBaseEntity, SBaseItem, SModelSkin, SModelBodyGroup, SBaseDynamicModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/items/ammopack_small.mdl") = item_ammopack_small : "Small ammo pack for players. Restores 20% of ammo and metal when picked up. Respawns after 10 seconds when picked up." [
] // end item_ammopack_small

@PointClass base(SPowerupModel, SBaseEntity, SBaseItem, SModelSkin, SModelBodyGroup, SBaseDynamicModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/bots/bot_worker/bot_worker_powercore.mdl") = item_bonuspack : "The power core that the players collect in robot destruction." [
] // end item_bonuspack

@PointClass base(SPowerupModel, SBaseEntity, SBaseItem, SModelSkin, SModelBodyGroup, SBaseDynamicModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/items/currencypack_small.mdl") = item_currencypack_custom : "Custom creditspickup from MvM." [ // TODO: How much currency?
	spawnflags(flags) = [
		1073741824: "Never Respawn" : 1
	] // end spawnflags
] // end item_currencypack_custom

@PointClass base(SPowerupModel, SBaseEntity, SBaseItem, SModelSkin, SModelBodyGroup, SBaseDynamicModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/items/currencypack_large.mdl") = item_currencypack_large : "Large credits pickup from MvM." [ // TODO: How much currency?
] // end item_currencypack_large

@PointClass base(SPowerupModel, SBaseEntity, SBaseItem, SModelSkin, SModelBodyGroup, SBaseDynamicModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/items/currencypack_medium.mdl") = item_currencypack_medium : "Medium credits pickup from MvM." [ // TODO: How much currency?
] // end item_currencypack_medium

@PointClass base(SPowerupModel, SBaseEntity, SBaseItem, SModelSkin, SModelBodyGroup, SBaseDynamicModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/items/currencypack_small.mdl") = item_currencypack_small : "Small credits pickup from MvM." [ // TODO: How much currency?
] // end item_currencypack_small

@PointClass base(SPowerupModel, SBaseEntity, SBaseItem, SModelSkin, SModelBodyGroup, SBaseDynamicModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/items/medkit_medium.mdl") = item_healthammokit : "Small health kit AND small ammo pack." [ // TODO: How much health/ammo?
] // end item_healthammokit

@PointClass base(SPowerupModel, SBaseEntity, SBaseItem, SModelSkin, SModelBodyGroup, SBaseDynamicModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/items/medkit_large.mdl") = item_healthkit_full : "Full health kit for players. Restores 100% of health when picked up. Respawns after 10 seconds when picked up." [
] // end item_healthkit_full

@PointClass base(SPowerupModel, SBaseEntity, SBaseItem, SModelSkin, SModelBodyGroup, SBaseDynamicModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/items/medkit_medium.mdl") = item_healthkit_medium : "Medium health kit for players. Restores 50% of health when picked up. Respawns after 10 seconds when picked up." [
] // end item_healthkit_medium

@PointClass base(SPowerupModel, SBaseEntity, SBaseItem, SModelSkin, SModelBodyGroup, SBaseDynamicModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/items/medkit_small.mdl") = item_healthkit_small : "Small health kit for players. Restores 20.5% of health when picked up. Respawns after 10 seconds when picked up." [
] // end item_healthkit_small

@PointClass base(SPowerupModel, SBaseEntity, SBaseItem, SModelSkin, SModelBodyGroup, SBaseDynamicModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/pickups/pickup_powerup_crit.mdl") = item_powerup_crit : "Temporary Crit Powerup. Powerup effect wears off. Powerup respawns automatically." [ // TODO: How long does it last and how long to respawn?
] // end item_powerup_crit

// HA! FICOOL LISTED THIS ONE OUT OF ALPHABETICAL ORDER! I BEAT YOU! YOU FOOL! YOU ABSOLUTE BUFFOON! YOU BUMBLING IDIOT! GIT OWNED NERD!
// sorry im getting really bored ok copy-pasting isnt fun
@PointClass base(SPowerupModel, SBaseEntity, SBaseItem, SModelSkin, SModelBodyGroup, SBaseDynamicModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/pickups/pickup_powerup_strength.mdl") = item_powerup_rune : "Temporary Strength Powerup. Powerup effect wears off. Powerup respawns automatically." [ // TODO: How long does it last and how long to respawn?
] // end item_powerup_rune

@PointClass base(SPowerupModel, SBaseEntity, SBaseItem, SModelSkin, SModelBodyGroup, SBaseDynamicModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/pickups/pickup_powerup_uber.mdl") = item_powerup_uber : "Temporary Uber Powerup. Powerup effect wears off. Powerup respawns automatically." [ // TODO: How long does it last and how long to respawn?
] // end item_powerup_uber

@PointClass base(SBaseEntity, SBaseDynamicModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/can.mdl") = item_sodacan : "Half-Life legacy: A beverage created from a Beverage Dispenser (env_beverage). Uses models/can.mdl, you will need to provide your own as it is missing." [ // TODO: Effect on pickup?
] // end item_sodacan

// NOTE FROM FICOOL: item_teamflag uses prop_dynamic base in code??
// A bunch of keyvalues and other features from prop_dynamic don't work, so don't inherit those
// TODO: Get rid of some of the useless Breakable keyvalues? Find/create a breakable dynamic model for testing breakable teamflag properties
@BaseClass = item_teamflag_keys_1 [
	GameType(choices) : "Game Type" : 0 : "Gamemode type this flag will be used for. Determines who can pick up this flag, whether players can carry multiple flags, and other behavioral quirks." = [
		0 : "Capture the Flag"
		1 : "Attack-Defend / Mann vs Machine"
		2 : "Territory Control"
		3 : "Invade" //Makes it so TF2 tries to load non-existing voicelines (This is actually great because that means you can supply your own!) -Brokk
		4 : "Resource Control"
		5 : "Robot Destruction"
		6 : "Player Destruction"
	] // end GameType
	ReturnTime(integer) : "Return Time " : 60 : "Length of time (in seconds) before dropped flag/intelligence returns to base. In Mann vs Machine, values greater than 600 seconds (10 minutes) will automtically hide the timer."
	ShotClockMode(choices) : "Shot Clock Mode?" : 0 : "Flag uses shot-clock mode, which means that the timer doesn't reset to the full time when an attacking player touches it." = [
		0 : "No"
		1 : "Yes"
	] // end ShotClockMode
	NeutralType(choices) : "Neutral Flag (Invade)" : 1 : "Only used for the Invade game type. When should a dropped Invade flag become neutral?" = [
		0 : "Never"
		1 : "Default (30 seconds)"
		2 : "Half of the Return Time"
	] // end NeutralType
	ScoringType(choices) : "Scoring style (Invade)" : 0 : "Only used for the Invade game type. When the Invade flag is captured, how should the team be rewarded? 'Score' is the team score in the scoreboard. 'Capture count' is the team capture count used in the HUD." = [
		0 : "Increment score"
		1 : "Increment capture count"
	] // end ScoringType
	PointValue(integer) : "Point Value (PD/RD)" : 1 : "Only used for Player Destruction or Robot Destruction. How many points this flag is worth."
	ReturnBetweenWaves(choices) : "Return Between Waves?" : 1 : "Only used for Mann vs Machine. Determines if the flag should return home between waves." = [
		0 : "No"
		1 : "Yes"
	] // end ReturnBetweenWaves
	// TODO: Code seems to indicate that bots that are *attempting* to obtain the flag will also receive these tags? Spotted in tf_populator_spawners.cpp which tells bots to SetFlagTarget() when they spawn, and doing so calls AddFollower(this) on item_teamflag from bot, which causes the item_teamflag to add its tags to the bot? Test this in-game!
	// Also probably doesn't affect squad members (except the squad leader?), as tf_bot_squad.cpp calls SetFlagTarget(null) on new non-leader bots which should clear any flag-assigned tags
	tags(string) : "MvM Robot Tags" :  : "Only used for Mann vs Machine. Space-delimited list of tags to be added to the robot carrying this flag. Can be used to tell the bot to avoid or prefer specific navigation areas with func_nav_avoid and func_nav_prefer."
] // end item_teamflag_keys_1
@BaseClass = item_teamflag_keys_2 [
	flag_icon(material) : "HUD Icon" : "../hud/objectives_flagpanel_carried" : "The icons used for the HUD in some game modes. Format: materials/vgui/[materialname]_red and materials/vgui/[materialname]_blue"
	flag_paper(string) : "Paper Particle" : "player_intel_papertrail" : "Particle effect used for the falling paper trail."
	trail_effect(choices) : "Use Trail Effect?" : 1 : "Use trail effect when the player is carrying the flag." = [
		0 : "None"
		1 : "All Effects"
		2 : "Paper Trail Only"
		3 : "Color Trail Only"
	] // end trail_effect
	flag_trail(material) : "Trail Effect Material" : "flagtrail" : "Materials used for the trail effect. Format: materials/effects/[materialname]_red and materials/effects/[materialname]_blu"
	VisibleWhenDisabled(choices) : "Visible When Disabled?" : 0 : "Flag appears semitransparent when disabled." = [
		0 : "No"
		1 : "Yes"
	] // end VisibleWhenDisabled
] // end item_teamflag_keys_2
@PointClass base(SFlagModel, SBaseEntity, SBaseDiv, SEnableDisable, STFTeam, item_teamflag_keys_1, SModelDynamic, item_teamflag_keys_2, SPropDynamicIO, SModelSettings, SRenderModes, SBaseBreakableModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/flag/briefcase.mdl") = item_teamflag : "Team Fortress 2 flag entity. Used for the intelligence in Capture the Flag, the bomb in Mann vs Machine, robot cores in Robot Destruction, and point drops in Player Destruction." [
	input ForceDrop(void) : "Force the flag to be dropped if it's being carried by a player."
	input ForceGlowDisabled(bool) : "Toggle the glow effect for this flag. 0 = normal behavior, 1 = glow disabled"
	input ForceReset(void) : "Force the flag to be dropped if it's being carried by a player, then reset the flag to its original position."
	input ForceResetAndDisableSilent(void) : "Force the flag to be dropped if it's being carried by a player, and disable the flag, then reset the flag to its original position silently (no messages sent to players)."
	input ForceResetSilent(void) : "Force the flag to be dropped if it's being carried by a player, then reset the flag to its original position silently (no messages sent to players)."
	//input RoundActivate(void) : "Forces this entity to activate. Fired automatically at the start of a round."
	input SetReturnTime(integer) : "Set the length of time (in seconds) before dropped flag/intelligence returns to base. If the flag is currently dropped, the timer will restart to this time regardless of its previous remaining time."
	input ShowTimer(bool) : "Set the visiblity of the flag's return timer while dropped. 0 = hidden, 1 = visible"

	output OnCapTeam1(void) : "Sent when the flag is captured by RED."
	output OnCapTeam2(void) : "Sent when the flag is captured by BLU."
	output OnCapture(void) : "Sent when the flag is captured."
	output OnDrop(void) : "Sent when the flag is dropped."
	output OnPickup(void) : "Sent when the flag is picked up."
	output OnPickupTeam1(void) : "Sent when the flag is picked up by RED."
	output OnPickupTeam2(void) : "Sent when the flag is picked up by BLU."
	output OnReturn(void) : "Sent when the flag is returned via timer."
	output OnTouchSameTeam(void) : "Sent when the flag is touched by a player on the same team (BLU player touches BLU flag, RED player touches RED flag)."
] // end item_teamflag



	// KEYFRAME ENTITIES //

// NOTES FROM FICOOL2:
// Hardcoded rope base classes, thanks Valve!!
// These are directly copied from base.fgd, for some reason *any* changes cause rope rendering to break
// END NOTES FROM FICOOL2

// 2023 UPDATE FROM FICOOL:
// postmortem: these were case sensitive
// which i never considered
// END UPDATE FROM FICOOL -Brokk


// Tested in stock TF2 Hammer, these classes are fairly different from the official rope classes but they don't break rope rendering as far as I can tell...
@BaseClass = keyframe_rope_keys_1 [
	NextKey(target_destination) : "Next KeyFrame" :  : "Name of the next keyframe along this keyframe path."
	Slack(integer) : "Slack" : 50 : "How much extra length the next length of rope has. Zero means it has the length between its two endpoints in the editor."
	PositionInterpolator(choices) : "Position Interpolator" : 2 : "Method of generating the curve followed by this rope." = [
		0 : "Linear"
		1 : "Catmull-Rom Spline"
		2 : "Rope"
	] // end PositionInterpolator
	Collide(choices) : "Collide with World?" : 0 : "Whether or not this rope collides with world geometry." = [
		0 : "No"
		1 : "Yes"
	] // end Collide
	NoWind(choices) : "Disable Wind?" : 0 : "When set to Yes, the rope will not be affected by wind." = [
		0 : "No"
		1 : "Yes"
	] // end NoWind
	//Breakable(choices) : "Breakable?" : 0 : "When set to yes, the rope can be detached from either endpoint when shot." = [ // Nonfunctional
	//	0 : "No"
	//	1 : "Yes"
	//] // end Breakable
	Dangling(choices) : "Start Dangling?" : 0 : "When set to Yes, the rope connecting this entity to its Next KeyFrame will start detached from the Next KeyFrame. If this entity has no Next KeyFrame, a short rope will be created to hang from this point." = [
		0 : "No"
		1 : "Yes"
	] // end Dangling
] // end keyframe_rope_keys_1
@BaseClass = keyframe_rope_keys_2 [
	RopeMaterial(material) : "Rope Material" : "cable/cable.vmt" : "The material to use when rendering the rope."
	TextureScale(float) : "Texture Scale" : "1.0" : "This scales the texture resolution. The default resolution is 4 pixels per HU. Larger values stretch the texture and smaller values scrunch it up."
	Width(float) : "Width (1-64)" : "2.0" : "Width of the rope in Hammer units."
	Type(choices) : "Flexibility" : 0 : "Used to calculate how many points this rope will bend at. The number of visual segments is a combination of this number and the number of Subdivisions." = [
		0 : "Rope (8)"
		1 : "Semi-rigid (2)"
		2 : "Rigid (0)"
	] // end Type
	Subdiv(integer) : "Subdivisions" : 2 : "Number of subdivisions between each rope segment. Maximum value is 8. Higher values make smoother ropes, but are slower to render."
	Barbed(choices) : "Barbed?" : 0 : "Test effect intended to make the rope look sharper and more barbed. In practice, makes the rope look like a collection of intertwined ropes. Not very noticeable at low slack values." = [
		0 : "No"
		1 : "Yes"
	] // end Barbed
] // end keyframe_rope_keys_2
@KeyFrameClass base(SPreservedEntity, SBaseEntity, SBaseDiv, keyframe_rope_keys_1, SClassDiv1, keyframe_rope_keys_2, SClassDiv2) animator() keyframe() studio("models/editor/axis_helper_thick.mdl") = keyframe_rope : "A node entity that marks a point in a rope. Identical to move_rope.\n" +
	"TIP: keyframe_rope and move_rope actually represent the same entity class and, with the correct FGD modifications, can be used interchangeably with no drawbacks or errors. This FGD provides the modifications necessary for both entities to be used interchangeably. (For an FGD modification that can be used alongside the ABS or stock FGDs and provides the same interchangeability, see http://src-ents.shoutwiki.com/wiki/CRopeKeyframe#FGD_Code.)" [
	MoveSpeed(integer) : "Speed" : 1 : "Does nothing in-game. Must be a positive integer for Hammer rope previews to work."

	spawnflags(flags) = [
		1 : "Auto Resize" : 0
	] // end spawnflags

	input Break(void) : "Break off any ropes connected to this node."
	input SetForce(string) : "Apply a force instantaneously to the rope. The parameter should be a vector containing the force to be applied (X Y Z)."
	//input SetScrollSpeed(float) : "Set the speed at which the texture scrolls." // Doesn't do anything
] // end keyframe_rope

@MoveClass base(keyframe_rope) animator() keyframe() studio("models/editor/axis_helper_thick.mdl") = move_rope : "A node entity that marks a point in a rope. Identical to keyframe_rope.\n" +
	"TIP: keyframe_rope and move_rope actually represent the same entity class and, with the correct FGD modifications, can be used interchangeably with no drawbacks or errors. This FGD provides the modifications necessary for both entities to be used interchangeably. (For an FGD modification that can be used alongside the ABS or stock FGDs and provides the same interchangeability, see src-ents.shoutwiki.com/wiki/CRopeKeyframe#FGD_Code.)" [
] // end move_rope



	// LIGHT ENTITIES //

@BaseClass base(SLightDiv, SToggle) color(255 255 255) = SLight [
	_light(color255) : "Brightness" : "255 255 255 200" : "The RGB color and brightness of the light. Colors must be between 0 and 255; brightness can be anything."
	_lightHDR(color255) : "HDR Brightness" : "-1 -1 -1 1" : "Brightness override used in HDR mode. Default is -1 -1 -1 1, which means no change."
	_lightscaleHDR(float) : "HDR Brightness Scale" : "1" : "Amount to scale the light by when compiling for HDR."
	defaultstyle(Choices) : "Default Appearance" : 0 : "Default custom appearance to use, may not function. Makes the light into a switchable light if any option other than Normal is selected." = [
		0 : "Normal"
		1 : "Flicker A"
		2 : "Slow, strong pulse"
		3 : "Candle A"
		4 : "Fast strobe"
		5 : "Gentle pulse"
		6 : "Flicker B"
		7 : "Candle B"
		8 : "Candle C"
		9 : "Slow strobe"
		10: "Fluorescent flicker"
		11: "Slow pulse, noblack"
		12: "Underwater light mutation"
	] // end defaultstyle
	style(Choices) : "Appearance" : 0 : "Various custom appearance presets. Makes the light into a switchable light if any option other than Normal is selected." = [ // TODO: Difference between Default Appearance?
		0 : "Normal"
		1 : "Flicker A"
		2 : "Slow, strong pulse"
		3 : "Candle A"
		4 : "Fast strobe"
		5 : "Gentle pulse"
		6 : "Flicker B"
		7 : "Candle B"
		8 : "Candle C"
		9 : "Slow strobe"
		10: "Fluorescent flicker"
		11: "Slow pulse, noblack"
		12: "Underwater light mutation"
	] // end style
	pattern(string) : "Custom Appearance" :  : "A string of characters, like a sequence of piano keys, that define a pattern of brightness. a is dark and z is full intensity. Applies only to switchable lights."

	spawnflags(Flags) = [
	     1 : "Initially dark - only works when light has a targetname." : 0
	] // end spawnflags

	input FadeToPattern(string) : "Fades from first value in old pattern, to first value in the new given pattern. Pattern format is a string of characters, where 'a' is total darkness, 'z' fully bright. i.e. 'aaggnnttzz' would be a steppy fade in from dark to light."
	input SetPattern(string) : "Set a custom pattern of light brightness for this light. Pattern format is a string of characters, where 'a' is total darkness, 'z' fully bright. i.e. 'aaggnnttzz' would be a steppy fade in from dark to light."

	input TurnOff(void) : "The the light off."
	input TurnOn(void) : "Turn the light on."
] // end SLight

@BaseClass = SLightFalloff [
	_constant_attn(float) : "Constant Attenuation" : 0 : "Used to set the proportion of this light's attenuation (loss of intensity over distance) that should be constant. Total constant falloff means the light never falls off over distance and is approximately the same intensity at all ranges. See developer.valvesoftware.com/wiki/Constant-Linear-Quadratic_Falloff for more info on using these values."
	_linear_attn(float) : "Linear Attenuation" : 0 : "Used to set the proportion of this light's attenuation (loss of intensity over distance) that should be calculated linearly. Total linear falloff means the light's intensity is inversely proportional to the distance from the source, so the light fades out slowly and gradually over a distance. See developer.valvesoftware.com/wiki/Constant-Linear-Quadratic_Falloff for more info on using these values."
	_quadratic_attn(float) : "Quadratic Attenuation" : 1 : "Used to set the proportion of this light's attenuation (loss of intensity over distance) that should be calculated quadratically. Total quadratic falloff means the rate of the light's drop in intensity increases proportionally as the light gets further from its source. This makes the light bright when close by, but it rapidly dims at a distance. See developer.valvesoftware.com/wiki/Constant-Linear-Quadratic_Falloff for more info on using these values."
	_fifty_percent_distance(float) : "Half (50%) Falloff" :  : "Distance from this light at which it is reduced to 50% brightness. Ignores Quadratic, Linear, and Constant if used."
	_zero_percent_distance(float) : "Complete (0%) Falloff" :  : "Distance from this light at which it cannot light objects anymore ((1/256)% brightness). Requires Half Falloff."
	// TODO: Evaluate code and re-test. Make sure you're testing with stock VRAD and not modded!
	//_hardfalloff(integer) : "Hard Falloff" :  : "If set, causes lights to fall to exactly zero beyond the zero percent distance. Doesn't appear to have any effect."
	//_distance(integer) : "Maximum Distance" :  : "This is the distance that light is allowed to cast, in units. Doesn't appear to have any effect." // Doesn't work?
] // end SLightFalloff

@PointClass base(STargetname, SBaseIO, SLight, SBaseDiv, SLightFalloff) color(255 255 255) iconsprite("editor-ficool2/light") light() sphere(_fifty_percent_distance) sphere(_zero_percent_distance) sphere(_hardfalloff) sphere(_distance) = light : "An invisible omnidirectional lightsource that emits pre-calculated lighting. If not given a targetname, the light is entirely static. If given a targetname, the light is turned into a switchable light that can be turned on and off at no cost to in-game performance. Switchable lights will not do light bouncing, the map's file size will be larger, and VRAD will take longer as a result. See developer.valvesoftware.com/wiki/Naming_Lights for more info." [
] // end light

@PointClass base(SBaseAnglesLight, SLight, SBaseDiv) color(255 255 255) iconsprite("editor-ficool2/light_directional") light() = light_directional : "A directional light with no falloff that only emits from skybox textures, similar to sunlight emitted by a light_environment. Only works with Slartibarty's modified VRAD.\n" +
	"NOTE: Although this entity can be used as a switchable light, it alone cannot be switched as TF2 does not recognize the entity class. Having an official light class with the same name as this entity in the map will allow this light to be toggled." [
	SunSpreadAngle(float) : "Sun Spread Angle" : 5 : "The angular extent of the light for casting soft shadows. Higher numbers are more diffuse. 5 is a good starting value."
] // end light_directional

@BaseClass = light_environment_keys [
	_ambient(color255) : "Ambient" : "255 255 255 20" : "Color and brightness of diffuse skylight."
	_ambientHDR(color255) : "Ambient HDR" : "-1 -1 -1 1" : "Override for Ambient when compiling HDR lighting. Defaults to -1 -1 -1 1, which means the same as LDR."
	_AmbientScaleHDR(float) : "Ambient HDR Scale" : "1" : "Amount to scale the ambient light by when compiling for HDR."
] // end light_environment_keys
@PointClass base(SBaseAnglesLight, SLight, SBaseDiv, light_environment_keys, light_directional) color(255 255 255) iconsprite("editor-ficool2/light_environment") light() = light_environment : "Sets the color and angle of the light from the sun and sky. The light_environment can be named and switched akin to a normal light entity, although the quality will be noticeably worse as bounced lighting will not be simulated on a named light. See developer.valvesoftware.com/wiki/Team_Fortress_2_Sky_List for example sky lighting setups." [
] // end light_environment

// Doesn't actually use the pitch keyvalue despite every FGD claiming it does
@PointClass base(SBaseEntity, SBaseDiv, SToggle) color(255 255 255) light() lightcone(_inner_cone, _cone, _light, -1) line(255 255 255, targetname, target) sphere(distance) studio("models/editor-ficool2/cone_helper_gray.mdl") = light_dynamic : "An invisible lightsource that is fully dynamic, and can be moved and adjusted at runtime. The light always starts on. There is a maximum of 17 light_dynamic entities that can be turned on at once; exceeding this number will result in some of the light_dynamics not casting light. Line-of-sight checks are not performed when applying lighting, so this entity cannot be used to cast shadows and will sometimes cast light on objects that are entirely obscured. This entity is actually two lights, one of which only affects brushes and the other only affects models.\n" +
	"The brush light is not located at the light_dynamic itself, but casts light from a point in front of the light_dynamic at the first world brush, displacement, func_detail, or static prop encountered. The light affects all world brush, displacement, func_detail, and brush entity faces within the Brush Spotlight End Radius that are facing the brush light source. As a result, brush entities can only be lit indirectly (not directly). If this light is marked as omnidirectional, the brush light emits from the light_dynamic itself.\n" +
	"Models use a separate lighting method: Models (including prop_static) within the light_dynamic's spotlight cone (if not omnidirectional) and radius will be lit per-vertex based on distance to the spotlight, with no regard for the model's orientation. Lighting origins are ignored. Static props using prop lightmaps will not be lit at all." [ // iconsprite("editor-ficool2/light_dynamic")
	target(target_destination) : "Entity to Point At" :  : "Optionally the name of an entity in the map that the dynamic light will point at instead of using Pitch Yaw Roll."
	_light(color255) : "Light Color" : "255 255 255" : "The RGB color of the light."
	brightness(integer) : "Brightness" : 5 : "The intensity of the spotlight. Does not use the same scale as normal lights: Values above 10 are generally excessive, and values approaching/above 20 may cause visual bugs."
	distance(float) : "Maximum Distance" : 128 : "This is the distance that light is allowed to cast from the light_dynamic entity, in Hammer Units, on both brushes and models."
	spotlight_radius(float) : "Brush Spotlight End Radius" : 128 : "This is the maximum radius from the brush face that the light is directly hitting, in Hammer Units, for brushes that this light can affect. The actual radius of the light is based on this value, the brightness, and distance from the light_dynamic. Has no effect if the Outer Angle is 0."
	_inner_cone(integer) : "Inner (Bright) Angle" : 30 : "The angle of the inner spotlight beam. Only affects lighting on models. Has no effect if the Outer Angle is 0."
	_cone(integer) : "Outer (Fading) Angle" : 45 : "The angle of the outer spotlight beam. Only affects lighting on models. 0 makes both the brush and model lights omnidirectional."
	style(choices) : "Appearance" : 0 : "Various custom appearance presets." = [
		0 : "0 - Normal"
		1 : "1 - Flicker A"
		2 : "2 - Slow, strong pulse"
		3 : "3 - Candle A"
		4 : "4 - Fast strobe"
		5 : "5 - Gentle pulse"
		6 : "6 - Flicker B"
		7 : "7 - Candle B"
		8 : "8 - Candle C"
		9 : "9 - Slow strobe"
		10 : "10 - Fluorescent flicker"
		11 : "11 - Slow pulse, noblack"
		12 : "12 - Underwater light mutation"
	] // end style

	spawnflags(flags) = [
		1 : "Do not light brushes (better performance)" : 0
		2 : "Do not light models (better performance)" : 0
		// These don't work
		//4 : "Add Displacement Alpha" : 0
		//8 : "Subtract Displacement Alpha" : 0
	] // end spawnflags

	input Color(color255) : "Set the light's color (R G B)."
	input Brightness(integer) : "Set the light's brightness."
	input Distance(float) : "Set the Maximum Distance."
	input spotlight_radius(float) : "Set the Brush Spotlight End Radius."
	input Style(integer) : "Change the appearance (see Appearance field for possible values)."
	input _cone(integer) : "Set the Outer (Fading) Angle."
	input _inner_cone(integer) : "Set the Inner (Bright) Angle."

	input TurnOff(void) : "Turn the light off."
	input TurnOn(void) : "Turn the light on."
] // end light_dynamic

@BaseClass = light_spot_keys [
	_inner_cone(integer) : "Inner (Bright) Angle" : 30 : "The angle of the inner spotlight beam."
	_cone(integer) : "Outer (Fading) Angle" : 45 : "The angle of the outer spotlight beam."
	_exponent(integer) : "Focus" : 1 : "Changes the distance between the umbra and penumbra cone - higher values make the edge of the light more blurred."
] // end light_spot_keys
@PointClass base(SBaseAnglesLight, SLight, SBaseDiv, light_spot_keys, SClassDiv1, SLightFalloff) color(255 255 255) light() lightcone() lightprop("models/editor/spot.mdl") sphere(_fifty_percent_distance) sphere(_zero_percent_distance) sphere(_hardfalloff) sphere(_distance) = light_spot : "An invisible and directional spotlight.\n" +
	"BUG: This entity may rotate improperly when placed inside of an instance. To avoid this bug, enable the pitch keyvalue in tf2_spud.fgd's settings and set the light_spot's pitch in the 'Pitch Yaw Roll' keyvalue to the opposite of the 'Pitch Override' keyvalue." [
] // end light_spot



	// LOGIC ENTITIES //

@PointClass base(SBaseLogical, SBaseDiv, SGlobalStates) color(100 150 255) iconsprite("editor/logic_auto") = logic_auto : "Fires outputs when a map spawns. If 'Remove on Fire' flag is set, the logic_auto is deleted after firing. If a Global State is set, this entity will only fire its OnMapSpawn output if the global state is enabled and set. This allows you to only fire events based on what took place in a previous map." [
	spawnflags(flags) = [
		1 : "Remove on Fire" : 1
	] // end spawnflags

	output OnBackgroundMap(void) : "Fired when the map is loaded as a background to the main menu."
	output OnLoadGame(void) : "Fired when the map is loaded from a saved game."
	output OnMapSpawn(void) : "Fired when the map is loaded for any reason, including saves and round restarts."
	output OnMapTransition(void) : "Fired when the map is loaded due to a level transition."
	output OnMultiNewMap(void) : "Fired only in multiplayer, when a new map is loaded." // TODO: Functions identically to OnMultiNewRound?
	output OnMultiNewRound(void) : "Fired when a new round starts."
	output OnNewGame(void) : "Fired when the map is loaded to start a new game."
] // end logic_auto

@PointClass base(SBaseLogical, SBaseDiv) color(100 255 100) iconsprite("editor/logic_branch") = logic_branch : "Stores and tests a boolean value, firing an output based on whether the value is true or false. Use this entity to branch between two potential sets of events." [
	InitialValue(choices) : "Initial value" : 0 : "Initial value for this branch." = [
		0 : "0: False"
		1 : "1: True"
	] // end InitialValue

	input SetValue(bool) : "Set the boolean value without performing the comparison. Use this to hold a value for a future test." // TODO: Are values beyond 0 and 1 considered true or false?
	input SetValueTest(bool) : "Set the boolean value and test it, firing OnTrue or OnFalse based on the new value."
	input Test(void) : "Test the input value and fire OnTrue or OnFalse based on the value."
	input Toggle(void) : "Toggle the boolean value between true and false."
	input ToggleTest(void) : "Toggle the boolean value and tests it, firing OnTrue or OnFalse based on the new value."

	output OnTrue(bool) : "Fired when the input value is true (nonzero)."
	output OnFalse(bool) : "Fired when the input value is false (zero)."
] // end logic_branch

@PointClass base(SBaseLogical, SBaseDiv) color(100 255 100) iconsprite("editor-abs/logic_branch_listener") = logic_branch_listener : "Contains a list of logic_branch entities and fires outputs when the state of any of the logic_branches changes. This entity is used to fire an event when a set of conditions are all satisfied." [
	Branch01(target_destination) : "Logic Branch 01" :  : "The name of one or more logic_branches to watch (wildcards allowed)."
	Branch02(target_destination) : "Logic Branch 02" :  : "The name of one or more logic_branches to watch (wildcards allowed)."
	Branch03(target_destination) : "Logic Branch 03" :  : "The name of one or more logic_branches to watch (wildcards allowed)."
	Branch04(target_destination) : "Logic Branch 04" :  : "The name of one or more logic_branches to watch (wildcards allowed)."
	Branch05(target_destination) : "Logic Branch 05" :  : "The name of one or more logic_branches to watch (wildcards allowed)."
	Branch06(target_destination) : "Logic Branch 06" :  : "The name of one or more logic_branches to watch (wildcards allowed)."
	Branch07(target_destination) : "Logic Branch 07" :  : "The name of one or more logic_branches to watch (wildcards allowed)."
	Branch08(target_destination) : "Logic Branch 08" :  : "The name of one or more logic_branches to watch (wildcards allowed)."
	Branch09(target_destination) : "Logic Branch 09" :  : "The name of one or more logic_branches to watch (wildcards allowed)."
	Branch10(target_destination) : "Logic Branch 10" :  : "The name of one or more logic_branches to watch (wildcards allowed)."
	Branch11(target_destination) : "Logic Branch 11" :  : "The name of one or more logic_branches to watch (wildcards allowed)."
	Branch12(target_destination) : "Logic Branch 12" :  : "The name of one or more logic_branches to watch (wildcards allowed)."
	Branch13(target_destination) : "Logic Branch 13" :  : "The name of one or more logic_branches to watch (wildcards allowed)."
	Branch14(target_destination) : "Logic Branch 14" :  : "The name of one or more logic_branches to watch (wildcards allowed)."
	Branch15(target_destination) : "Logic Branch 15" :  : "The name of one or more logic_branches to watch (wildcards allowed)."
	Branch16(target_destination) : "Logic Branch 16" :  : "The name of one or more logic_branches to watch (wildcards allowed)."

	input Test(void) : "Tests the state of all the logic_branches in the list and fires the appropriate output."
	// NOTE FROM FICOOL: Hammer doesn't like the _ at the beginning, these outputs don't seem to do anything
	input _OnLogicBranchChanged(void) : "Sent automatically by a logic_branch when its state changes. Makes the listener re-check its branches for updates, and fire an output if its final result has changed."
	input _OnLogicBranchRemoved(void) : "Sent automatically by a logic_branch (with said branch as the !activator) when it should no longer be watched by the listener. Makes the listener remove the !activator from its list of branches to watch, re-check its remaining branches, and fire an output if its final result has changed."

	output OnAllTrue(void) : "Fired when all the logic_branches in the list become true."
	output OnAllFalse(void) : "Fired when all the logic_branches in the list become false."
	output OnMixed(void) : "Fired when one of the logic_branches in the list changes, such that some are true and some are false."
] // end logic_branch_listener

@PointClass base(SBaseLogical, SBaseDiv) color(100 255 100) iconsprite("editor/logic_case") = logic_case : "Compares an input to up to 16 preset values. If the input value is the same as any of the preset values, an output corresponding to that value is fired. For example: if Case01 is set to 2 and Case02 is set to 5, and the input value is 5, the OnCase02 output will be fired. This entity can also be used to select from a number of random targets via the PickRandom input. One of the OnCase outputs with a connection (even a broken connection) will be selected at random and fired.\n" +
	"NOTE: logic_case compares its values as strings, not as numbers; this means that the values '1', '1.0', and '01' would all be not equal despite representing the same numerical value. When testing numerical values, remove any unnecessary leading and trailing zeros from your Case Values." [
	Case01(string) : "Case 01 Value"
	Case02(string) : "Case 02 Value"
	Case03(string) : "Case 03 Value"
	Case04(string) : "Case 04 Value"
	Case05(string) : "Case 05 Value"
	Case06(string) : "Case 06 Value"
	Case07(string) : "Case 07 Value"
	Case08(string) : "Case 08 Value"
	Case09(string) : "Case 09 Value"
	Case10(string) : "Case 10 Value"
	Case11(string) : "Case 11 Value"
	Case12(string) : "Case 12 Value"
	Case13(string) : "Case 13 Value"
	Case14(string) : "Case 14 Value"
	Case15(string) : "Case 15 Value"
	Case16(string) : "Case 16 Value"

	input InValue(string) : "Compares the input value to the case values, and fires the matching OnCase output. If no case value matches the input value, OnDefault is fired."
	input PickRandom(void) : "Fires a random OnCase output with at least one connection."
	input PickRandomShuffle(void) : "Fires a random OnCase output with at least one connection, with no repeats until all cases have been picked, at which point the shuffle starts over."

	output OnCase01(void) : "Fired when the InValue equals the Case01 value, or a PickRandom chooses this case."
	output OnCase02(void) : "Fired when the InValue equals the Case02 value, or a PickRandom chooses this case."
	output OnCase03(void) : "Fired when the InValue equals the Case03 value, or a PickRandom chooses this case."
	output OnCase04(void) : "Fired when the InValue equals the Case04 value, or a PickRandom chooses this case."
	output OnCase05(void) : "Fired when the InValue equals the Case05 value, or a PickRandom chooses this case."
	output OnCase06(void) : "Fired when the InValue equals the Case06 value, or a PickRandom chooses this case."
	output OnCase07(void) : "Fired when the InValue equals the Case07 value, or a PickRandom chooses this case."
	output OnCase08(void) : "Fired when the InValue equals the Case08 value, or a PickRandom chooses this case."
	output OnCase09(void) : "Fired when the InValue equals the Case09 value, or a PickRandom chooses this case."
	output OnCase10(void) : "Fired when the InValue equals the Case10 value, or a PickRandom chooses this case."
	output OnCase11(void) : "Fired when the InValue equals the Case11 value, or a PickRandom chooses this case."
	output OnCase12(void) : "Fired when the InValue equals the Case12 value, or a PickRandom chooses this case."
	output OnCase13(void) : "Fired when the InValue equals the Case13 value, or a PickRandom chooses this case."
	output OnCase14(void) : "Fired when the InValue equals the Case14 value, or a PickRandom chooses this case."
	output OnCase15(void) : "Fired when the InValue equals the Case15 value, or a PickRandom chooses this case."
	output OnCase16(void) : "Fired when the InValue equals the Case16 value, or a PickRandom chooses this case."
	output OnDefault(string) : "Fired when the InValue does not equal any of the case values, with the InValue as the parameter. This output is not used by PickRandom."
] // end logic_case

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/logic_choreographed_scene") = logic_choreographed_scene : "Manages a choreographed scene of one or more actors." [
	SceneFile(scene) : "Scene File" :  : "The VCD scene file to use."
	target1(target_destination) : "Target 1"
	target2(target_destination) : "Target 2"
	target3(target_destination) : "Target 3"
	target4(target_destination) : "Target 4"
	target5(target_destination) : "Target 5"
	target6(target_destination) : "Target 6"
	target7(target_destination) : "Target 7"
	target8(target_destination) : "Target 8"
	busyactor(choices) : "If an Actor is talking..." : 1 : "What to do if an actor this scene needs is already talking when this scene is told to start." = [
		0 : "Start immediately"
		1 : "Wait for actor to finish"
		2 : "Interrupt at next interrupt event"
		3 : "Cancel at next interrupt event"
	] // end busyactor
	onplayerdeath(choices) : "On Player Death" : 0 : "What should this entity do if the player dies?" = [
		0 : "Do Nothing"
		1 : "Cancel Script and return to AI"
	] // end onplayerdeath

	input Cancel(void) : "Cancels playback of the scene."
	input CancelAtNextInterrupt(void) : "Cancels playback of the scene at the next interrupt event in the scene."
	input InterjectResponse(string) : "Finds an actor who can respond to the specified concept string while the scene continues playing."
	input Pause(void) : "Pauses playback of the scene file."
	input PitchShift(float) : "Multiplies the pitch of any sounds associated."
	input Resume(void) : "Resumes playback of the scene if it has been paused."
	input ResumeSceneFile(string) : "Resumes playback of the scene file specified."
	input Start(void) : "Starts playback of the scene file."
	input StopWaitingForActor(void) : "Stop waiting on an actor to stop talking."
	input Trigger(void) : "Trigger the manager."
	output OnCanceled(void) : "The scene has been canceled"
	output OnCompletion(void) : "The scene has completed"
	output OnStart(void) : "The scene has started"

	output OnTrigger1(void) : "Scene trigger 1"
	output OnTrigger2(void) : "Scene trigger 2"
	output OnTrigger3(void) : "Scene trigger 3"
	output OnTrigger4(void) : "Scene trigger 4"
	output OnTrigger5(void) : "Scene trigger 5"
	output OnTrigger6(void) : "Scene trigger 6"
	output OnTrigger7(void) : "Scene trigger 7"
	output OnTrigger8(void) : "Scene trigger 8"
	output OnTrigger9(void) : "Scene trigger 9"
	output OnTrigger10(void) : "Scene trigger 10"
	output OnTrigger11(void) : "Scene trigger 11"
	output OnTrigger12(void) : "Scene trigger 12"
	output OnTrigger13(void) : "Scene trigger 13"
	output OnTrigger14(void) : "Scene trigger 14"
	output OnTrigger15(void) : "Scene trigger 15"
	output OnTrigger16(void) : "Scene trigger 16"
] // end logic_choreographed_scene

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/logic_collision_pair") = logic_collision_pair : "An entity that can be used to enable/disable vphysics collisions between two target entities." [
	attach1(target_destination) : "Attachment 1" :  : "The first entity."
	attach2(target_destination) : "Attachment 2" :  : "The second entity."
	startdisabled(choices) : "Start with collisions disabled?" : 1 = [
		0 : "No"
		1 : "Yes"
	] // end startdisabled

	input DisableCollisions(void) : "Disable collisions between the first and second entity."
	input EnableCollisions(void) : "Enable collisions between the first and second entity."
] // end logic_collision_pair

@PointClass base(SBaseLogical, SBaseDiv) color(100 255 100) iconsprite("editor/logic_compare") = logic_compare : "Compares two values. If the base value is less than the compare value, the OnLessThan output is fired. If the base value is equal to the compare value, the OnEqualTo output is fired. If the base value is greater than the compare value, the OnGreaterThan output is fired." [
	InitialValue(float) : "Base (Left) Value" : 0 : "Base value for comparison."
	CompareValue(float) : "Compare (Right) Value" : 0 : "The value to compare the base value against."

	input Compare(void) : "Compare the stored values and fire the appropriate outputs."
	input SetCompareValue(float) : "Set the compare (right) value to compare the base value against."
	input SetValue(float) : "Set the base (left) value for comparison."
	input SetValueCompare(float) : "Set the base (left) value for comparison and fire the appropriate outputs."

	output OnLessThan(float) : "Fired when the base value is less than the compare value. Sends the base value as data."
	output OnEqualTo(float) : "Fired when the base value is equal to the compare value. Sends the base value as data."
	output OnNotEqualTo(float) : "Fired when the base value is different from the compare value. Sends the base value as data."
	output OnGreaterThan(float) : "Fired when the base value is greater than the compare value. Sends the base value as data."
] // end logic_compare

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/logic_lineto") = logic_lineto : "An entity that calculates and outputs a vector from one entity to another." [
	source(target_destination) : "Start Entity" :  : "Name of the entity the line should start from."
	target(target_destination) : "End Entity" :  : "Name of the entity that line should end at."

	output Line(vector) : "Fired when the vector, from the start entity to the end entity, changes. Passes along the vector as a parameter."
] // end logic_lineto

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-abs/logic_measure_movement") = logic_measure_movement : "An entity that can measure the movement of an entity relative to another entity, and apply that movement to a third entity relative to a fourth entity. More specifically, the 'Entity to Move' is constantly teleported every game tick such that it's offset from the 'Movement Reference' is the same as the 'Entity to Measure's offset from the 'Measure Reference'." [
	MeasureTarget(target_destination) : "Entity to Measure" :  : "Entity whose movement you want to measure."
	MeasureReference(target_destination) : "Measure Reference" :  : "The movement of Entity to Measure will be measured relative to this entity."
	Target(target_destination) : "Entity to Move" :  : "This entity will be moved to mimic the motions of Entity to Measure."
	TargetReference(target_destination) : "Movement Reference" :  : "The Entity to Move will move relative to this entity."
	TargetScale(float) : "Movement Scale" : "1.0" : "A scale to divide the measured movements by, before applying those movements to the Entity to Move. 1 = target entity moves as much as the measured entity, 2 = target entity moves half as far as the measured entity, and 0.5 = target entity moves twice as far as the measured entity."
	MeasureType(choices) : "Measurement Type" : 0 : "" = [ // TODO: What does this do?
		0 : "Position"
		1 : "Eye position"
	] // end MeasureType

	input SetMeasureTarget(target_destination) : "Set the Entity to Measure, whose movement should be measured."
	input SetMeasureReference(target_destination) : "Set the Measure Reference entity."
	input SetTarget(target_destination) : "Set the Entity to Move, which will be moved to mimic the measured entity."
	input SetTargetReference(target_destination) : "Set the Movement Reference entity."
	input SetTargetScale(float) : "Set the scale to divide the measured movements by."
	input Enable(void) : "Enable the logic_measure_movement."
	input Disable(void) : "Disable the logic_measure_movement."
] // end logic_measure_movement

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor/logic_multicompare") = logic_multicompare : "Compares a set of input integers to each other. This entity stores a list of every input value it has ever received, and will compare them when it receives the CompareValues input. If all inputs are the same, the OnEqual output is fired. If any are different, the OnNotEqual output is fired. The list cannot be cleared manually and will only automatically clear on a round restart; use a point_template to remove and respawn the entity if this is a problem." [
	IntegerValue(integer) : "Compare Value (Optional)" :  : "An optional integer value to compare all input values to."
	ShouldComparetoValue(choices) : "Use Compare Value?" : 0 : "If set to yes, require all input integers to equal the specified Compare Value before the OnEqual output can be fired." = [
		0 : "No"
		1 : "Yes"
	] // end ShouldComparetoValue

	input InputValue(integer) : "Input a value."
	input CompareValues(void) : "Compares the values and fires appropriate outputs."

	output OnEqual(void) : "Fires if the values are equal."
	output OnNotEqual(void) : "Fires if the values are not equal."
] // end logic_multicompare

// TODO: Affects TFBots? (probably not)
@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/logic_navigation") = logic_navigation : "An entity that is used to set navigation properties on other entities. Useful to make NPCs ignore physics props in their way that they can easily push." [
	target(target_destination) : "Navigation Entity" :  : "Name of the entity to set navigation properties on."
	navprop(choices) : "Navigation Property" : "Ignore" : "Changes the navigation properties type." = [
		"Ignore" : "NPCs Ignore this when navigating (they'll bump into it)"
	] // end navprop

	spawnflags(flags) = [
		1 : "Start On" : 1
	] // end spawnflags

	input TurnOn(void) : "Turn On. The Navigation Entity will have its navigation properties set."
	input TurnOff(void) : "Turn Off. The Navigation Entity will have its navigation properties returned to the default settings."
	input Toggle(void) : "Toggle on/off."
] // end logic_navigation

@PointClass base(SBaseLogical, SBaseDiv, SEnableDisable, SToggle) color(100 150 255) iconsprite("editor/logic_relay") = logic_relay : "A message forwarder. Fires an OnTrigger output when it receives the Trigger input, and can be disabled to prevent this output from firing. Useful as an intermediary between one entity and another for turning on or off an I/O connection, or as a container for holding a set of outputs that can be triggered from multiple places. By default, a triggered logic_relay cannot be triggered again until all of its OnTrigger outputs have fired (it's 'sleep' period). This can be bypassed with the 'Allow Fast Retrigger' spawnflag or the 'EnableRefire' input." [
	spawnflags(flags) = [
		1 : "Only Trigger Once - Relay removes itself after firing OnSpawn or OnTrigger" : 0
		2 : "Allow Fast Retrigger - logic_relay doesn't 'sleep' after triggering, bad for performance in great numbers" : 0
	] // end spawnflags

	input CancelPending(void) : "Cancel any events fired by this relay that are currently pending in the I/O event queue due to an outstanding delay. This includes ALL outputs, not just OnTrigger. BUG: May crash the game if a logic_relay sends CancelPending directly to itself."
	input EnableRefire(void) : "Allows the logic_relay to fire again, if the Allow Fast Retrigger flag is unticked. Automatically fired after the last OnTrigger output is fired or this entity receives CancelPending, but can be manually sent to refire the trigger earlier."
	input Trigger(void) : "Trigger the relay, causing its OnTrigger output to fire if it is enabled."

	output OnSpawn(void) : "Fired when the relay is spawned. If the relay is set to only trigger once, it will delete itself after firing this output (if it has any OnSpawn connections)."
	output OnTrigger(void) : "Fired when the relay is triggered. If the relay is set to only trigger once, it will delete itself after firing this output."
] // end logic_relay

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/logic_scene_list_manager") = logic_scene_list_manager : "Manages a list of logic_choreographed_scene entities. Store choreo scenes in them in order that they will be played by other inputs. Whenever a scene plays, the manager will remove all scenes before that one in the list. The name of another logic_scene_list_manager can be entered in a slot instead of an invididual scene, which will cause all scenes in that manager to be removed when a later scene in this list is played." [
	scene0(target_destination) : "Scene 1" :  : "The name of a logic_choreographed_scene, or logic_scene_list_manager."
	scene1(target_destination) : "Scene 2" :  : "The name of a logic_choreographed_scene, or logic_scene_list_manager."
	scene2(target_destination) : "Scene 3" :  : "The name of a logic_choreographed_scene, or logic_scene_list_manager."
	scene3(target_destination) : "Scene 4" :  : "The name of a logic_choreographed_scene, or logic_scene_list_manager."
	scene4(target_destination) : "Scene 5" :  : "The name of a logic_choreographed_scene, or logic_scene_list_manager."
	scene5(target_destination) : "Scene 6" :  : "The name of a logic_choreographed_scene, or logic_scene_list_manager."
	scene6(target_destination) : "Scene 7" :  : "The name of a logic_choreographed_scene, or logic_scene_list_manager."
	scene7(target_destination) : "Scene 8" :  : "The name of a logic_choreographed_scene, or logic_scene_list_manager."
	scene8(target_destination) : "Scene 9" :  : "The name of a logic_choreographed_scene, or logic_scene_list_manager."
	scene9(target_destination) : "Scene 10" :  : "The name of a logic_choreographed_scene, or logic_scene_list_manager."
	scene10(target_destination) : "Scene 11" :  : "The name of a logic_choreographed_scene, or logic_scene_list_manager."
	scene11(target_destination) : "Scene 12" :  : "The name of a logic_choreographed_scene, or logic_scene_list_manager."
	scene12(target_destination) : "Scene 13" :  : "The name of a logic_choreographed_scene, or logic_scene_list_manager."
	scene13(target_destination) : "Scene 14" :  : "The name of a logic_choreographed_scene, or logic_scene_list_manager."
	scene14(target_destination) : "Scene 15" :  : "The name of a logic_choreographed_scene, or logic_scene_list_manager."
	scene15(target_destination) : "Scene 16" :  : "The name of a logic_choreographed_scene, or logic_scene_list_manager."

	input Shutdown(void) : "Remove the manager and all scenes referenced by it (and all scenes referenced by logic_scene_list_manager's embedded in this one)."
] // end logic_scene_list_manager

// TODO: Does disabling this entity reset its timer?
@PointClass base(SBaseLogical, SBaseDiv, SEnableDisable, SToggle) color(100 255 100) iconsprite("editor/logic_timer") = logic_timer : "An entity that fires a timer event at regular, or random, intervals. It can also be set to oscillate between a high and low end, in which case it will fire alternating high/low outputs each time it fires. This entity uses a high amount of server bandwidth, especially with low refire intervals. Use a I/O loop with an entity such as logic_relay for those cases." [
	RefireTime(float) : "Refire Interval" :  : "If 'Use Random Time' is disabled, this is the time between timer fires, in seconds."
	LowerRandomBound(float) : "Minimum Random Interval" :  : "If 'Use Random Time' is enabled, this is the minimum time between timer fires. The time will be a random number between this and the 'Maximum Random Interval'."
	UpperRandomBound(float) : "Maximum Random Interval" :  : "If 'Use Random Time' is enabled, this is the maximum time between timer fires. The time will be a random number between the 'Minimum Random Interval' and this."
	UseRandomTime(choices) : "Use Random Time?" : 0 = [
		0 : "No"
		1 : "Yes"
	] // end UseRandomTime

	spawnflags(flags) = [
		1 : "Oscillator (alternates between OnTimerHigh and OnTimerLow outputs)" : 0
	] // end spawnflags

	input FireTimer(void) : "Force the timer to fire immediately."
	input RefireTime(integer) : "Set a new Refire Interval."
	input ResetTimer(void) : "Reset the timer. It will fire after the Refire Interval expires."

	input AddToTimer(float) : "Add time to the timer if it is currently enabled. Does not change the Refire Interval."
	input LowerRandomBound(float) : "Set a new Minimum Random Interval."
	input SubtractFromTimer(float) : "Subtract time from the timer if it is currently enabled. Does not change the Refire Interval."
	input UpperRandomBound(float) : "Set a new Maximum Random Interval."

	output OnTimer(void) : "Fired when the timer expires." // TODO: Fires even when oscillating?
	output OnTimerHigh(void) : "Fired every other time for an oscillating timer."
	output OnTimerLow(void) : "Fired every other time for an oscillating timer."
] // end logic_timer



	// MAPOBJ ENTITIES //

@PointClass base(SBaseEntity, SBaseDiv, SEngieBuilding, SDispenserTrigger, SClassDiv1, SDispenserTriggerDefault) iconsprite("editor-ficool2/mapobj_cart_dispenser") wirebox(helper_trigger_mins, helper_trigger_maxs)  = mapobj_cart_dispenser : "The origin point of the healing stream provided by a dispenser_touch_trigger, typically placed on the Payload cart." [
	input FireHalloweenBonus(integer) : "Trigger bonus effect on players near this dispenser." // TODO: What does this do?
	input SetDispenserLevel(integer) : "Set the dispenser level: 1, 2, or 3" // TODO: Normal dispensers don't have this? Also is this really clamped?
] // end mapobj_cart_dispenser



	// MATERIAL ENTITIES //

@PointClass base(SBaseLogical, SBaseDiv, SParentname) color(100 255 100) iconsprite("editor-ficool2/material_modify_control") = material_modify_control : "An entity that can be used to directly control material variables on its parent. The .vmt of the material you intend to change must have the MaterialModify or MaterialModifyAnimated proxy.\n" +
	"BUG: If a material_modify_control is told to StartAnimSequence or StartFloatLerp, the material will not begin animating until the material_modify_control's target entity is being rendered (within the viewer's PVS and FOV) and the material is being rendered on that entity (material is facing the viewer).\n" +
	"NOTE: Under some circumstances, this entity may also control instances of the specified material that are not associated with any material_modify_control entity. This includes any instance of the material which falls under at least one of the following categories:\n" +
	"-The material is applied to the world.\n" +
	"-The material is applied to an entity that does NOT have an associated material_modify_control.\n" +
	"-The material is applied to an entity that does have an associated material_modify_control, but that material_modify_control has not received any inputs to modify its target entity since the start of the current round.\n" +
	"Under any of these conditions, that instance of the material will be controlled by a random material_modify_control whose target entity is being rendered with its material. This may be beneficial in certain circumstances, such as to control a displacement's material (which usually cannot be directly controlled). If multiple candidate material_modify_control entities are present, the game will seemingly randomly switch between them based on the viewer's orientation in the world." [
	parentname(target_destination) : "Entity to Modify (Parent)" :  : "REQUIRED: The name of an entity with the specified material, which will be modified."

	materialName(material) : "Material to Modify" :  : "The material .vmt file to modify, without the extension. The specified material must have either the MaterialModify or MaterialModifyAnimated proxy."
	materialVar(string) : "Material Variable to Modify" :  : "The variable in the .vmt to modify, including the $. This can be a custom material variable, which can be used to affect other material variables via proxies. The material variable will not reset between rounds and must be reset manually. Not all material variables are fully supported."

	input SetMaterialVar(string) : "Fire to modify the specified material variable. The argument is the value to set the variable to."
	input SetMaterialVarToCurrentTime(void) : "This sets the material variable to the current time on the server."
	input StartAnimSequence(string) : "Force an animated material with the MaterialModifyAnimated proxy to play a set of animation frames. Format is: <Frame Start> <Frame End> <Frame Rate> <Loop?>. Setting <Frame End> to -1 uses the last frame of the texture. <Loop?> should be 1 or 0."
	input StartFloatLerp(string) : "Force a material to linearly interpolate the specified material var between two floating point values, smoothly transitioning from the start value to the end value. Format is: <Start Value> <End Value> <Transition Time> <Loop?>. <Loop?> should be 1 or 0."
] // end material_modify_control



	// MATH ENTITIES //

@PointClass base(SBaseLogical, SBaseDiv) color (100 255 100) iconsprite("editor-ficool2/math_colorblend") = math_colorblend : "An entity that remaps a range of input float values into a range of output color values, with alpha. This entity functions similarly to math_remap, except that the output value is a color instead of a float." [
	inmin(float) : "Lower Input Value" : "0.0" : ""
	inmax(float) : "Upper Input Value" : "1.0" : ""
	colormin(color255) : "Lower Output Value" : "0 0 0 255" : ""
	colormax(color255) : "Upper Output Value" : "255 255 255 255" : ""

	spawnflags(flags) = [
		1 : "Ignore out of range input values" : 1
	] // end spawnflags

	input InValue(float) : "Remap the input value and fire OutValue with the remapped value."

	output OutColor(color255) : "Fired when the InValue input is received, with the remapped color value as the parameter."
] // end math_colorblend

@PointClass base(SBaseLogical, SBaseDiv, SEnableDisable) color(100 255 100) iconsprite("editor/math_counter") = math_counter : "Stores a numeric value and performs arithmetic operations upon it. If either the minimum or maximum legal value is nonzero, the stored value will be clamped to the legal range, and the OnHitMin/OnHitMax outputs will be fired when the value reaches the minimum or maximum (respectively). If both the minimum and maximum are set to zero, no clamping is performed. While disabled, the counter's value is read-only." [
	startvalue(integer) : "Initial Value" : 0 : "Starting value for the counter."
	min(float) : "Minimum Legal Value" : 0 : "Minimum legal value for the counter. If minimum = 0 and maximum = 0, no clamping is performed."
	max(float) : "Maximum Legal Value" : 0 : "Maximum legal value for the counter. If minimum = 0 and maximum = 0, no clamping is performed."

	input Add(float) : "Add an amount to the counter and fire the OutValue output with the result."
	input Divide(float): "Divide the counter by an amount and fire the OutValue output with the result. Divisions by 0 will be ignored."
	input Multiply(float): "Multiply the counter by an amount and fire the OutValue output with the result."
	input SetHitMax(float): "Set the upper bound of the counter, and clamp the current value if necessary."
	input SetHitMin(float): "Set the lower bound of the counter, and clamp the current value if necessary."
	input SetValue(float): "Set the counter to a new value and fire the OutValue output with the result."
	input SetValueNoFire(float): "Set the counter to a new value without firing any outputs."
	input Subtract(float): "Subtract an amount from the counter and fire the OutValue output with the result."

	input GetValue(void): "Causes the counter to fire its OnGetValue output with the current value of the counter. Used for polling the counter when you don't want constant updates from the OutValue output."

	output OnGetValue(float) : "Fired in response to the GetValue input, with the counter's current value as the parameter. Unlike with other outputs, the !caller of this output is the !caller of the GetValue input." // TODO: Does this also mess with !self?
	output OnHitMax(void) : "Fired when the counter value meets or exceeds the max value. The counter must go below the max value before the output will fire again."
	output OnHitMin(void) : "Fired when the counter value meets or goes below the min value. The counter must go back above the min value before the output will fire again."
	output OutValue(float) : "Fired when the counter value changes."
] // end math_counter

@PointClass base(SBaseLogical, SBaseDiv, SEnableDisable) color(100 255 100) iconsprite("editor-abs/math_remap") = math_remap : "An entity that remaps a range of input values to a given range of output values. When the InValue is equivalent to the Lower Input Value, OutValue will return the Lower Output Value. When the InValue is equivalent to the Upper Input Value, OutValue will return the Upper Output Value. When the InValue is between the two input values, the OutValue will be a value between the two output values, proportionally scaled. Take this example scenario:\n" +
	"Lower Input Value = 1\n" +
	"Upper Input Value = 2\n" +
	"Lower Output Value = 12\n" +
	"Upper Output Value = 16\n" +
	"If a math_remap entity with the above settings receives 1.25 as the InValue, it will return 13 as the OutValue, as 1.25 is 1/4th of the way between 1 and 2, and 13 is 1/4th of the way between 12 and 16.\n" +
	"The precise mathematical formula followed by this entity is as follows:" +
	"<Lower Output> + ((<InValue> - <Lower Input>) * (<Upper Output> - <Lower Output>) / (<Upper Input> - <Lower Input>))" [
	in1(integer) : "Lower Input Value" :  : "The lower bound of input values. If Ignoring is enabled, input values below this value will not fire OutValue. If Clamping is enabled, input values below this value will be treated as this value."
	in2(integer) : "Upper Input Value" :  : "The upper bound of input values. If Ignoring is enabled, input values above this value will not fire OutValue. If Clamping is enabled, input values above this value will be treated as this value."
	out1(integer) : "Lower Output Value" :  : "The lower bound of output values. When the input value is equal to 'Lower Input Value', this will be the output value."
	out2(integer) : "Upper Output Value" :  : "The upper bound of output values. When the input value is equal to 'Upper Input Value', this will be the output value."
	// flRemappedValue = m_flOut1 + (((flValue - m_flInMin) * (m_flOut2 - m_flOut1)) / (m_flInMax - m_flInMin))

	spawnflags(flags) = [
		1 : "Ignore out of range input values" : 1
		2 : "Clamp output to output range" : 1
	] // end spawnflags

	input InValue(float) : "Remap the input value and fire OutValue with the remapped value."

	output OutValue(float) : "Fired when the InValue input is received, with the remapped value as the parameter."
] // end math_remap



	// MERASMUS ENTITIES //

@PointClass base(SBaseEntity, SBaseDynamicModel) color(150 0 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/bots/merasmus/merasmus.mdl") = merasmus : "Merasmus, a boss NextBot. Will not work without a .nav file for the map and won't respawn after death. He will walk around a map, pursuing and attacking players, and occasionally teleporting to another location. Uses the following entities:\n" +
	"-A func_nav_prefer entity named 'boss_nav_prefer', which is the entire volume Merasmus is allowed to wander in,\n" +
	"-info_target entities named 'boss_flying1', 'boss_flying2', 'boss_start' and 'boss_end',\n" +
	"-info_target entities named 'spawn_loot_red' and 'spawn_loot_blue', which are used as teleport destinations when they touch the Bombonomicon that remains after defeating Merasmus." [
] // end merasmus

@PointClass base(SDoesNotFunction, SBaseEntity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/bots/merasmus/merasmus.mdl") = merasmus_dancer : "Unused or unfinished entity. A green, static Merasmus model with teleport sound effects and a large green cloud of particles upon spawning." [
] // end merasmus_dancer



	// MONSTER ENTITIES //

@PointClass base(SModel, SBaseEntity, SBaseDiv, SModelSkin, SModelBodyGroup, SBaseNPC, SBaseDynamicModel) color(150 0 200) sphere(fademindist) sphere(fademaxdist) studioprop() = monster_generic : "Obsolete entity from Half-Life, used as a generic NPC. Identical to monster_furniture although lacks PlayerCollision inputs." [
] // end monster_generic



	// MULTISOURCE ENTITIES //

// TODO: Does this have any use?
@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor/obsolete") = multisource : "Half-Life legacy entity. Obsoleted by I/O in Source. Entity which lets mechanisms be created. It is the only entity that can be used as a 'master'." [ // iconsprite("editor-ficool2/multisource")
	target(target_destination) : "Target" :  : "Entity to activate."
	globalstate(integer) : "Globalstate" :  : "Unknown function."

	output OnTrigger(void) : "Fired when the entity is triggered."
] // end multisource



	// NPC ENTITIES //

@PointClass base(SModel, SBaseEntity, SBaseDiv, SModelSkin, SModelBodyGroup, SBaseNPC, SBaseDynamicModel) color(150 0 200) sphere(fademindist) sphere(fademaxdist) studioprop() = npc_furniture : "An entity used when an otherwise inanimate object needs to synchronise animation with an NPC in a scene or scripted_sequence. This usually means a piece of furniture or a door that an NPC needs to manipulate." [
	input DisablePlayerCollision(void) : "Enable the player to collide with this entity."
	input EnablePlayerCollision(void) : "Disable the player from colliding with this entity."
] // end npc_furniture

@PointClass base(npc_furniture) color(150 0 200) studioprop() = monster_furniture : "Obsolete entity from Half-Life, used as a scene prop." [
	input DisablePlayerCollision(void) : "Enable the player to collide with this entity."
	input EnablePlayerCollision(void) : "Disable the player from colliding with this entity."
] // end monster_furniture

@PointClass base(SBaseEntity, SBaseDynamicModel) color(150 0 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/weapons/w_grenade.mdl") = npc_handgrenade : "Half-Life 2 grenade entity. Spawns a Half-Life 2 grenade model and then explodes shortly after." [
] // end npc_handgrenade

@PointClass base(SBaseEntity, SBaseDiv, SEnableDisable, SToggle) color(150 0 200) iconsprite("editor-ficool2/npc_maker") = npc_maker : "Spawns a class of NPC at its position when told to. Typically used to provide a continuous wave of attackers during an ambush, or to replace killed enemies in a standoff-type situation." [
	MaxNPCCount(integer) : "Num. of NPCs" : 1 : "Number of NPCs that will spawn before this spawner is exhausted."
	SpawnFrequency(string) : "Frequency" : 5 : "How often (in seconds) a new NPC will be spawned. If set to -1, a new NPC will be made when the last NPC dies."
	MaxLiveChildren(integer) : "Max Live NPCs" : 5 : "Maximum number of live children allowed at any one time (new ones will not be made until one dies). If set to -1, no limit is applied."
	NPCType(npcclass) : "Class name of spawned NPC" :  :" Class of all NPCs spawned by this entity."
	NPCTargetname(target_source) : "Childrens' Name" :  : "Targetname of all NPCs spawned by this entity."
	NPCSquadname(string) : "Childrens' Squad Name" :  : "Squad name of all NPCs spawned by this entity."
	NPCHintGroup(string) : "Childrens' Hint Group" :  : "Hintgroup of all NPCs spawned by this entity."
	relationship(string) : "Relationship" :  : "Changes whether the spawned NPC likes or dislikes certain others. Format is: <string|targetname or classname> <string|disposition> <integer|rank>. Values for disposition are: D_HT (Hate), D_FR (Fear), D_LI (Like), D_NU, (Neutral)."
	additionalequipment(string) : "Weapons" :  : "The classname of the weapon to spawn the NPCs with."

	spawnflags(flags) = [
		16 : "Fade Corpse, otherwise remain permanently, even between rounds" : 0
		32 : "Infinite Children" : 0
		64 : "Do not drop equipment" : 0
		128 : "Don't spawn while visible" : 0
	] // end spawnflags

	input AddMaxChildren(integer) : "Adds to the number of NPCs that can spawn before the spawner is exhausted. If an exhausted spawner is given some children to spawn, it still wont begin spawning until it is re-enabled with the Enable input."
	input SetMaxChildren(integer) : "Sets the number of NPCs that can spawn before the spawner is exhausted. If an exhausted spawner is given some children to spawn, it still won't begin spawning until it is re-enabled with the Enable input."
	input SetMaxLiveChildren(integer) : "Sets the maximum number of NPCs that can be alive at any one time from this spawner."
	input SetSpawnFrequency(float) : "Sets how often (in seconds) a new NPC will be spawned."
	input Spawn(void) : "Spawns an NPC."

	output OnAllLiveChildrenDead(void) : "Fired when all spawned children have died. This does not mean the spawned is exhausted, so a new child may be spawned any time after this (unless the maker is disabled)."
	output OnAllSpawned(void) : "Fired when the spawned is exhausted (all children have been spawned)."
	output OnAllSpawnedDead(void) : "Fired when the spawner is exhausted (all children have been spawned) and all spawned children have died."
	output OnSpawnNPC(string) : "Fired when an NPC is spawned. The activator is the NPC, and the string is the name of the NPC."
] // end npc_maker

@PointClass base(SBaseEntity, SBaseDiv, SEnableDisable, SToggle) color(150 0 200) iconsprite("editor-ficool2/npc_template_maker") sphere(radius) = npc_template_maker : "An entity that creates NPCs. The NPCs it creates are clones of a template NPC. NPCs are spawned around this maker's origin, or at specified destination points. The NPC must have the 'Template NPC' spawnflag ticked." [
	TemplateName(target_destination) : "Name of template NPC" :  : "Template NPC that this maker should be creating clones of."
	Radius(float) : "Radius" : 256 : "Radius around this maker within which NPCs are to be placed. Spawned NPCs will try and find empty space within this radius to spawn."
	DestinationGroup(target_destination) : "Name of Destination Group" :  : "If you'd like spawned NPCs to be created at an info_npc_spawn_destination entity, enter the name of that entity here. If you have more than one destination entity by that name, the Destination Criteria will be used to select one from the group."
	CriterionVisibility(Choices) : "Dest. Criterion: Visible to player?" : 2 : "Should the NPC try to spawn at a destination that the player can see? Only applicable if a Destination Group is being used." = [
		0 : "Yes"
		1 : "No"
		2 : "Don't Care"
	] // end CriterionVisibility
	CriterionDistance(Choices) : "Dest. Criterion: Distance to player?" : 2 : "Should the NPC try to spawn nearest to or farthest from the player's current location? Only applicable if a Destination Group is being used." = [
		0 : "Nearest"
		1 : "Farthest"
		2 : "Don't Care"
	] // end CriterionDistance
	MinSpawnDistance(integer) : "Minimum spawn distance from player" : 0 : "The spawn destination node distance to the player will have to be further or equal than this value."
	MaxNPCCount(integer) : "Num. of NPCs" : 1 : "Number of NPCs that will spawn before this spawner is exhausted."
	SpawnFrequency(string) : "Frequency" : "5" : "How often (in seconds) a new NPC will be spawned. If set to -1, a new NPC will be made when the last NPC dies."
	MaxLiveChildren(integer) : "Max Live NPCs" : 5 : "Maximum number of live children allowed at any one time (new ones will not be made until one dies). If set to -1, no limit is applied."

	spawnflags(flags) = [
		16 : "Fade Corpse" : 0
		32 : "Infinite Children" : 0
		64 : "Do Not Drop" : 0
		128 : "Don't Spawn While Visible" : 0
		256 : "Always use radius spawn" : 0
		512 : "Don't preload template models" : 0
	] // end spawnflags

	input AddMaxChildren(integer) : "Adds to the number of NPCs that can spawn before the spawner is exhausted. If an exhausted spawner is given some children to spawn, it still wont begin spawning until it is re-enabled with the Enable input."
	input ChangeDestinationGroup(string) : "Switch to a different set of Destination entities."
	input SetMaxChildren(integer) : "Sets the number of NPCs that can spawn before the spawner is exhausted. If an exhausted spawner is given some children to spawn, it still won't begin spawning until it is re-enabled with the Enable input."
	input SetMaxLiveChildren(integer) : "Sets the maximum number of NPCs that can be alive at any one time from this spawner."
	input SetMinimumSpawnDistance(integer) : "Set the minimum spawn distance from player to destination node."
	input SetSpawnFrequency(float) : "Sets how often (in seconds) a new NPC will be spawned."

	input Spawn(void) : "Spawns an NPC."
	input SpawnMultiple(integer) : "Spawn multiple NPCs (uses destination group, else radius)."
	input SpawnNPCInLine(void) : "Spawn an NPC somewhere within a line behind the maker."
	input SpawnNPCInRadius(void) : "Spawn an NPC somewhere within the maker's radius."

	output OnAllLiveChildrenDead(void) : "Fired when all spawned children have died. This does not mean the spawned is exhausted, so a new child may be spawned any time after this (unless the maker is disabled)."
	output OnAllSpawned(void) : "Fired when the spawned is exhausted (all children have been spawned)."
	output OnAllSpawnedDead(void) : "Fired when the spawner is exhausted (all children have been spawned) and all spawned children have died."
	output OnSpawnNPC(string) : "Fired when an NPC is spawned. The activator is the NPC, and the string is the name of the NPC."
] // end npc_template_maker

@BaseClass = npc_vehicledriver_keys [
	vehicle(target_destination) : "Vehicle" :  : "Vehicle entity to drive."
	driverminspeed(float) : "Minimum Speed" : "0.0" : "Minimum speed that the NPC can drive, as a multiple of the vehicle's maximum speed."
	drivermaxspeed(float) : "Maximum Speed" : "1.0" : "Maximum speed that the NPC can drive, as a multiple of the vehicle's maximum speed."
] // end npc_vehicledriver_keys
@PointClass base(SBaseEntity, SBaseDiv, npc_vehicledriver_keys, SBaseNPC) color(150 0 200) studioprop("models/roller.mdl") = npc_vehicledriver : "Invisible NPC used to drive a target vehicle." [
	spawnflags(flags) = [
		65536 : "Start Inactive" : 1
	] // end spawnflags

	input GotoPathCorner(string) : "Tell the driver to go to a specific path_corner and continue from there."
	input SetDriversMaxSpeed(float) : "Set the Maximum speed (percentage of vehicle's maximum speed)."
	input SetDriversMinSpeed(float) : "Set the Minimum speed (percentage of vehicle's maximum speed)."
	input StartFiring(void) : "Tell the driver to attack nearby enemies with the vehicle's weaponry (if any)"
	input StartForward(void) : "Tell the driver to start driving."
	input Stop(void) : "Tell the driver to stop driving."
	input StopFiring(void) : "Tell the driver to stop attacking nearby enemies with the vehicle's weaponry."
] // end npc_vehicledriver



	// OBJ ENTITIES //

// Does nothing on mapobj_cart_dispenser and obj_teleporter
@BaseClass = SSolidAllies [
	//SolidToPlayer(choices) : "Solid to Allies?" : 0 : "Determines whether this object should be solid to players on its own team. Enemies and the builder of the object will always be solid to the object." = [
	//	0 : "No"
	//	1 : "Yes"
	//] // end SolidToPlayer
	SolidToPlayer(choices) : "Solid to Allies?" : 0 : "Determines whether this object should be solid to players on its own team. Sentry guns and dispensers are by default nonsolid to allies, while teleporters are by default always solid. Nonsolid teleporters may not be able to be used." = [
		// Setting/changing this value causes the object to call SetCollisionGroup() on itself, passing TFCOLLISION_GROUP_OBJECT_SOLIDTOPLAYERMOVEMENT if the object's IsSolidToPlayers() method returns true, and otherwise passing TFCOLLISION_GROUP_OBJECT. This value affects what IsSolidToPlayers() returns.
		0 : "Default" // SOLID_TO_PLAYER_USE_DEFAULT // Returns GetObjectInfo(ObjectType())->m_bSolidToPlayerMovement.
		1 : "Yes" // SOLID_TO_PLAYER_YES // Returns true always.
		2 : "No" // SOLID_TO_PLAYER_NO // Returns false always.
	] // end SolidToPlayer
] // end SolidAllies

@PointClass base(SHelperModel, SBaseEntity, SBaseDiv, SEngieBuilding, SSolidAllies, SDispenserTrigger, SBaseDynamicModel, SClassDiv1, SDispenserTriggerDefault) sphere(fademindist) sphere(fademaxdist) studioprop() wirebox(helper_trigger_mins, helper_trigger_maxs) = obj_dispenser : "The Dispenser. Gives health and ammunition to nearby players. The entity also spawns a vgui_screen entity, used for the metal counter screen." [
	model(choices) : "Helper Model (Hammer Only)" : "models/buildables/dispenser_light.mdl" : "Model this entity should appear as in Hammer, to assist with placement or identification. Any model can be specified, not just ones listed here. This will NOT affect how the entity appears in-game." = [
		"" : "None"
		"models/buildables/dispenser_light.mdl" : "Level 1 Dispenser"
		"models/buildables/dispenser_lvl2_light.mdl" : "Level 2 Dispenser"
		"models/buildables/dispenser_lvl3_light.mdl" : "Level 3 Dispenser"
		"models/buildables/dispenser_blueprint.mdl" : "Blueprint"
		"models/editor/cone_helper.mdl" : "Blue Cone Helper"
		"models/editor-ficool2/cone_helper_gray.mdl" : "Gray Cone Helper"
		"models/editor/axis_helper_thick.mdl" : "Thick Axis Helper"
		"models/editor/camera.mdl" : "Camera Helper"
	] // end model
	modelscale(float) : "Model Scale" : "1.0" : "A multiplier for the size of the model. The dispenser's metal counter screen will scale improperly."
] // end obj_dispenser

@PointClass base(SHelperModel, SBaseEntity, SBaseDiv, SEngieBuilding, SSolidAllies, SBaseDynamicModel, SClassDiv1) sphere(fademindist) sphere(fademaxdist) sphere(rangehelper) studioprop() = obj_sentrygun : "The Sentry Gun is a defensive building that automatically targets and fires at enemies in-range." [
	model(choices) : "Helper Model (Hammer Only)" : "models/buildables/sentry1.mdl" : "Model this entity should appear as in Hammer, to assist with placement or identification. Any model can be specified, not just ones listed here. This will NOT affect how the entity appears in-game." = [
		"" : "None"
		"models/buildables/sentry1.mdl" : "Level 1 Sentry"
		"models/buildables/sentry2.mdl" : "Level 2 Sentry"
		"models/buildables/sentry3.mdl" : "Level 3 Sentry"
		"models/buildables/sentry1_blueprint.mdl" : "Blueprint"
		"models/editor/cone_helper.mdl" : "Blue Cone Helper"
		"models/editor-ficool2/cone_helper_gray.mdl" : "Gray Cone Helper"
		"models/editor/axis_helper_thick.mdl" : "Thick Axis Helper"
		"models/editor/camera.mdl" : "Camera Helper"
	] // end model

	rangehelper(choices) readonly : "Sight Radius (Display Only)" : 1100 : "DO NOT CHANGE. Keyvalue to display the range of the Sentry Gun (1100HU) in Hammer to assist with placement. Changing this value WILL NOT change the range of the sentry; this is for display purposes only." = [
		1100 : "1100"
	] // end rangehelper

	spawnflags(flags) = [
		2 : "Invulnerable - Can still be sapped however" : 0
		4 : "Upgradeable" : 0
		8 : "Infinite Ammo" : 0
	] // end spawnflags
] // end obj_sentrygun

@BaseClass = obj_teleporter_keys [
	teleporterType(choices) : "Type" : 1 : "Whether this teleporter is an entrance or exit. Two-way teleporters can be made by specifying both as entrances." = [
		1 : "Entrance"
		2 : "Exit"
	] // end teleporterType
	matchingTeleporter(target_destination) : "Matching Teleporter" :  : "The teleporter linked to this one. Both teleporters much reference each other to function."
] // end obj_teleporter_keys
@PointClass base(SHelperModel, SBaseEntity, SBaseDiv, SEngieBuilding, SSolidAllies, obj_teleporter_keys, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop() = obj_teleporter : "The Teleporter. A teleporter deploys players from one end to the other. 2 obj_teleporters should have linked Matching Teleporter keyvalues to function." [
	model(choices) : "Helper Model (Hammer Only)" : "models/buildables/teleporter_light.mdl" : "Model this entity should appear as in Hammer, to assist with placement or identification. Any model can be specified, not just ones listed here. This will NOT affect how the entity appears in-game." = [
		"" : "None"
		"models/buildables/teleporter_light.mdl" : "Teleporter"
		"models/buildables/teleporter_blueprint_enter.mdl" : "Entrance Blueprint"
		"models/buildables/teleporter_blueprint_exit.mdl" : "Exit Blueprint"
		"models/editor/cone_helper.mdl" : "Blue Cone Helper"
		"models/editor-ficool2/cone_helper_gray.mdl" : "Gray Cone Helper"
		"models/editor/axis_helper_thick.mdl" : "Thick Axis Helper"
		"models/editor/camera.mdl" : "Camera Helper"
	] // end model
] // end obj_teleporter



	// PASSTIME ENTITIES //

@PointClass base(SModel, SBaseEntity, SBaseDiv, STFTeam, SModelSkin, SModelBodyGroup, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop() = passtime_ball : "The JACK/ball in the Passtime gamemode. Created automatically by the passtime_logic on PASStime maps; cannot be picked up if spawned manually." [
	model(studio) : "Model" : "models/passtime/ball/passtime_ball.mdl" : "The model this entity should appear as. 128-character limit."
] // end passtime_ball

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/passtime_logic") = passtime_logic : "Passtime gamemode logic." [
	num_sections(integer) : "Number of Sections" : 1 : "The number of distinct areas that this map has."
	ball_spawn_countdown(integer) : "Ball Spawn Countdown" : 15 : "The amount of time, in seconds, after the ball despawns (scored, timed out, or after SpawnBall input) before it should respawn."
	max_pass_range(float) : "Max Pass Range" : 0 : "The maximum distance, in HU, that the ball-carrier can be from an ally in order to be able to lock a pass onto that ally (0 = unlimited). If the ball carrier throws the ball while locked onto an ally, the ball will home in on that ally even if the ball carrier's aim is off. Players can still pass to allies outside this range, but the ball's homing ability will be disabled."

	input JumpPadUsed(void) : "Indicates that a player used a jump pad, for stats tracking."
	input SetSection(string) : "Send this at the start of a round to configure the player/goal/ball-tracking HUD. Parameter must be three space-delimited values, [section number] [name of first path_track] [name of last path_track]. The section must be a number within the range of 0 and (Number of Sections - 1). The path_tracks should be connected in a path that runs lengthwise down the map, connecting each team's goal areas. First path should be on Blu's side, last path should be on Red's side."
	input SpawnBall(void) : "Remove the current ball, and after the Ball Spawn Countdown, pick a random enabled info_passtime_ball_spawn and respawn the ball there."
	input SpeedBoostUsed(void) : "Indicates that a player used a speed boost, for stats tracking."
	input TimeUp(void) : "Input this from a round timer or something to indicate the game timer ended with no winner."

	input RoomTriggerOnTouch(void) : "Used to track which players have found the secret room on pass_brickyard, to determine who should receive the 'Tune Merasmus's Multi-Dimensional Television' achievement once it has been earned."
	input statica(void) : "Used to indicate when a player has started touching one of the slot triggers used for the secret 'Tune Merasmus's Multi-Dimensional Television' achievement. Only works on pass_brickyard."
	input staticb(void) : "Used to indicate when a player has stopped touching one of the slot triggers used for the secret 'Tune Merasmus's Multi-Dimensional Television' achievement. Only works on pass_brickyard."
	input staticc(void) : "Used to indicate that the plug for Merasmus's television has been destroyed, completing the 'Tune Merasmus's Multi-Dimensional Television' achievement. Only works on pass_brickyard."

	output OnBallFree(void) : "The ball is free - someone was holding it, and now they aren't."
	output OnBallGetAny(void) : "The ball was free and someone picked it up."
	output OnBallGetBlu(void) : "The ball was free and someone on Blu team picked it up."
	output OnBallGetRed(void) : "The ball was free and someone on Red team picked it up."
	output OnBallRemoved(void) : "The ball was removed by game rules and you should respawn it. (e.g. fell out of the world (func_passtime_goal with -1 points))."
	output OnScoreAny(void) : "Either team scored."
	output OnScoreBlu(void) : "BLU scored."
	output OnScoreRed(void) : "RED scored."
	output OnBallPowerDown(void) : "Experimental."
	output OnBallPowerUp(void) : "Experimental."
] // end passtime_logic



	// PATH ENTITIES //

@BaseClass base(SHelperModel, SBaseEntity, SBaseDiv) line (255 255 255, targetname, target) = SBasePath [
	parentname(target_destination) : "Parent" :  : "Specifies a movement parent. An entity will mimic the movements of its parent, maintaining its initial offset from its parent. An attachment point can optionally be added to the end of the name, separated by a comma. Entities following this path may follow it at an offset if the train and all of the tracks do not have the same parent. logic_measure_movement can be used as a workaround to parenting."

	target(target_destination) : "Next Path Target" :  : "The next path entity in the path."

	input InPass(void) : "Fires OnPass. Used to indicate that a path follower has passed this point."

	output OnPass(void) : "Fired when any entity following this path passes this node."
] // end BasePath

@PointClass base(SBasePath) color(150 0 200) iconsprite("editor-ficool2/path_corner") line(255 255 255, targetname, target) = path_corner : "Generic path point for moving entities such as NPCs. This entity is generally obsolete, use path_track instead." [
	speed(float) : "New Train Speed" : 0 : "If nonzero, when an entity reaches this path_track, it will set its speed to this speed. This speed must be a positive value that is less than the entity's max speed (if it has such). A value of 0 will cause no change in the entity's speed. For train entities, a positive value must be specified for them to properly reverse over the path."
	wait(integer) : "Wait Time" : 0 : "When passing this point, wait here for this many seconds."

	spawnflags(flags) = [
		1 : "Wait for retrigger" : 0
		2 : "Teleport to THIS path_corner" : 0
	] // end spawnflags

	input SetNextPathCorner(string) : "Sets next path_corner."
] // end path_corner

@PointClass base(path_corner) color(150 0 200) iconsprite("editor-ficool2/path_corner_crash") line(255 255 255, targetname, target) = path_corner_crash : "Identical to a path_corner, but when an NPC is searching for a crash point, it will search for this point instead." [
] // end path_corner_crash


@PointClass base(SBasePath) cylinder(255 255 255, targetname, targetname, radius, targetname, target, radius) cylinder(150 150 150, targetname, targetname, radius, targetname, altpath, radius) sidelist(sides) size(-1 -1 -48, 1 1 -8) line(255 255 255, targetname, target) line(150 150 150, targetname, altpath) iconsprite("editor-ficool2/path_track") sphere(radius) studio() = path_track : "An entity used to build paths for other entities to follow. Each path_track is a node on the path, each holding the name of the next path_track in the path." [
	model(choices) : "Helper Model (Hammer Only)" : "models/empty.mdl" : "Model this entity should appear as in Hammer, to assist with placement or identification. Any model can be specified, not just ones listed here. This will NOT affect how the entity appears in-game. If the Empty option causes this entity to disappear from the 3D view, you can still find it via the 2D view or Map -> Entity Report." = [
		"" : "None (Default Cube)" //This will actually place a cube instead, completely covering the iconsprite (if there is one). Use "No Model" if you just want to see the iconsprite.
		"models/empty.mdl" : "Empty (Check 2D view!)"
		"models/editor-puddy/hngineer.mdl" : "Dev Engineer by Puddy"
		"models/editor-abs/dev_engy.mdl" : "Dev Engineer by ABS"
		"models/editor/playerstart.mdl" : "Dev Gordon"
		"models/editor/cone_helper.mdl" : "Blue Cone Helper"
		"models/editor-ficool2/cone_helper_gray.mdl" : "Gray Cone Helper"
		"models/editor/axis_helper_thick.mdl" : "Thick Axis Helper"
		"models/editor/camera.mdl" : "Camera Helper"
	] // end model
	altpath(target_destination) : "Branch Path Target" :  : "An alternate entity to function as the next node in the path, which can be toggled on and off over the main path. Useful for making branching paths. By default, entities will be sent to the Next Path Target; use the ToggleAlternatePath / EnableAlternatePath inputs to make the Branch Path active. Not all entities pay attention to this."
	speed(float) : "New Train Speed" : 0 : "If nonzero, when an entity reaches this path_track, it will set its speed to this speed. This speed must be a positive value that is less than the entity's max speed (if it has such). A value of 0 will cause no change in the entity's speed. For train entities, a positive value must be specified for them to properly reverse over the path."
	orientationtype(choices) : "Orientation Type" : 1 : "The way that the path follower should face as it moves along this path." = [
		0 : "No change"
		1 : "Face direction of motion"
		2 : "Face this path_track's angles"
	] // end orientationtype
	radius(float) : "Path Radius" : 0 : "Used by NPCs who follow path_tracks (attack chopper/gunship). This tells them the maximum distance they're allowed to be from the path at this node."

	spawnflags(flags) = [
		1 :  "Start Disabled - Trains cannot move to this path while disabled" : 0
		8 :  "Disable Train - Activate 'No User Control' on passing trains" : 0
		//2 :  "Fire Once" : 0 // Doesn't do anything
		16 : "Teleport to THIS Track (when I am a forward-moving train's next path target)" : 0
		32768 : "Start Branch Path Enabled" : 0
		4 :  "Branch Reverse - Alternate path is used for reversing trains instead of forward trains" : 0
		32 : "Roll Back <- Zone on Payload HUD (auto-roll if team_train_watcher handles movement)" : 0
		64 : "Roll Forward -> Zone on Payload HUD (auto-roll if team_train_watcher handles movement)" : 0
	] // end spawnflags

	input DisableAlternatePath(void) : "Disable the alternate path for this track."
	input DisablePath(void) : "Disable this path_track. Trains cannot move onto disabled tracks; if a disabled track is next on the train's path, the train will stop immediately as though it has reached the end of its path."
	input EnableAlternatePath(void) : "Enable the alternate path for this track."
	input EnablePath(void) : "Enable the track and allow trains to move to it."
	input InTeleport(void) : "Fires OnTeleport. Used to indicate that a path follower has teleported to this point."
	input ToggleAlternatePath(void) : "Cause the track to toggle to/from its alternate path."
	input TogglePath(void) : "Cause the track to toggle between enabled and disabled."

	output OnTeleport(void) : "Fired when any entity following this path teleports directly to this path_track node."
] // end path_track



	// PD ENTITIES //

@PointClass base(SBaseEntity, SBaseDiv, SEngieBuilding, SDispenserTrigger, SDispenserTriggerDefault) wirebox(helper_trigger_mins, helper_trigger_maxs) = pd_dispenser : "Invisible dispenser granted to each team's leader (the player carrying the most points) in Player Destruction." [
	helper_trigger_mins(vector) : "Default Trigger (Display Only)" : "-450 -450 -450" : "Keyvalue to display the size of the default touch trigger. Has no effect in-game. If a tf_logic_player_destruction is present on the map, the value along each axis is determined by the tf_logic_player_destruction's Heal Distance keyvalue. Otherwise the default distance is 450HU."
	helper_trigger_maxs(vector) : "Default Trigger (Display Only)" : "450 450 450" : "Keyvalue to display the size of the default touch trigger. Has no effect in-game. If a tf_logic_player_destruction is present on the map, the value along each axis is determined by the tf_logic_player_destruction's Heal Distance keyvalue. Otherwise the default distance is 450HU."
] // end pd_dispenser



	// PHYS ENTITIES //

@PointClass base(SBaseConstraint) color(150 50 50) iconsprite("editor/phys_ballsocket") = phys_ballsocket : "A constraint that keeps the position of two objects fixed, relative to the constraint's origin. It does not affect rotation." [
] // end phys_ballsocket

@PointClass base(SBaseConstraint) color(150 50 50) studio("models/editor/axis_helper_thick.mdl") = phys_constraint : "A constraint that keeps the relative position and orientation of two objects fixed. Recommended to be used with phys_constraintsystem." [
] // end phys_constraint

@PointClass base(SBaseLogical, SBaseDiv) color(150 50 50) iconsprite("editor-ficool2/phys_constraintsystem")  = phys_constraintsystem : "An entity used to manage a group of interacting constraints and keep them stable. All constraints on a set of entities should be placed in the same system, or they will fight each other during simulation." [
	additionaliterations(integer) : "Additional System Iterations" : 0 : "Adding iterations makes the interactions among constraints in a system tighter.  It will not compensate for errors due to collision, but will help in cases where objects of disparate mass are constrained to each other."
] // end phys_constraintsystem

@PointClass base(SBaseLogical, SBaseDiv) color(150 50 50) iconsprite("editor-ficool2/phys_convert") = phys_convert : "Turns an arbitrary entity into a physically simulated entity. Brush entities will turn into simple_physics_brush and model entities will turn into simple_physics_prop." [
	target(target_destination) : "Entity to Convert" :  : "Name of the entity that will be converted to a physics object when the ConvertTarget input is fired."
	swapmodel(studio) : "Model Swap Entity" :  : "If specified, the model of the entity specified here will replace the model of the target object when it is converted."
	massoverride(float) : "Mass Override" : 0 : "Sets the mass when the object(s) are converted (0 means auto-calculate)."

	spawnflags(flags) = [
		1 : "Convert Asleep" : 0
		2 : "Convert As Debris" : 0
	] // end spawnflags

	input ConvertTarget(void) : "Converts this entity's target to a physically simulated object. Only name, model, and velocity are retained after conversion. No keyvalues, e.g. skin and color, are kept. AddOutput could be used as a workaround depending on the circumstances."

	output OnConvert(void) : "Fires after the conversion has taken place."
] // end phys_convert

@PointClass base(SBaseConstraint) color(150 50 50) iconsprite("editor-ficool2/phys_hinge") = phys_hinge : "A physically simulated hinge. Use the helper to define the axis of rotation." [
	hingeaxis(vecline) : "Hinge Axis" :  : ""
	hingefriction(float) : "Friction" : 0 : "Resistance/friction in the hinge"
	SystemLoadScale(float) : "Load Scale" : "1.0" : "Scale of the load connected to this hinge (1=just the objects directly connected)"
	minSoundThreshold(float) : "Minimum Sound Velocity" : 6 : "When travelling below this many units/sec, will not play any sound."
	maxSoundThreshold(float) : "Full Sound Velocity" : 80 : "When travelling at this speed or above, will play sound at full volume."
	slidesoundfwd(sound) : "Travel sound (forward)" :  : "Play this sound when travelling forward on helper axis"
	slidesoundback(sound) : "Travel sound (backward)" :  : "Play this sound when travelling backward on helper axis"

	input SetAngularVelocity(float) : "Set angular velocity around the hinge (motor) in deg/sec."
	input SetHingeFriction(float) : "Set the resistance/friction in the hinge."
] // end phys_hinge

@PointClass base(STargetname, SAngles, SBaseIO, SBaseDiv) color(150 50 50) iconsprite("editor-ficool2/phys_keepupright")  = phys_keepupright : "A controller that tries to keep an entity facing a particular direction. This works on parented entities, allowing their angles to be constrained." [
	attach1(target_destination) : "Target Entity" :  : "The entity to align to the desired angles."
	angularlimit(float) : "Angular Limit" : "15" : "The maximum angular velocity that this controller can compensate for, in degrees per second."

	spawnflags(flags) = [
		1 : "Start inactive" : 0
	] // end spawnflags

	input TurnOn(void) : "Enable the controller."
	input TurnOff(void) : "Disable the controller."
] // end phys_keepupright

@PointClass base(SBaseConstraint) color(150 50 50) studio("models/editor/axis_helper_thick.mdl") = phys_lengthconstraint : "A constraint that preserves the distance between two entities. If the 'Keep Rigid' flag is set, think of it as a rod. If not, think off it as a virtual rope." [
	addlength(float) : "Additional Length" : 0 : "Add (or subtract) this amount to the rest length of the rope."
	minlength(float) : "Minimum Length" : 0 : "If the constraint is not rigid, this is the minimum length it can be."
	attachpoint(vecline) : "Attached Object 2 Point" : "The position at which the rope attaches to Entity 2. For Entity 1, that point is the constraint's origin."

	spawnflags(flags) = [
		2 : "Keep Rigid - Prevent constrained objects from getting closer to each other" : 0
	] // end spawnflags
] // end phys_lengthconstraint

@BaseClass = phys_magnet_keys [
	forcelimit(float) : "Force Limit to Break (lbs)" : "0" : "The amount of force necessary to break a stuck object off the magnet. A way of calculating this is to set it to the mass of an object that would break this constraint if it were resting on the magnet."
	torquelimit(float) : "Torque Limit to Break (lbs * distance)" : "0" : "The amount of torque necessary to break a stuck object off the magnet. A way of calculating this is to multiply any reference mass by the resting distance (from the center of mass of the object) needed to break the constraint."
	massScale(float) : "Mass Scale" : "0" : "A scale multiplier for the object's mass."
	overridescript(string) : "Override parameters" :  : "A list of physics key/value pairs that are usually in a physics prop .qc file. Format is 'key,value,key,value,etc'."
	maxobjects(integer) : "Maximum Attached Objects" : 0 : "The maximum number of physics objects that can be stuck to the magnet at once. 0 = no limit."
] // end phys_magnet_keys
@PointClass base(SModel, SBaseEntity, SBaseDiv, SModelSkin, SModelBodyGroup, phys_magnet_keys, SBaseDynamicModel) color(150 50 50) sphere(fademindist) sphere(fademaxdist) studioprop() = phys_magnet : "An physics object that acts like a magnet, attaching metallic physics objects to itself when they touch it. The game will crash if no model is specified! Coast jeep pickup hack flag: In HL2, prevent objects from interfering with the crane as it picks up the buggy. It is hardcoded for use with prop_vehicle_jeep only. Another entity can be used by changing the entity's classname to prop_vehicle_jeep using AddOutput. However, if the game round restarts in multiplayer, the entity will no longer function and will cause crashes (this can be fixed by clearing the classname again with AddOutput to the original)." [
	spawnflags(flags) = [
		1 : "Start Asleep" : 0
		2 : "Motion Disabled" : 0
		4 : "Suck On Touch" : 0
		8 : "Allow Attached Rotation" : 0
		16 : "Coast Jeep Pickup Hack - See description" : 0
	] // end spawnflags

	input TurnOff(void) : "The the magnet off. This will detach anything current stuck to the magnet."
	input TurnOn(void) : "Turn the magnet on."

	output OnAttach(void) : "Fired when an entity is grabbed by the magnet."
	output OnDetach(void) : "Fired when an entity is released by the magnet."
] // end phys_magnet

@PointClass base(SBaseLogical, SBaseDiv) color(150 50 50) iconsprite("editor-ficool2/phys_motor") = phys_motor : "An entity that tries to spin a target entity at a particular speed." [
	attach1(target_destination) : "Attached Object" :  : "Object to apply the force to."
	speed(string) : "Rotation Speed" : "0" : "Angular speed (units are degress/second)"
	spinup(string) : "Spin up time" : "1" : "spin up time in seconds (also affects the rate at which speed changes happen)"
	inertiafactor(float) : "System Interia Scale" : "1.0" : "Make this larger if the object being driven is constrained to a set of heavier objects."
	axis(vecline) : "Rotation Axis" :  : "The point to the origin of the entity whose line the rotation axis."

	spawnflags(flags) = [
		1 : "Start On" : 1
		2 : "No world collision" : 0
		4 : "Hinge Object - Motor also acts as a hinge constraining the object to this axis" : 1
		8 : "Orient Locally - Maintain local relationship with the attached object" : 1
	] // end spawnflags

	input SetSpeed(float) : "Sets target speed."
	input TurnOn(void) : "Turns motor on."
	input TurnOff(void) : "Turns motor off."
] // end phys_motor

@PointClass base(SBaseConstraint) color(150 50 50) studio("models/editor/axis_helper_thick.mdl") = phys_pulleyconstraint : "A constraint that is essentially two length constraints and two points. Imagine it as a virtual rope connected to two objects, each suspended from a pulley above them. The constraint keeps the sum of the distances between the pulley points and their suspended objects constant." [
	position2(vecline) : "Pulley Position 2" :  : "The position of the pulley for Entity 2. The pulley for Entity 1 is the origin of this constraint entity. Entity 1 is always suspended from pulley point 1, and Entity 2 is always suspended from pulley point 2."
	addlength(float) : "Additional Length" : 0 : "Add (or subtract) this amount to the rest length of the pulley rope. The default length is the distance from Entity 1 to this entity plus the distance from Entity 2 to Pulley Position 2."
	gearratio(float) : "Pulley Gear Ratio" : "1.0" : "Multiplier for how much Entity 2's movement will affect Entity 1." // TODO: Causes erractic behavior?

	spawnflags(flags) = [
		2 : "Keep Rigid" : 0 // TODO: Does nothing?
	] // end spawnflags
] // end phys_pulleyconstraint

// TODO: Compare to src-ents.shoutwiki.com/wiki/Phys_ragdollconstraint
@PointClass base(SBaseConstraint) color(150 50 50) studio("models/editor/axis_helper_thick.mdl") = phys_ragdollconstraint : "A constraint that fixes the position of two entities, relative to this constraint's origin. Also allows for limits on the rotation around each axis, in the space of this constraint." [
	xmin(float) : "X axis min limit" : -90 : "-180 min and 180 max = no constraint on this axis."
	xmax(float) : "X axis max limit" : 90 : "-180 min and 180 max = no constraint on this axis."
	ymin(float) : "Y axis min limit" : 0 : "-180 min and 180 max = no constraint on this axis."
	ymax(float) : "Y axis max limit" : 0 : "-180 min and 180 max = no constraint on this axis."
	zmin(float) : "Z axis min limit" : 0 : "-180 min and 180 max = no constraint on this axis."
	zmax(float) : "Z axis max limit" : 0 : "-180 min and 180 max = no constraint on this axis."
	xfriction(float) : "X axis friction" : 0 : ""
	yfriction(float) : "Y axis friction" : 0 : ""
	zfriction(float) : "Z axis friction" : 0 : ""

	spawnflags(flags) = [
		2 : "Only limit rotation (free movement)" : 0 // TODO: Does nothing? Also describe better
	] // end spawnflags
] // end phys_ragdollconstraint

@PointClass base(SBaseEntity, SBaseDiv, SEnableDisable) color(150 50 50) iconsprite("editor-ficool2/phys_ragdollmagnet") sphere(radius) = phys_ragdollmagnet : "An entity that acts like a magnet for ragdolls. Useful for crafting exaggerated ragdoll behavior (i.e. guys falling over rails on death). If the Bar Magnet spawnflag is set, the magnet works like it was a cylindrical magnet i.e. it attracts ragdolls to the nearest point on a line." [
	target(string) : "Entity to Affect" :  : "If specified, the phys_ragdollmagnet will only affect the target entity."
	axis(vecline) : "Bar Magnet Axis" :  : "Axis of the bar magnet, if the spawnflag is active."
	radius(float) : "Effective Radius" : 512 : "Radius in which ragdolls are affected around this entity's origin."
	force(float) : "Force" : 5000 : "Magnetic force to apply to ragdolls within the radius. Expressed as kilograms per inch per second. So a force of 1000 will add 10 units/second to a 100kg man. It will add 100 units per second to a 10kg headcrab."

	spawnflags(flags) = [
		2 : "Bar Magnet (use axis helper)" : 0
	] // end spawnflags
] // end phys_ragdollmagnet

@PointClass base(SBaseConstraint) color(150 50 50) studio("models/editor/axis_helper_thick.mdl") = phys_slideconstraint : "A constraint that constrains an entity along a line segment." [
	slideaxis(vecline) : "Sliding Axis" :  : "Axis of the constraint. Usually set with the Hammer helper tool."
	slidefriction(float) : "Friction" : 0 : "Resistance/friction in the constraint,"
	SystemLoadScale(float) : "Load Scale" : "1.0" : "Scale of the mass load connected to this constraint (1 = just the objects directly connected)."

	spawnflags(flags) = [
		2 : "Limit Endpoints" : 1
	] // end spawnflags

	input SetVelocity(float) : "Set linear velocity along the constraint."
] // end phys_slideconstraint

@PointClass base(SBaseLogical, SBaseDiv) color(150 50 50) iconsprite("editor-ficool2/phys_spring") sphere(length) sphere(breaklength) = phys_spring : "A physically simulated spring. 'Length' is what's known as the 'natural spring length'. This is how long the spring would be if it was at rest (nothing hanging on it or attached). When you attach something to the spring, it will stretch longer than its 'natural length'. The amount of stretch is determined by the 'Sprint Constant'. The larger the spring constant the less stretch the spring." [
    attach1(target_destination) : "Entity 1" :  : ""
    attach2(target_destination) : "Entity 2" :  : ""
	springaxis(vecline) : "Spring Axis" :  : "Use the helper. Drag it out to match the virtual spring."
	length(float) : "Spring Length" : 0 : "How long the spring would be if it was at rest (nothing hanging on it or attached). 0 means the length of the brush."
	constant(float) : "Spring Constant" : 50 : "Stiffness of the spring.  The larger the number the less the spring will stretch."
	damping(float) : "Damping Constant" : "2.0" : "How much energy the spring loses.  The larger the number, the less bouncy the spring."
	relativedamping(float) : "Relative Damping Constant" : "0.1" : "The amount of energy the spring loses proportional to the relative velocity of the two objects the spring is attached to."
	breaklength(float) : "Break on Length" : "0" : "If the spring's length ever exceeds this length, the spring breaks."

	spawnflags(flags) = [
		1 : "Force only on stretch" : 0
	] // end spawnflags

	input SetSpringConstant(float) : "Set the Spring Constant."
	input SetSpringLength(float) : "Set the Spring Length."
	input SetSpringDamping(float) : "Set the Spring Damping."
] // end phys_spring

@PointClass base(SBaseLogical, SBaseDiv) color(150 50 50) studio("models/editor-ficool2/cone_helper_gray.mdl") = phys_thruster : "An entity used to apply constant acceleration to a physics object. The force and torque is calculated using the position and direction of the thruster as an impulse. So moving those off the object's center will cause torque as well. Torque can be removed by unchecking the 'apply torque' flag. The position of the thruster can be forced to be at the object's center by checking to 'Ignore Position' flag." [
	attach1(target_destination) : "Attached Object" :  : "Object to apply the force to."
	force(float) : "Force" : 0 : "Force (will be integrated, units are force kg*in/s^2). Negative values are accepted."
	forcetime(float) : "Force Time" : 0 : "Automatic shut-off after this time has passed (0 = stay on forever or until deactivated)"

	spawnflags(flags) = [
		1 : "Start On" : 0
		2 : "Apply Linear Force" : 1
		4 : "Apply Torque (rotational force)" : 1
		8 : "Orient Locally - Maintain local relationship with the attached object" : 1
		16 : "Ignore Mass - Impulse is independent of object's mass (impulse is acceleration NOT force)" : 0
		32 : "Ignore Position -  Put the thrust at the object center" : 0
	] // end spawnflags

	input Activate(void) : "Turn the force on."
	input Deactivate(void) : "Turn the force off."
	input Scale(string) : "Set Force Scale, negative values are accepted."
] // end phys_thruster

@PointClass base(phys_thruster) color(150 50 50) studio("models/editor-ficool2/cone_helper_gray.mdl") = phys_torque : "An angular thruster. Use it to apply angular force to an entity." [
	axis(vecline) : "Rotation Axis" :  : "The point to the origin of the entity whose line represents the rotation axis."

	spawnflags(flags) = [
		1 : "Start On" : 0
		2 : "Apply Linear Force" : 1
		4 : "Apply Torque (rotational force)" : 1
		8 : "Orient Locally - Maintain local relationship with the attached object" : 1
		16 : "Ignore Mass - Impulse is independent of object's mass (impulse is acceleration NOT force)" : 0
	] // end spawnflags

	input Activate(void) : "Turn the force on."
	input Deactivate(void) : "Turn the force off."
	input Scale(string) : "Set Force Scale, negative values are accepted."
] // end phys_torque



	// PHYSICS ENTITIES //

@BaseClass = physics_cannister_keys [
	expdamage(float) : "Explosion Damage" : 200 : "The amount of damage done by the explosion created when the cannister blows up."
	expradius(float) : "Explosion Radius" : 256 : "The radius of the explosion to create when the cannister blows up."
	thrust(float) : "Thrust" : 3000 : "When the cap has been blown off, and the escaping gas is thrusting the cannister about, this is the amount of thrust generated."
	fuel(float) : "Fuel Time" : 12 : "The amount of time in seconds that gas leaks from the cannister before being considered empty."
	rendercolor(color255) : "Smoke Color (R G B)" : "255 255 255" : "Color of the smoke."
	renderamt(integer) : "Smoke Alpha (0 - 255)" : 128 : "Transparency of the smoke."
	gassound(sound) : "Thruster Sound" : "PhysicsCannister.ThrusterLoop" : "The sound played when the gas is escaping from the cannister."
] // end physics_cannister_keys
@PointClass base(SModel, SBaseEntity, SBaseDiv, SModelSkin, SModelBodyGroup, SHealth, physics_cannister_keys, SBaseDynamicModel) sphere(expradius) sphere(fademindist) sphere(fademaxdist) studioprop() = physics_cannister : "A physically simulated gas cannister that can have its cap shot off, at which point gas will start escaping and cause the cannister to fly around. If it takes enough damage, it will explode. Follows the same rules as prop_physics for simulation." [
	model(studio) : "Model" : "models/props_c17/canister02a.mdl" : "The model this entity should appear as. The model should have a nozzle attachment point, which is where gas will escape and thrust will be produced from. Must be compiled with $staticprop to allow usage."

	spawnflags(flags) = [
		1 : "Start Asleep" : 0
		2 : "Explodes" : 1
	] // end spawnflags

	input Activate(string) : "Start gas escaping from the cannister."
	input Deactivate(string) : "Stop gas escaping from the cannister."
	input Explode(string) : "Force the cannister to explode."
	input Wake(void) : "Wakes up the cannister, if it is sleeping."

	output OnActivate(void) : "Fired when gas starts to escape from the cannister."
	output OnAwakened(void) : "Fired when this entity becomes awake (collision/force is applied)."
] // end physics_cannister



	// PLAYER ENTITIES //

@BaseClass = player_keys [
	gravity(float) : "Gravity" : "1.0" : "The player's gravity. Default is 1. Does not allow a value of 0, use a small decimal like 0.0001 instead. Negative values are accepted. Custom gravity values are not properly lag-compensated, so players with high ping will have jittery jumping."
	//waterlevel(float) : "Water Level" :  : "Current water level of the player, can cause strange behavior if changed with AddOutput."
	// NOTE FROM FICOOL: a proper explanation will be written on these when I have time, they have some *very* interesting effects
	ResponseContext(string) : "Response Contexts" :  : "Response system context(s) for this entity. Format should be: 'key:value,key2:value2,etc'. When this entity speaks, the list of keys & values will be passed to the response rules system."
	view_ofs(vector) : "View Offset (X Y Z)" : "0 0 0" : "Offsets the player's camera on the X and Y axis (Z-axis offset does not work). This also offsets where bullets and projectiles fired by the player originate from. At most, the player's view will be offset by no more than 48hu on any axis, but otherwise the game treats the value as unclamped (bullets and projectiles will spawn at the correct offset, VIS may get funky if the player's view offset would place their view through a wall). If the player crouches or uncrouches, any view offset will be cleared. Offsetting the player's view while they are crouching will teleport their view to floor height in addition to applying the given offset."
] // end player_keys
@PointClass base(SPreservedEntity, SDoNotPlace, SBaseEntity, SBaseDiv, SHealth, SHealthMax, SDamageFilter, SVelocity, STFTeam, player_keys, SBaseDynamicModel) studioprop("models/player/soldier.mdl") = player : "The player itself. This entity is automatically created at runtime when a new player joins the server, and removed when a player disconnects. The keyvalues should be changed on existing players at runtime with AddOutput.\n" +
	"WARNING: NEVER place/spawn this entity in a map, it will result in an instant server crash! On a similar note, NEVER Kill/remove a player entity! The player's view will become stuck at the world origin and their client may crash, and on the server side that player slot becomes bricked and unusable by any other player until a server map change." [
	health(integer) : "Health" : 300 : "Health of the player."
	max_health(integer) : "Maximum Health" : 300 : "Maximum health of the player."

	input BleedPlayer (integer) : "Cause the player to bleed for the specified number of seconds."
	input DispatchResponse(string) : "Dispatches a response to the player."
	input ExtinguishPlayer(void) : "Extinguishes the player."
	input HandleMapEvent(string) : "Tells the game to perform a function, such as unlock an achievement. Hardcoded for specific map names."
	input IgnitePlayer(integer) : "Ignites the player with a specified lifetime and causes a reaction (sound and speech). Does not fire the OnIgnite output. Broken since the Jungle Inferno update, only initiates sound and speech but no actual fire. Use trigger_ignite as a workaround."
	input RollRareSpell(void) : "Forces the player to roll a rare spell. Only available if spells are enabled on the map."
	input SpeakResponseConcept(string) : "Forces the player to speak the specified response concept, an example being 'halloweenlongfall' or 'TLK_HELP'." // TODO: Where are these defined?

	input ClearCustomModelRotation(void) : "Clears the custom player model rotation."
	input SetCustomModel(string) : "Set a custom player model without animations."
	input SetCustomModelOffset(vector) : "Set a custom player model position on the player."
	input SetCustomModelRotates(bool) : "Set if the custom model rotates or not to the player's angles."
	input SetCustomModelRotation(vector) : "Set a custom player model rotation on the player."
	input SetCustomModelVisibleToSelf (bool) : "Set if the custom model is visible to the player, in thirdperson."
	input SetFogController(string) : "Sets the fog controller to use."
	input SetForcedTauntCam(bool) : "Forces the player into thirdperson mode. 1 - force into thirdperson, 0 - force into firstperson."
	input SetHudVisibility(bool) : "Hides or displays the HUD. The menu can still be accessed, and some HUD elements such as kill icons may still be visible. Players cannot switch weapons while the HUD is invisible. 1 = visibile, 0 = invisible."
	input TriggerLootIslandAchievement(void) : "Hardcoded to only function on certain official maps. Used to give the player various achievements upon escaping from the underworld."
	input TriggerLootIslandAchievement2(void) : "Does nothing."

	// a proper explanation will be written on these when I have time
	input AddContext(string) : "Adds a context to this player's list of response contexts. The format should be 'key:value'."
	input ClearContext(void) : "Removes all contexts in this player's list of response contexts."
	input RemoveContext(string) : "Remove a context from this player's list of response contexts. The name should match the 'key' of a previously added context."

	//input RoundSpawn(void) : "Spawns the player, fired automatically."
] // end player

@PointClass base(SBaseLogical) color(100 150 255) iconsprite("editor-ficool2/player_speedmod") = player_speedmod : "An entity intended to increase or decrease the player's move speed. The speed aspect does not work in Team Fortress 2, however the flags can still be used to suppress certain player abilities." [
	spawnflags(flags) = [
		1 : "Suppress Weapons and Taunting (Causes player to T-pose)" : 0
		64 : "Suppress Attack (Not acknowledged by client, weapons visually jitter and spam fire sound when attacking)" : 0
		4 : "Suppress Jump" : 0
		8 : "Suppress Duck" : 0
		16 : "Suppress +USE" : 0
		//32 : "Suppress Sprint" : 0
		//128 : "Suppress Zoom" : 0
		2 : "Hide HUD (Player cannot switch weapons while active)" : 0
	] // end spawnflags

	input ModifySpeed(float) : "Apply/remove the flags to/from the !activator. A value must be specified. A value of 1 will clear any flags applied by this entity, any other values will apply the flags."
] // end player_speedmod

@PointClass base(SDoesNotFunction, SBaseLogical) color(100 150 255) iconsprite("editor/obsolete") = player_weaponstrip : "Strips a player's weapons. Does not work in Team Fortress 2." [
	input Strip(void) : "Strip the !activator's weapons."
	input StripWeaponsAndSuit(void) : "Strip the !activator's weapons and suit."
] // end player_weaponstrip



	// POINT ENTITIES //

@PointClass base(SBaseLogical, SBaseDiv, SEnableDisable, SToggle) color(100 150 255) iconsprite("editor-ficool2/point_anglesensor") line(255 255 255, targetname, target, targetname, lookatname) = point_anglesensor : "An entity that detects if another entity points in a given direction for a period of time." [
	target(target_destination) : "Entity to Sense" :  : "Name of the entity whose angles will be sensed."
	lookatname(target_destination) : "Look At Entity" :  : "The entity we want to check to see if the Target Entity is looking at."
	duration(float) : "Duration" : "1.0" : "The amount of time the Target Entity must look at the 'Look at Entity' to trigger this entity, in seconds."
	tolerance(integer) : "Tolerance" : 45 : "The tolerance, in degrees, in the checking to determine when the Target Entity is looking at the Look At Entity."

	spawnflags(flags) = [
		1 : "Use target entity's angles (NOT position)" : 0
	] // end spawnflags

	input SetTargetEntity(target_destination) : "Set the target entity whose angles should be sensed."
	input Test(void) : "Check to see if the Target Entity is facing the Look At Entity within the specified tolerance, firing either the OnFacingLookat or OnNotFacingLookat output based on the result."

	output FacingPercentage(float) : "Normalized value (0..1) where 1 is facing directly at target and 0 is at or beyond the angle of tolerance."
	output OnFacingLookat(void) : "Fired when the Target Entity points at the Look At Entity for more than the specified Duration, or in response to a Test input."
	output OnNotFacingLookat(void) : "Fires in response to a Test input when the Target Entity is not pointing at the Look At Entity."
	output TargetDir(vector) : "Fired when the forward direction of the Target Entity changes. Passes the new forward direction as a parameter."
] // end point_anglesensor

@PointClass base(SBaseLogical, SBaseDiv, SEnableDisable) color(100 150 255) iconsprite("editor-ficool2/point_angularvelocitysensor") = point_angularvelocitysensor : "An entity that detects if another entity's angular velocity meets or exceeds a threshold value. The AngularVelocity is fired every frame, so use with caution!" [
	target(target_destination) : "Target Entity Name" :  : "Name of the entity whose angular velocity will be sensed."
	threshold(float) : "Threshold Velocity" : 0 : "The threshold angular velocity to compare against, in degrees per second."
	fireinterval(float) : "Fire Interval" : "0.2" : "Angular velocity must cross the threshold for at least this long to fire."
	axis(vecline) : "Axis" :  : "The axis to measure for."
	usehelper(choices) : "Use Axis Helper?" : 0 : "Use axis helper to determine rotation values (clockwise/counter-clockwise)." = [
		0 : "No"
		1 : "Yes"
	] // end usehelper

	input Test(void) : "Checks to see if the Target Entity's angular velocity meets or exceeds the Threshold Velocity, firing either the OnGreaterThanOrEqualTo or OnLessThan output based on the result."
	input TestWithInterval(void) : "Checks to see if the Target Entity's angular velocity meets or exceeds the Threshold Velocity. Once the Fire Interval expires, fires the appropriate test result output if the result is stable throughout the Fire Interval."

	output AngularVelocity(float) : "Fired when the Target's Angular Velocity changes, passing the new magnitude of the angular velocity."
	output OnEqualTo(void) : "Fired when the Target Entity reaches the threshold angular velocity from a different velocity."
	output OnGreaterThan(void) : "Fired when the Target Entity goes from slower than the threshold angular velocity to faster than the threshold angular velocity."
	output OnGreaterThanOrEqualTo(void) : "Fired when the Target Entity goes from slower than the threshold angular velocity to faster than the threshold angular velocity."
	output OnLessThan(void) : "Fired when the Target Entity goes from faster than the threshold angular velocity to slower than the threshold angular velocity."
	output OnLessThanOrEqualTo(void) : "Fired when the Target Entity goes from faster than the threshold angular velocity to slower than the threshold angular velocity."
] // end point_angularvelocitysensor

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/point_bonusmaps_accessor") = point_bonusmaps_accessor : "An entity that relays bonus maps changes. " [
	filename(string) : "File Name" :  : "Link to a .BNS file with values for this map. Relative to mod's root directory."
	mapname(string) : "Map Name" :  : "Script entry inside above .BNS file of the map. This is NOT .bsp file name."

	input Complete(void) : "Completes the filename/map combination."
	input Save(void) : "Saves bonus map data."
	input Unlock(void) : "Unlocks the filename/map combination."
] // end point_bonusmaps_accessor

@PointClass base(SBaseLogical) color(100 150 255) iconsprite("editor-abs/point_clientcommand") = point_clientcommand : "An entity that issues commands to the client console, as if it was typed in by the player (the !activator if that is a player, or the local player in single player). Most commands are blocked, to see a list of allowed commands, do 'findflags server_can_execute' in the developer console." [
	input Command(string) : "Command to execute."
] // end point_clientcommand

@PointClass base(SPreservedEntity, SBaseEntity, SBaseDiv, SEnableDisable) studioprop("models/extras/info_speech.mdl") = point_commentary_node : "Core entity used in the Commentary System. It appears as a floating speech bubble for the player to +USE, which then starts the commentary playing. This entity is typically placed with the Commentary Editor." [
	commentaryfile(sound) : "Commentary sound file" :  : "The commentary sound file that should be played when this node is used by the player."
	commentaryfile_nohdr(sound) : "Commentary sound NoHDR" :  : "The commentary sound file that should be played when this node is used by the player. If the player has HDR turned off, this file will be used instead of the commentaryfile. If this entry is not specified, the base commentaryfile entry will still be used."
	speakers(string) : "Speakers" : "Gabe Newell" : "The name of the speakers of the commentary sound file(s). Will be displayed in the HUD while the commentary sound file is playing."
	precommands(string) : "semi-colon delimited list" :  : "A semi-colon delimited list of commands that should entered into the console when the commentary file starts playing. e.g. ai_disable 1;mat_wireframe 1"
	postcommands(string) : "semi-colon delimited list" :  : "A semi-colon delimited list of commands that should entered into the console when the commentary file finishes playing. e.g. ai_disable 0;mat_wireframe 0"
	viewposition(target_destination) : "Players view move" :  : "The targetname of entity to which the players view should move while the commentary file is playing."
	viewtarget(target_destination) : "Players view track" :  : "The targetname of entity that the players view should track while the commentary file is playing."
	teleport_origin(string) : "Teleport To..." :  : "Teleport to this entity."
	prevent_movement(choices) : "Prevent Movement?" : 0 : "If Yes, the player will not be able to move while the commentary sound file is playing" = [
		0 : "No"
		1 : "Yes"
	] // end prevent_movement

	input StartCommentary(void) : "Force the commentary node to start."
	input StartUnstoppableCommentary(void) : "Force the commentary node to start, and don't allow the player to stop it in any way."
	input StopCommentary(void) : "Force the commentary node to stop."

	output OnCommentaryStarted(void) : "Sent when Commentary started."
	output OnCommentaryStopped(void) : "Sent when Commentary stopped."
] // end point_commentary_node

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("tools/toolsinvisibledisplacement") studioprop("models/editor/camera.mdl") = point_devshot_camera : "An entity used by the -makedevshots system, which automatically takes screenshots at the position of every point_devshot_camera in the level." [
	cameraname(string) : "Camera Name" :  : "Used as the name of the directory to store screenshots from this camera, relative to /screenshots/[mapname]/. Must be set or screenshot-taking will fail. Must be unique within the level."
	FOV(integer) : "Camera FOV" : 75 : "FOV of this camera."
] // end point_devshot_camera

@PointClass base(STargetname, SAngles, SBaseIO, SBaseDiv, SParentname) iconsprite("editor-ficool2/point_enable_motion_fixup") = point_enable_motion_fixup : "An entity used to move a motion-disabled prop when it enables motion. Parent this entity to the prop, and when the prop has its motion enabled, it will immediately teleport to the origin of this entity." [
	parentname(target_destination) : "Entity to Fix" :  : "Physics entity to teleport when it is motion enabled."
] // end point_enable_motion_fixup

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/point_gamestats_counter") = point_gamestats_counter : "Generic game statistics counter." [
	Name(string) : "Statistic Counter Name" :  : "Name of statistic counter." // TODO: Are these listed anywhere?

	input Disable(void) : "Disable the statistic counter."
	input Enable(void) : "Enables the statistic counter."
	input Increment(float) : "Increments named statistic counter by specified value"
	input SetName(string) : "Changes name of statistic counter"
] // end point_gamestats_counter

// TODO: Doesn't seem to refire automatically when turned on?
@PointClass base(SBaseEntity, SBaseDiv, SToggle, SDamageTypes) iconsprite("editor-ficool2/point_hurt") sphere(DamageRadius) = point_hurt : "An entity that does damage to all entities in a radius around itself, with a specified delay. If 'Target Entity' is specified, the damage is only done to that entity.\n" +
	"BUG: Blood particles are emitted from the point_hurt entity, rather than the player receiving the damage. TODO: What about sparks from the shock damage type?" [
	Damage(integer) : "Damage" : 5 : "Maximum damage done to affected entities each time this entity fires. If a Target Entity is not specified, the actual damage is based on the player's distance to the entity. Ignores damage resistances, as well as damage types that apply/alter damage ramp-up and falloff (except for DMG_HALF_FALLOFF, 262144)."
	DamageRadius(float) : "Radius" : 256 : "If no Target Entity is specified, all entities within this radius of this entity will take damage. Entities at the edge of the radius will take 1 damage at a time, while entities at the center of this radius will take the full Damage. If a 'Target Entity' is specified, only that entity will take damage, and the Radius is ignored."
	DamageDelay(float) : "Delay" : "1.0" : "Minimum delay between dealing damage, in seconds."
	DamageTarget(target_destination) : "Target Entity" :  : "If specified, only entities with matching targetnames will take damage from this point_hurt, and the damage will be dealt even if the target is outside the Radius. Otherwise, all entities within the Radius will take damage. Can be set to damage the !activator."

	input Hurt(void) : "Force a single fire, damaging either the Target Entity or all entities within the radius." // TODO: Respects the Delay?
	input TurnOff(void) : "Disable this entity. It will stop damaging entities."
	input TurnOn(void) : "Enable this entity. It will start damaging entities everytime it fires, and refire based upon the specified Delay."
] // end point_hurt

@PointClass base(SBaseLogical) color(100 150 255) iconsprite("editor-ficool2/point_intermission") = point_intermission : "Entity that ends the match and triggers an intermission. Seems to have the same effect as game_end: In Team Fortress 2, this freezes all players, shows the scoreboard, and after a few seconds, forces a map change. To end a round normally with a winner, use game_round_win." [
	input Activate(void) : "Causes the game to end and the intermission to begin."
] // end point_intermission

@PointClass base(SDoesNotFunction, SBaseLogical, SBaseDiv) iconsprite("editor/obsolete") sphere(radius) = point_message : "An entity intended to display a message, in the world, at its own location. Does not work in Team Fortress 2, use training_annotation or game_text instead." [
	message(string) : "Message" :  : "Text to display."
	radius(integer) : "Display Radius" : 256 : "Only players closer than this distance will see this message."
	developeronly(choices) : "Developer Only?" : 0 : "If Yes, this message will only appear when the 'developer' console variable is nonzero." = [
		0 : "No"
		1 : "Yes"
	] // end developeronly

	spawnflags(flags) = [
		1 : "Start Disabled - If set, this entity's message will start hidden" : 1
	] // end spawnflags

	input Disable(void) : "Hide the message."
	input Enable(void) : "Show the message."
] // end point_message

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/point_playermoveconstraint") sphere(radius) = point_playermoveconstraint : "An entity that constrains players to a radius around itself, slowing them down the closer they get to the edge of the radius." [
	radius(float) : "Radius" : 256 : "Radius to constrain players to."
	width(float) : "Constraint Width" : 80 : "Width of the constraint edge. This is the distance in which to start slowing players down as they approach the edge of the radius."
	speedfactor(float) : "Speed Factor" : "0.15" : "Factor applied to the player's max speed as they approach the radius edge."

	input TurnOn(void) : "Start constraining any players within the radius."
	input TurnOff(void) : "Stop constraining any players previously constrained."

	output OnConstraintBroken(void) : "Fired when a player breaks through the constraint."
] // end point_playermoveconstraint

@PointClass base(SBaseLogical) color(150 0 200) iconsprite("editor-ficool2/point_populator_interface") = point_populator_interface : "Entity interface to the MvM robot populator. See the inputs." [
	input PauseBotSpawning(void) : "Pause the spawning of all bots."
	input UnpauseBotSpawning(void) : "Resume spawning of bots."
	input ChangeBotAttributes(string) : "All bots with EventChangeAttributes and a matching event name will apply the attributes from the specified event name block. In Valve official usage, 'Default' will instruct gatebots to attempt to capture gates (if any), while 'RevertGateBotsBehavior' will tell gatebots to attempt to deploy the bomb."
	input ChangeDefaultEventAttributes(string) : "Sets the default event name that EventChangeAttributes bots will spawn with. Bots that do not have the specified event name will use the default event name, which is simply 'Default'."
] // end point_populator_interface

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/point_posecontroller") = point_posecontroller : "An entity that controls a pose parameter of a prop and cycles the pose clientside. Using an invalid or non-existant Pose Parameter will crash the game." [
	PropName(target_destination) : "Prop Name" :  : "Name of the prop to control."
	PoseParameterName(string) : "Pose Parameter Name" :  : "Name of the pose parameter to control."
	PoseValue(float) : "Pose Parameter Value" : "0.0" : "Normalized value for the pose parameter from 0.0 and 1.0 (maps to min and max range). Suffers from rounding or overflow errors, the only fix is to constantly set a new value using SetPoseValue."
	InterpolationTime(float) : "Interpolation Time" : 0 : "Number of seconds (0.0 to 10.0) for client to match absolue pose values."
	InterpolationWrap(choices) : "Interpolation Wrap?" : 0 : "Should wrap from 0.0 to 1.0 when interpolating." = [
		0 : "No"
		1 : "Yes"
	] // end InterpolationWrap
	CycleFrequency(float) : "Cycle Frequency" : "0.0" : "Base cycles per second from -10.0 to 10.0."
	FModulationType(choices) : "Frequency Modulation Type" : 0 = [
		0: "None"
		1: "Sine"
		2: "Square"
		3: "Triangle"
		4: "Sawtooth"
		5: "Noise"
	] // end FModulationType
	FModTimeOffset(float) : "Frequency Modulation Time Offset" : "0.0" : "Modulation time offset from -1.0f to 1.0."
	FModRate(float) : "Frequency Modulation Rate" : "0.0" : "Modulation cycles per second from -10.0f to 10.0."
	FModAmplitude(float) : "Frequency Modulation Amplitude" : "0.0" : "Modulation extents from 0.0f to 10.0."

	input GetFMod(void) : "Outputs the current modulation settings in console to the activating player."
	input RandomizeFMod(float) : "Randomize the frequency modulation by an extremeness of 0.0 to 1.0."
	input SetCycleFrequency(float) : "Set the pose parameter's base cycles per second from -10.0f to 10.0."
	input SetFModAmplitude(float) : "Set the modulation extents from 0.0f to 10.0."
	input SetFModRate(float) : "Set the modulation cycles per second from -10.0f to 10.0."
	input SetFModTimeOffset(float) : "Set the modulation time offset from -1.0f to 1.0."
	input SetFModType(integer) : "Set the type of frequency modulation."
	input SetInterpolationTime(float) : "Set the interpolation time to a number of seconds between 0.0 and 10.0."
	input SetPoseParameterName(string) : "Sets the pose parameter to control."
	input SetPoseValue(float) : "Set the pose parameter to a normalized value between 0.0 and 1.0 (maps to min and max range)."
] // end point_posecontroller

@PointClass base(SBaseEntity, SBaseDiv, SEnableDisable, SToggle) iconsprite("editor-abs/point_proximity_sensor") = point_proximity_sensor : "An entity that detects another entity's proximity to this entity." [
	target(target_destination) : "Target Entity Name" :  : "Name of the entity whose proximity will be sensed."

	spawnflags(flags) = [
		1 : "Test the distance as measured along the axis specified by our direction." : 0
	] // end spawnflags

	input SetTargetEntity(target_destination) : "Set the entity to detect."

	output Distance(float) : "Distance of the target entity away from this entity."
] // end point_proximity_sensor

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/point_push") sphere(radius) sphere(inner_radius) = point_push : "Push sphere that will push any physics props or entity that has a movement type set (e.g. NPCs) away from its origin. Does not push parented objects." [
	enabled(choices) : "Start Enabled?"	: 1 = [
		0 : "No"
		1 : "Yes"
	] // end enabled
	magnitude(float) : "Magnitude" : 100 : "How strongly to push away from the center. Negative values will pull into the centre."
	radius(float) : "Radius" : 128 : "Radius to affect items in."
	inner_radius(float) : "LOS Radius" : 0 : "If not zero, the LOS is calculated from a point intersecting this sphere."

	spawnflags(flags) = [
		1 : "Test LOS before pushing" : 0
		2 : "Use angles for push direction" : 0
		4 : "No falloff (constant push at any distance)" : 0
		8 : "Push players" : 1
		16 : "Push physics" : 0
	] // end spawnflags

	input Enable(void) : "Enable the push."
	input Disable(void): "Disable the push."
] // end point_push

@PointClass base(SBaseLogical) color(100 150 255) iconsprite("editor-abs/point_servercommand") = point_servercommand : "An entity that issues commands to the server console. Servers may block this entity with the sv_allow_point_servercommand convar or with plugins." [
	input Command(string) : "Execute this command, as though it were typed into the server console."
] // end point_servercommand

@BaseClass = point_spotlight_keys [
	spotlightlength(integer) : "Spotlight Length" : 500 : "Length of the spotlight beam."
	spotlightwidth(integer) : "Spotlight Width" : 50 : "Width of the spotlight beam."
	IgnoreSolid(choices) : "Ignore Solids?" : 0 : "If Yes, this spotlight won't trace for solids. If No, the spotlight beam will automatically shorten itself if it finds a wall within its Spotlight Length." = [
		0 : "No"
		1 : "Yes"
	] // end IgnoreSolid
	HDRColorScale(float) : "HDR Color Scale" : "1.0" : "Float value to multiply sprite color by when running in HDR mode."
] // end point_spotlight_keys
@PointClass base(SBaseEntity, SBaseDiv, point_spotlight_keys, SRenderModes) studio("models/editor/cone_helper.mdl") = point_spotlight : "An entity to draw a spotlight. Will draw a beam when the player views it side on, and a halo when it's facing towards the player. Unless the 'No Dynamic Light' spawnflag is checked, it will also create a dynamic light wherever the end of the spotlight rests." [
	spawnflags(Flags) = [
		1 :  "Start On" : 1
		2 :  "No Dynamic Light" : 1
	] // end spawnflags

	input LightOn(void) : "Turn the spotlight on."
	input LightOff(void) : "Turn the spotlight off"

	output OnLightOn(void) : "Fires when light turns on."
	output OnLightOff(void) : "Fires when light turns off."
] // end point_spotlight

@PointClass base(SHelperModel, STargetname, SAngles, SBaseIO, SBaseDiv) iconsprite("editor-ficool2/point_teleport") studio() = point_teleport : "An entity that teleports a target entity to its position and angles. If 'Teleport Home' spawnflag is set, then the target's position will be recorded when this entity spawns (if the target exists) and that will be the teleport destination. If the target is physically simulated, simulation is turned off when teleporting. The entity does not update its teleport destination ever after spawning, even if it is moved. Use trigger_teleport as a workaround if necessary." [
	target(target_destination) : "Entity To Teleport" :  : "Name of the entity that will be teleported. Only one entity can be teleported at a time. !activator and !caller can be used to teleport the activator and caller of the Teleport input respectively, but are incompatible with the Teleport Home spawnflag."

	// For entities with one spawnflag, could we turn that into a keyvalue to make it easier to spot? (Unfortunately not, Hammer treats it as spawnflags even without the (flags) type)
	spawnflags(flags) = [
		1 : "Teleport Home (Target MUST exist when I spawn)" : 0
		//2 : "Into Duck/Crouch" : 0 // Doesn't work
	] // end spawnflags

	input Teleport(void) : "Teleport the target entity."
] // end point_teleport

// TODO: What happens if we try to templatize an entity that doesn't reset on round restart?
@PointClass base(SBaseLogical, SBaseDiv) iconsprite("editor-ficool2/point_template") = point_template : "Turns an entity, or set of entities, into a single template that can be re-created anywhere, and multiple times. If there are interdependencies (entity I/O, hierarchy, or other name references) between the entities in the template, the entities in the template will have their names changed and the interdependencies will be reconnected to the new names. The name change format is as follows: '<original name>&XXXX', where XXXX will be replaced with a variable 4-digit integer, so wildcard searches for '<original name>*' will still find them. If you don't want the name fixup to happen, check the 'Preserve Entity Names' spawnflag." +
	"NOTE: point_template cannot be parented traditionally; to spawn the template in other places, use an env_entity_maker to reference the template remotely, or a logic_measure_movement to move the point_template." +
	"NOTE: point_template will only perform name fix-up on entities which are referenced directly by name from elsewhere in the template (either as a keyvalue or in an I/O connection). An entity referencing itself via its own targetname (not via !self) counts as a reference for this purpose. On a similar note, point_template will not recognize entity names in the parameter override field of an output." [
	Template01(target_destination) : "Template 1" :  : "Entity/ies to add to this template."
	Template02(target_destination) : "Template 2" :  : "Entity/ies to add to this template."
	Template03(target_destination) : "Template 3" :  : "Entity/ies to add to this template."
	Template04(target_destination) : "Template 4" :  : "Entity/ies to add to this template."
	Template05(target_destination) : "Template 5" :  : "Entity/ies to add to this template."
	Template06(target_destination) : "Template 6" :  : "Entity/ies to add to this template."
	Template07(target_destination) : "Template 7" :  : "Entity/ies to add to this template."
	Template08(target_destination) : "Template 8" :  : "Entity/ies to add to this template."
	Template09(target_destination) : "Template 9" :  : "Entity/ies to add to this template."
	Template10(target_destination) : "Template 10" :  : "Entity/ies to add to this template."
	Template11(target_destination) : "Template 11" :  : "Entity/ies to add to this template."
	Template12(target_destination) : "Template 12" :  : "Entity/ies to add to this template."
	Template13(target_destination) : "Template 13" :  : "Entity/ies to add to this template."
	Template14(target_destination) : "Template 14" :  : "Entity/ies to add to this template."
	Template15(target_destination) : "Template 15" :  : "Entity/ies to add to this template."
	Template16(target_destination) : "Template 16" :  : "Entity/ies to add to this template."

	spawnflags(flags) = [
		1 : "Don't Remove Template Entities" : 0
		2 : "Preserve Entity Names - Don't do name fixup" : 1
	] // end spawnflags

	input ForceSpawn(void) : "Spawn an instance of the template at the original position."

	output OnEntitySpawned(void) : "Fired after spawning an instance of this template."
] // end point_template

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/point_tesla") line(255 255 255, targetname, m_SourceEntityName) sphere(m_flRadius) = point_tesla : "An entity that creates tesla lightning arcs around its origin." [
	m_SourceEntityName(string) : "Source Entity" :  : "If specified, tesla lightning will originate from the specified entity. Otherwise, they originate from this entity."
	m_SoundName(sound) : "Sound Name" : "DoSpark" : "Sound to be played whenever lightning is created."
	texture(sprite) : "Sprite Name" : "sprites/physbeam.vmt" : "Material to use for the tesla lightning beams."
	m_Color(color255) : "Color" : "255 255 255" : "Beam color."
	m_flRadius(integer) : "Radius" : 200 : "Radius around the origin to find a point to strike with a tesla lightning beam."
	beamcount_min(integer) : "Min # of Beams" : 6 : "Minimum number of tesla lightning beams to create when creating an arc."
	beamcount_max(integer) : "Max # of Beams" : 8 : "Maximum number of tesla lightning beams to create when creating an arc."
	thick_min(string) : "Min Beam Width" : 4 : "Minimum width of the tesla lightning beams."
	thick_max(string) : "Max Beam Width" : 5 : "Maximum width of the tesla lightning beams."
	lifetime_min(string) : "Min Time Visible" : "0.3" : "Minimum lifetime of the tesla lightning beams."
	lifetime_max(string) : "Max Time Visible" : "0.3" : "Maximum lifetime of the tesla lightning beams."
	interval_min(string) : "Min Time Between Arcs": "0.5" : "Minimum time delay between random arcing."
	interval_max(string) : "Max Time Between Arcs": "2" : "Maximum time delay between random arcing."
	m_bOn(choices) : "Start On?" : 1 : "Start the point_tesla already on?" = [
		0 : "No"
		1 : "Yes"
	] // end m_bOn

	input DoSpark(void) : "Force a single arc."
	input TurnOff(void) : "Turn the tesla off."
	input TurnOn(void) : "Turn the tesla on."
] // end point_tesla

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/point_velocitysensor")  = point_velocitysensor : "An entity that detects and outputs an entity's velocity. The Velocity output is fired every tick, so use with caution!" [
	enabled(choices) : "Start Enabled?" : 1 : "Whether or not to start enabled and active." = [
		0 : "No"
		1 : "Yes"
	] // enabled
	target(target_destination) : "Target Entity Name" :  : "Name of the entity whose velocity will be sensed."
	axis(vecline) : "Measurement Axis" :  : "The axis to measure the velocity along with."

	input Enable(void) : "Enable the sensor."
	input Disable(void) : "Disable the sensor."

	output Velocity(float) : "Fired when the Target's Velocity changes, passing the new magnitude of the velocity."
] // end point_velocitysensor

@PointClass base(SPreservedEntity, SBaseEntity, SBaseDiv, SSpeed) iconsprite("tools/toolsinvisibledisplacement") line(255 255 255, targetname, target) studioprop("models/editor/camera.mdl") = point_viewcontrol : "A camera entity that hijacks a player's view, forcing them to see out of the camera's position and angles. This entity is fairly buggy, but functional and usable. This entity does not reset its position on a round restart, but other features will be indirectly reset.\n" +
	"BUG: The player's view becomes stuck at the world origin if the point_viewcontrol is killed, fixable by Enabling the player on another point_viewcontrol.\n" +
	"BUG: Players are not visible to themselves when viewing through the point_viewcontrol, unless they are in thirdperson mode. If the player is in thirdperson, their view will be offset from the point_viewcontrol and will not rotate to face what the point_viewcontrol is facing.\n" +
	"NOTE: Players are immune to all forms of damage when viewing through the point_viewcontrol (even SetHealth), although they can still suicide. Dead players cannot stop viewing through the point_viewcontrol; their view can only be reset after they respawn.\n" +
	"NOTE: Although multiple players CAN view through the same point_viewcontrol at the same time, the entity was NOT built with multiplayer in mind. As a result, many of the entity's secondary features behave poorly/strangely when multiple players attempt to view through it, most notably the Disable input (see below for more info and how to overcome these limits)." [
	parentname(target_destination) : "Parent (see description)" :  : "Specifies a movement parent. This entity will delete itself if it spawns with a parent, but can be assigned one using SetParent with no issue (requires the 'Freeze Player' spawnflag to be checked). If this entity's parent rotates, the point_viewcontrol will not properly face its Look At target. If following a path, this entity and all of its path_tracks should have the same parent. logic_measure_movement can be used as an alternative to parenting."
	speed(float) : "Speed" : 100 : "The speed at which this entity moves along its path initially, in HU/sec. When this entity passes a path_track, it immediately begins accelerating or decellerating to the speed specified by the NEXT path_track. At faster speeds, the point_viewcontrol follows its track more loosely and may appear to 'miss' its destination. When this entity reaches the end of its track, it immediately and abruptly slows to a crawl and continues drifting in a straight line in the same direction it was already moving, as though it were Disabled."

	acceleration(float) : "Acceleration (HU/sec^2)" : 128 : "The speed at which the point_viewcontrol accelerates (speeds up) to the speed specified in its next path_track or path_corner. This entity will not change speed if the path_track or path_corner's New Train Speed is set to 0."
	deceleration(float) : "Deceleration (HU/sec^2)" : 128 : "The speed at which the point_viewcontrol decelerates (slows down) to the speed specified in its next path_track or path_corner. This entity will not change speed if the path_track or path_corner's New Train Speed is set to 0."
	moveto(target_destination) : "First path_track" :  : "Optionally the first path_track or path_corner in a track for the point_viewcontrol to move along when Enabled. Requires the 'Freeze Player' flag and a Look At target. The point_viewcontrol starts at its current position, and will always skip over the First path_track and immediately begin moving to the first path's Next Path Target. The point_viewcontrol resets its next track every time it is Enabled, even if it is already Enabled. Aside from New Train Speed, point_viewcontrol ignores all settings in path_track (even branch paths), but does fire OnPass." // TODO: Can point_viewcontrol be teleported with point_teleport while following a path?
	target(target_destination) : "Entity to Look At" :  : "Optionally the entity that the point_viewcontrol should attempt to aim at while Enabled. The point_viewcontrol smoothly rotates to face this entity, and may lag behind it slightly while moving. If the 'Snap to Goal Angles' spawnflag is checked, the point_viewcontrol will instantly turn to face its target when it receives the Enable input."
	targetattachment(string) : "Target Attachment Name" :  : "If the Entity to Look At has a model with the specified attachment point, the point_viewcontrol will focus on this attachment point on the model (rather than its origin)."
	wait(integer) : "Hold Time" : 10 : "The amount of time the point_viewcontrol should control the player's view for, after which it Disables itself. Requires a Look At target, and for the 'Infinite Hold Time' spawnflag to be unchecked. The timer is reset every time this entity is Enabled, and only affects the last !activator of the Enable input."

	spawnflags(flags) = [
		1 : "Start At Player - When Enabled, teleport to !activator's eyes (moves to first path at an offset if !activator is moving)" : 0
		2 : "Watch Player - Sets the Look At target to the last !activator of the Enable input" : 0
		4 : "Freeze Player - Ignore player input (can still taunt/suicide), doesn't properly follow paths or parents if unchecked" : 1 // TODO: Can still be teleported, and still faces Look At target?
		32 : "Make Players Non-Solid (while looking through this camera)" : 0
		64 : "Interruptable by Player - Disable if last !activator presses any key, requires Freeze Player to be unchecked" : 0
		8 : "Infinite Hold Time - Don't auto-Disable when Hold Time expires" : 1
		16 : "Snap to Goal Angles - Instantly rotate to Look At target on Enable (otherwise smoothly glide to face target)" : 1
	] // end spawnflags

	input Enable(void) : "Enable the point_viewcontrol. This entity will start controlling the view of the !activator of this input. It will also reset its speed, next path_track, and hold time (but not its position). If the !activator is watching through another point_viewcontrol, that point_viewcontrol will have its Disable input called. The last !activator of this input is the only player whose view can be freed from this entity via any means outside of using another point_viewcontrol. A player can be Enabled on a point_viewcontrol (even if they are already viewing through it) to make them eligible to be removed via the Disable input, which may be useful in multiplayer contexts. (Alternatively, it may be easier to make a separate point_viewcontrol for each player.)"
	input Disable(void) : "Disable the point_viewcontrol. This entity will stop controlling the view of the !activator of the last Enable input (NOT the !activator of this input or of any previous Disable input!) (only if the last !activator is alive), but any other players watching through this entity will be unchanged. The point_viewcontrol will continue moving in the same direction it was previously, at the same speed, but will not turn to continue following its path if the path bends. This input functions even if the last !activator is not currently watching through this entity. This input is called automatically on a round restart, when the Hold Time expires, or when the Look At target is destroyed."

	output OnEndFollow(void) : "Fired when the point_viewcontrol is Disabled for any reason, such as the Disable input being fired, a round restart occurring, the Hold Time expiring, or the Look At target being destroyed. This output even fires if the Disable input is called while no players are viewing through this entity."
] // end point_viewcontrol



	// PROP ENTITIES //

// Ficool says these should have origin keyvalues, but they work fine without it
// TODO: Alternately called detail_prop?
@PointClass base(SModel, SAngles, SBaseDiv) color(255 255 0) studioprop() = prop_detail : "Used to manually insert a detail prop into the map. This entity is for models; use prop_detail_sprite for detail sprites." [
	model(studio) : "Model" :  : "The model to appear as. Must be compiled with $staticprop and use UnlitGeneric shader on every material. Maximum string length is 128."

	detailOrientation(choices) : "Detail Orientation" : 0 : "How the prop will react to face the camera." = [
		0 : "Don't rotate"
		1 : "Rotate freely to face camera"
		2 : "Rotate around vertical axis to face camera"
	] // end detailOrientation
] // end prop_detail

// TODO: How to define sprite?
@PointClass base(SAngles, SBaseDiv) color(255 255 0) iconsprite("editor-ficool2/prop_detail_sprite") = prop_detail_sprite : "Used to manually insert a detail sprite into the map. This entity is for sprites; use prop_detail for detail props." [
	//origin(origin) : "Origin (X Y Z)" :  : "The position of the sprite."
	position_ul(vector) : "Upper Left Position" :  : "Location of the sprite's upper left corner, relative to the origin."
	position_lr(vector) : "Lower Right Position" :  : "Location of the sprite's lower right corner, relative to the origin."
	tex_ul(vector) : "Upper Left Texture" :  : ""
	tex_size(vector) : "Texture Size" :  : ""
	tex_total_size(float) : "Total Texture Size" :  : "The area of the detail texture that should constitute this sprite."
	detailOrientation(choices) : "Detail Orientation" : 2 : "How the sprite will react to face the camera." = [
		0 : "Don't rotate"
		1 : "Rotate freely to face camera"
		2 : "Rotate around vertical axis to face camera"
	] // end detailOrientation
] // end prop_detail_sprite

// TODO: developer.valvesoftware.com/wiki/Prop_dynamic lists updatechildren boolean keyvalue?
@BaseClass = prop_dynamic_keys [
	DefaultAnim(string) : "Default Animation" :  : "The name of the idle animation that this prop will revert to whenever it finishes a random or forced animation."
	RandomAnimation(choices) : "Randomly Animate?" : 0 : "If set, this prop will randomly choose and play animations, based upon the times specified in 'Min/Max Random Anim Time'. Inbetween the random animations, it will revert to playing the 'Default Animation'." = [
		0: "No"
		1: "Yes"
	] // end RandomAnimation
	MinAnimTime(float) : "Min Random Anim Time" : 5 : "Minimum time between random animations."
	MaxAnimTime(float) : "Max Random Anim Time" : 10 : "Maximum time between random animations."
	DisableBoneFollowers(choices) : "Disable Bone Followers?" : 1 : "If set, this prop won't generate phys_bone_followers." = [
		0: "No"
		1: "Yes"
	] // end DisableBoneFollowers
] // end prop_dynamic_keys
@PointClass base(SModel, SBaseEntity, SBaseDiv, SCollisions, SEnableDisable, SModelSkin, SModelBodyGroup, SClassDiv1, SPropDynamicIO, prop_dynamic_keys, SBaseDynamicModel, SBaseBreakableModel) color(255 100 0) sphere(fademindist) sphere(fademaxdist) studioprop() = prop_dynamic : "A prop capable of playing animations and being moved (by being parented to other entities). Dynamic props can also be used as breakable objects, but the model must either natively support being used as a breakable or it must be used with an *_override entity class." [
	spawnflags(flags) = [
		64 : "Use Hitboxes for Renderbox" : 0
		256 : "Start with Collision Disabled" : 0
	] // end spawnflags
] // end prop_dynamic

@PointClass base(prop_dynamic) color(255 100 0) sphere(fademindist) sphere(fademaxdist) studioprop() = dynamic_prop : "An alternative classname to prop_dynamic; converted to prop_dynamic on spawn. A prop capable of playing animations and being moved (by being parented to other entities). Dynamic props can also be used as breakable objects, but the model must either natively support being used as a breakable or it must be used with an *_override entity class." [
] // end dynamic_prop

// NOTE FROM FICOOL: Why is it associated with prop_dynamic in code if the door requires to be compiled as a physically-simulated object???
@BaseClass = prop_door_rotating_keys_1 [
	axis(axis) : "Hinge Axis" :  : "Axis around which to rotate when the door is opened. Despite Hinge Axis values, the door can only rotate on the Z Axis?"
	opendir(choices) : "Open Direction" : 0 : "Force the door to open only forwards or only backwards. Both directions is the standard door behavior." = [
		0 : "Open Both Directions"
		1 : "Open Forward Only"
		2 : "Open Backward Only"
	] // end opendir
	returndelay(integer) : "Delay Before Close (-1 stay open)" : -1 : "Amount of time, in seconds, after the door has opened before it closes. If the value is set to -1, the door never closes itself."
	hardware(choices) : "Hardware Type" : 1 : "The type of mechanism used to open the door (handle, push bar, keypad). The mechanism only appears in the game, not in Hammer. " = [
		0 : "None"
		1 : "Lever (i.e. door handle)"
		2 : "Push bar"
		3 : "Keypad"
	] // end hardware
	spawnpos(choices) : "Spawn Position" : 0 : "State the door should begin in. Check the door's angles to see forward/backward orientation." = [
		0 : "Closed"
		1 : "Open forward"
		2 : "Open back"
		3 : "Ajar (use Ajar Angles)"
	] // end spawnpos
	ajarangles(angle) : "Ajar Angles (Pitch Yaw Roll)" : "0 0 0" : "If the door 'Spawn Position' is set to Ajar, these are the angles to spawn at, instead of being open or closed."
	slavename(target_destination) : "Linked Door" :  : "The name of any doors that should be linked to this door (i.e. should open when this one opens, and close when this one closes)."
] // end prop_door_rotating_keys_1
@BaseClass = prop_door_rotating_keys_2 [
	soundopenoverride(sound) : "Fully Open Sound" :  : "Sound played when the door has finished opening."
	soundcloseoverride(sound) : "Fully Closed Sound" :  : "Sound played when the door has finished closing."
	soundmoveoverride(sound) : "Moving Sound" :  : "Sound played when the door starts to move."
	soundlockedoverride(sound) : "Locked Sound" :  : "Sound played when the player tries to open the door, and fails because it's locked."
	soundunlockedoverride(sound) : "Unlocked Sound" :  : "Sound played when the door is unlocked."
] // end prop_door_rotating_keys_2
@PointClass base(SModel, SBaseEntity, SBaseDiv, SCollisions, SEnableDisable, SModelSkin, SModelBodyGroup, SClassDiv1, SRotateDistance, SDoor, prop_door_rotating_keys_1, SClassDiv2, prop_door_rotating_keys_2, SClassDiv3, SPropDynamicIO, prop_dynamic_keys, SBaseDynamicModel, SBaseBreakableModel, prop_dynamic) sphere(fademindist) sphere(fademaxdist) color(255 100 0) studioprop() = prop_door_rotating : "An entity used to place a door in the world." [
	// TODO: Missing any spawnflags from this list?
	//spawnflags(flags) = [
	//	1024 : "Touch Opens " : 0
	//	256 : "Use Opens" : 0
	//	8192 : "Use Closes" : 0
	//	32768 : "Ignore player +USE" : 0
    //	32 : "Toggle" : 0
	//	512 : "NPCs Can't Open This Door" : 0
	//	4096 : "Door Silent - Door makes no sound" : 0
	//	16384 : "Door Silent to NPCS" : 0
	//	8 : "Passable" : 0
	//	1 : "Starts Open" : 0
	//	2048 : "Starts Locked" : 0
	//	524288 : "Starts Unbreakable" : 0
	//	4 : "Don't Link" : 0
	//] // end spawnflags

	spawnflags(flags) = [
		2048 : "Starts Locked - Cannot be opened or closed while locked" : 0
		4096 : "Silent Door - Does not play sounds" : 0
		8192 : "+USE Closes" : 0
		32768 : "Ignore Player +USE" : 0
	] // end spawnflags

	input OpenAwayFrom(target_destination) : "Open the door away from the specified entity."
	input SetRotationDistance(float) : "Set the distance (in degrees) between Open and Closed."
] // end prop_door_rotating

// TODO: What flags are automatically set? Is it the effect flag(s)?
@BaseClass = prop_dynamic_ornament_keys [
	InitialOwner(target_destination) : "Target Entity" :  : "Name of the entity that this ornament should attach to, at startup."
] // end prop_dynamic_ornament_keys
@PointClass base(SModel, SBaseEntity, SBaseDiv, prop_dynamic_ornament_keys, SCollisions, SEnableDisable, SModelSkin, SModelBodyGroup, SClassDiv1, SPropDynamicIO, prop_dynamic_keys, SBaseDynamicModel, SBaseBreakableModel, prop_dynamic) color(255 100 0) sphere(fademindist) sphere(fademaxdist) studioprop() = prop_dynamic_ornament : "Identical to prop_dynamic, but has bonemerge flags automatically set, which means it will automatically attach to its parent. Can be used to attach hats and weapons to the hands of player models." [
	input SetAttached(target_destination) : "Attach the ornament to a different entity. Parameter should be the name of entity to attach to."
	input Detach(string) : "Detach from the Target Entity and become invisible. The ornament can be re-attached with the SetAttached input."
] // end prop_dynamic_ornament

@PointClass base(SModel, SBaseEntity, SBaseDiv, SCollisions, SEnableDisable, SModelSkin, SModelBodyGroup, SClassDiv1, SPropDynamicIO, prop_dynamic_keys, SBaseDynamicModel, SBaseBreakableModel, SHealth, prop_dynamic) color(255 100 0) sphere(fademindist) sphere(fademaxdist) studioprop() = prop_dynamic_override : "Identical to prop_dynamic, but allows the use of any model (including models not intended to be used as dynamic props). It is also capable of overriding a model's built-in health value, which can allow ordinarily unbreakable props to be used as breakables. Becomes a prop_dynamic on spawn." [
	health(integer) : "Health" : 0 : "Amount of damage this entity can take before dying, breaking, or opening."
] // end prop_dynamic_override

// TODO: Test
@PointClass base(prop_dynamic) color(255 100 0) sphere(fademindist) sphere(fademaxdist) studioprop() = training_prop_dynamic : "Same as prop_dynamic, but with an additional flag for training." [
	spawnflags(flags) = [
		512 : "Custom collision with grenades and sticky bombs" : 1
	] // end spawnflags
] // end training_prop_dynamic

@BaseClass = prop_physics_keys [
	inertiaScale(float) : "Scale Factor For Inertia" : "1.0" : "Scales the angular mass of an object. Used to hack angular damage and collision response."
	//puntsound(sound) : "Sound to Make when Punted"  :  : ""
] // end prop_physics_keys
@PointClass base(SModel, SBaseEntity, SBaseDiv, SModelSkin, SModelBodyGroup, SPhysics, prop_physics_keys, SBaseBreakableModel, SBaseDynamicModel) color(255 100 0) sphere(exploderadius) sphere(fademindist) sphere(fademaxdist) studioprop() = prop_physics : "A prop that physically simulates as a single rigid body. It can be constrained to other physics objects using hinges or other constraints. It can also break when it takes enough damage, if the model supports it; use an *_override entity class to override this." [
	// TODO: Compare spawnflags with src-ents.shoutwiki.com/wiki/CPhysicsProp
	spawnflags(flags) = [
		1 : "Start Asleep" : 1
		8 : "Start Motion Disabled" : 0
		//64 : "Enable motion on Physgun grab" : 0
		1024 : "Prevent motion enable on player bump" : 0
		4 : "Debris - Don't collide with the player or other debris" : 0
		4096 : "Debris w/ Trigger Interaction - Can touch triggers without 'Physics Debris' spawnflag" : 0
		2097152 : "No Collisions - Causes prop to fall through world" : 0 // TODO: Test
		128 : "Not affected by rotor wash" : 0
		256 : "Generate output on +use " : 0
		512 : "Prevent pickup" : 0
		//1048576 : "Physgun can always pick up. No matter what." : 0
		2 : "Don't take physics damage" : 0
		8192 : "Force server-side (multiplayer only)" : 0 // TODO: In prop_physics_multiplayer only?
	] // end spawnflags

	//input EnablePuntSound(void) : "Allow this prop to play its own sound when punted."
	//input DisablePuntSound(void) : "Prevent this prop from playing its own sound when punted."

	output OnPlayerPickup(void) : "Fired whenever the player picks up this prop (with the physcannon or with +USE)."
	output OnOutOfWorld(void) : "Fired whenever the prop is out of the allowed world bounds."
] // end prop_physics

@PointClass base(prop_physics) = physics_prop : "An alternative classname to prop_physics; converted to prop_physics on spawn. A prop that physically simulates as a single rigid body. It can be constrained to other physics objects using hinges or other constraints. It can also break when it takes enough damage, if the model supports it; use an *_override entity class to override this." [
] // end physics_prop

@BaseClass = prop_physics_multiplayer_keys [
	physicsmode(choices) : "Physics Mode" : 0 : "Change the physics mode of this entity." = [
		0 : "Auto Detect"
		1 : "Solid, Server-side"
		2 : "Non-Solid, Server-side (still gets pushed away by player)"
		3 : "Non-Solid, Client-side"
	] // end physicsmode
] // end prop_physics_multiplayer_keys
@PointClass base(SModel, SBaseEntity, SBaseDiv, SModelSkin, SModelBodyGroup, SPhysics, prop_physics_keys, prop_physics_multiplayer_keys, SBaseBreakableModel, SBaseDynamicModel, prop_physics) color(255 100 0) sphere(fademindist) sphere(fademaxdist) studioprop() = prop_physics_multiplayer : "Identical to prop_physics, except the runtime collisions use a more bouncy method that avoids the prediction errors normal physics objects get." [
] // end prop_physics_multiplayer

@PointClass base(SModel, SBaseEntity, SBaseDiv, SModelSkin, SModelBodyGroup, SPhysics, prop_physics_keys, SBaseBreakableModel, SHealth, SBaseDynamicModel, prop_physics) color(255 100 0) sphere(fademindist) sphere(fademaxdist) studioprop() = prop_physics_override : "Identical to prop_physics, but allows models not compiled for physical simulation to be used. It is also capable of overriding a model's built-in health value, which can allow ordinarily unbreakable props to be used as breakables. Becomes a prop_physics when spawned." [
	health(integer) : "Health" : 0 : "Amount of damage this entity can take before dying, breaking, or opening."
] // end prop_physics_override

// TODO: Confirm this is broken? http://src-ents.shoutwiki.com/wiki/Prop_physics_respawnable
@BaseClass = prop_physics_respawnable_keys [
	RespawnTime(float) : "Respawn Time" : 60 : "Amount of time this prop will respawn after it breaks, in seconds."
] // end prop_physics_respawnable_keysz
@PointClass base(SModel, SBaseEntity, SBaseDiv, SModelSkin, SModelBodyGroup, SPhysics, prop_physics_keys, SBaseBreakableModel, prop_physics_respawnable_keys, SBaseDynamicModel, prop_physics) color(255 100 0) sphere(fademindist) sphere(fademaxdist) studioprop() = prop_physics_respawnable : "Identical to prop_physics, except it respawns after breaking. Seems to be broken however, use a point_template instead." [
] // end prop_physics_respawnable

// TODO: Check this has the right inheritance
@BaseClass = prop_soccer_ball_keys [
	// TODO: What does this do?
	trigger_name(target_destination) : "Trigger Name" :  : "The name of the trigger(s) to try and touch."
] // end prop_soccer_ball_keys
@PointClass base(SModel, SBaseEntity, SBaseDiv, prop_soccer_ball_keys, SModelSkin, SModelBodyGroup, SPhysics, prop_physics_keys, SBaseBreakableModel, SBaseDynamicModel, prop_physics) color(255 100 0) sphere(fademindist) sphere(fademaxdist) studioprop() = prop_soccer_ball : "Very bouncy physically-simulated entity. Flies at high velocity and plays sounds when touched. Any model is accepted." [
	model(studio) : "Model" : "models/props_gameplay/ball001.mdl" : "The model this entity should appear as. 128-character limit."
] // end prop_soccer_ball

@PointClass base(prop_physics, SClassDiv1) color(255 100 0) sphere(fademindist) sphere(fademaxdist) sphere(sizehelper) studioprop() = prop_sphere : "A physically simulated prop with a perfectly spherical collision mesh. The radius of the collision mesh is locked at 12HU." [
	sizehelper(choices) : "Size Helper (Display Only)" : 12 : "DO NOT CHANGE. Helper keyvalue to show the collision mesh size (12HU radius). Changing this value WILL NOT change the radius of the collision mesh; this is for display purposes only." = [
		12 : "12"
	] // end sizehelper
] // end prop_sphere

// This doesn't even inherit any physics keyvalues!
@BaseClass = prop_ragdoll_keys [
	angleOverride(string) : "Override Animation" :  : "Filled in by the engine via hammer_update_entity, do not edit by hand except to clear."
	sequence(integer) : "Sequence" :  : "Animation sequence to spawn the ragdoll in, by index NOT name!"
] // end prop_ragdoll_keys
@PointClass base(SModel, SBaseEntity, SBaseDiv, prop_ragdoll_keys, SEnableDisable, SModelSkin, SModelBodyGroup, SBaseDynamicModel) color(255 100 0) sphere(fademindist) sphere(fademaxdist) studioprop() = prop_ragdoll : "A prop that physically simulates and can be articulated with internal joints. The joint constraints are part of the physics model. Very expensive to simulate." [
	spawnflags(flags) = [
		65536 : "Start Asleep" : 0
		16384 : "Start Motion Disabled" : 0
		4 : "Debris - Don't collide with the player or other debris (better performance)" : 1
		8192 : "Allow Dissolve" : 1
		32768 : "Allow Stretch" : 0
	] // end spawnflags

	input DisableMotion(void) : "Disable physics motion/collision response."
	input EnableMotion(void) : "Enable physics motion/collision response."
	input FadeAndRemove(float) : "Fade out then remove self. Parameter override = duration of fade"
	input StartRagdollBoogie(void) : "Perform ragdoll boogie effect for 5 seconds."
] // end prop_ragdoll

@PointClass base(prop_ragdoll) color(255 100 0) sphere(fademindist) sphere(fademaxdist) studioprop() = physics_prop_ragdoll : "Identcial to prop_ragdoll. A prop that physically simulates and can be articulated with internal joints. The joint constraints are part of the physics model. Very expensive to simulate." [
] // end physics_prop_ragdoll

@PointClass base(prop_ragdoll) color(255 100 0) sphere(fademindist) sphere(fademaxdist) studioprop() = prop_ragdoll_attached : "Identical to prop_ragdoll, but signals the ragdoll is attached to change collision responses." [
] // end prop_ragdoll_attached

// TODO: Alternately static_prop?
@BaseClass = prop_static_keys [
	disableshadows(choices) : "Disable Shadows?" : 0 : "Prevent this prop from casting lightmap shadows." = [
		0 : "No"
		1 : "Yes"
	] // end disableshadows
	disablevertexlighting(choices) : "Disable Vertex Lighting?" : 0 : "If set to Yes, this prop will be lit uniformly with a lighting value sampled from its origin. Vertex lighting is always disabled on models with $bumpmapped materials." = [
		0 : "No"
		1 : "Yes"
	] // disablevertexlighting
	lightingorigin(target_destination) : "Lighting Origin" :  : "An info_lighting from which to sample lighting (instead of the model's origin). Requires vertex lighting to be disabled."
	disableselfshadowing(choices) : "Disable Self-Shadowing?" : 0 : "Prop will not cast shadows on itself when vertex lighting is calculated." = [
		0 : "No"
		1 : "Yes"
	] // end disableselfshadowing
	ignorenormals(choices) : "Ignore Surface Normal for Lighting?" : 0 : "A surface normal defines the direction from which each polygon is brightest-lit, and how much light is received. Setting this to Yes will ignore the surface normal when vertex lighting is calculated. Great for foilage." = [
		0 : "No"
		1 : "Yes"
	] // end ignorenormals
	generatelightmaps(choices) : "Generate Prop Lightmaps?" : 0 : "If yes, this prop will have lightmaps generated and used for it instead of vertex lighting (similar to how brushes are lit)." = [
		0 : "No"
		1 : "Yes"
	] // end generatelightmaps
	lightmapresolutionx(integer) : "Lightmap Resolution X" : 32 : "The number of luxels on this prop's generated lightmap in the X (or U) direction (only used if Generate Lightmaps is Yes). This value functions inversely to brush lightmap scale; in this case, higher values mean more luxels. Cannot be previewed using 3D Lightmap Grid view in Hammer, use the console command 'mat_luxels 1' in-game instead."
	lightmapresolutiony(integer) : "Lightmap Resolution Y" : 32 : "The number of luxels on this prop's generated lightmap in the Y (or V) direction (only used if Generate Lightmaps is Yes). This value functions inversely to brush lightmap scale; in this case, higher values mean more luxels. Cannot be previewed using 3D Lightmap Grid view in Hammer, use the console command 'mat_luxels 1' in-game instead."
] // end prop_static_keys
@PointClass base(SModel, SAngles, SBaseDiv, SCollisions, SModelSkin, SClassDiv1, prop_static_keys, SModelSettings) color(255 255 0) sphere(fademindist) sphere(fademaxdist) studioprop() = prop_static : "A prop that doesn't move and doesn't animate, essentially being part of the map geometry. This is the cheapest way to insert models into a map." [ // line(255 255 255, targetname, lightingorigin) // Causes the little box to not appear when it has no model :shrug:
	model(studio) : "Model" :  : "The model this entity should appear as. 128-character limit. Must be compiled with $staticprop to work."
	solid(choices) : "Collisions" : 6 : "Method of collision for this entity." = [
		0 : "Non-solid" // prop_static, prop_dynamic: Nonsolid (expected)
		//1 : "BSP (QPhysics)" // prop_static, prop_dynamic: Nonsolid
		6 : "VPhysics (collision mesh)" // prop_static, prop_dynamic: Collide with collision mesh
		2 : "Bounding Box" // prop_static: Collide with grid-aligned bounding box (expected); prop_dynamic: Collide with unrotated bounding box
		//3 : "Oriented Bounding Box" // prop_static: Nonsolid; prop_dynamic: Collide with oriented bounding box, sometimes gets stuck
		//4 : "Oriented Bounding Box, constrained to Yaw only" // prop_static, prop_dynamic: Nonsolid
		//5 : "Custom (defined per-entity, if not defined the entity will have bizarre collision behavior)" // prop_static, prop_dynamic: Nonsolid
	] // end solid
] // end prop_static

@BaseClass = prop_vehicle_keys [
	vehiclescript(string) : "Vehicle Script File" : "scripts/vehicles/jeep_test.txt" : "The vehicle script files contained in scripts/vehicles/ define the behaviour and handling of a vehicle."
	actionScale(float) : "Scale of Action Input / Framerate" : "1.0" : "How fast the vehicle turns/accelerates."
] // end prop_vehicle_keys
@PointClass base(SBaseEntity, SBaseDiv, prop_vehicle_keys, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/buggy.mdl") = prop_vehicle : "Vehicle that can be driven via inputs." [
	spawnflags(flags) = [
		1 : "Always Think (Run physics every frame) - Must be used in multiplayer!" : 1
	] // end spawnflags

	input Action(float) : "Set the speed of the action animation."
	input HandBrakeOff(void): "Releases the handbrake."
	input HandBrakeOn(void) : "Turns the handbrake on."
	input Lock(void) : "Prevent the player from entering or exiting the vehicle."
	input Steer(float) : "Steer the vehicle +/-1."
	input Throttle(float) : "Throttle +/-1."
	input TurnOff(void) : "Turn off: Stop engine, disable throttle, engage brakes."
	input TurnOn(void) : "Turn on: Start engine & enable throttle."
	input Unlock(void) : "Re-allow the player to enter or exit the vehicle."
] // end prop_vehicle

@BaseClass = prop_vehicle_driveable_keys [
	EnableGun(choices) : "Gun Enabled?" : 0 : "Whether the vehicle's gun is enabled or disabled." = [
		0 : "No"
		1 : "Yes"
	] // end EnableGun
	VehicleLocked(choices) : "Start Locked?" : 0 = [
		0 : "No"
		1 : "Yes"
	] // end VehicleLocked
] // end prop_vehicle_driveable_keys
@PointClass base(SBaseEntity, SBaseDiv, prop_vehicle_keys, prop_vehicle_driveable_keys, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/airboat.mdl") = prop_vehicle_driveable : "Generic vehicle driveable by a player. Very broken functionality in Team Fortress 2. If the player +uses the vehicle, they will not be able to exit or drive, the only escape is death or disconnection." [
	input EnableGun(bool) : "Enables or disables the vehicle gun. 1 = enabled, 0 = disabled."

	output AttackAxis(string) : "State of attack button [0,1]."
	output Attack2Axis(string) : "State of attack2 button [0,1]."
	output PlayerOff(void) : "Player exited the vehicle."
	output PlayerOn(void) : "Player entered the vehicle."
	output PressedAttack(void) : "Player pressed +attack."
	output PressedAttack2(void) : "Player pressed +attack2."
] // end prop_vehicle_driveable



	// SCRIPTED ENTITIES //

@PointClass base(SBaseEntity, SBaseDiv) color(150 0 200) studioprop("models/editor/scriptedsequence.mdl") sphere(m_flRadius) = scripted_sequence : "Grabs an NPC and makes them play a specified set of animations. The NPC can be told to move to the scripted sequence position or can be told to play the script wherever they currently are. Multiple scripted sequences of the same name will frame-synchronize in the action animation once all the actors have moved to position. This allows tight interaction between actors (one actor grabbing another, hitting them, etc.) The flow is as follows:\n" +
	"1) Move to position using the specified movement animation. If 'Move to Position' is set to NONE, skip to step 2.\n" +
	"2) If forced to wait for another actor to move to position, play the pre-action idle animation, otherwise skip to step 3. If there is no pre-action idle specified, ACT_IDLE is used.\n" +
	"3) Fire the OnBeginSequence output.\n" +
	"4) Play the action animation. If no action animation is specified, skip to step 5.\n" +
	"5) Play the post-action idle animation. If none is specified, skip to step 6. If the 'Loop in Post Idle' spawnflag is set, keep playing the post-action idle until the script is cancelled. If no post-action idle animation is specified, ACT_IDLE is used.\n" +
	"6) Fire the OnEndSequence output.\n" +
	"7) If a next script to play is specified, hand the NPC to the next script and repeat this process for that script.\n" +
	"The MoveToPosition input runs steps 1 and 2, then waits while playing the pre-action idle animation until the BeginSequence input is received. If the sequence has motion extraction in it, set the 'Don't Teleport NPC On End' spawnflag." [
	m_iszEntity(target_destination) : "Target NPC" : : "The name or class name (such as 'npc_zombie') of an NPC to use for this script."
	m_iszIdle(string) : "Pre Action Idle Animation" :  : "The name of the sequence (such as 'idle01') or activity (such as 'ACT_IDLE') to play before the action animation if the NPC must wait for the script to be triggered. Use 'Start on Spawn' flag or MoveToPosition input to play this idle animation."
	m_iszEntry(string) : "Entry Animation" :  : "The name of the sequence (such as 'reload02') or activity (such as 'ACT_RELOAD') to play when the sequence starts, before transitioning to play the main action sequence."
	m_iszPlay(string) : "Action Animation" :  : "The name of the main sequence (such as 'reload02') or activity (such as 'ACT_RELOAD') to play."
	m_iszPostIdle(string) : "Post Action Idle Animation" :  : "The name of the sequence (such as 'idle01') or activity (such as 'ACT_IDLE') to play after the action animation."
	m_iszCustomMove(string) : "Custom Move Animation" :  : "Used in conjunction with the 'Custom movement' setting for the 'Move to Position' property, specifies the sequence (such as 'crouch_run01') or activity (such as 'ACT_RUN') to use while moving to the scripted position."
	m_bLoopActionSequence(Choices) : "Loop Action Animation?" : 0 = [
		0 : "No"
		1 : "Yes"
	] // end m_bLoopActionSequence
	m_bSynchPostIdles(Choices) : "Synch Post Idles?" : 0 = [
		0 : "No"
		1 : "Yes"
	] // end m_bSynchPostIdles
	m_flRadius(integer) : "Search Radius (0=everywhere)" : 0 : "Radius to search within for an NPC to use. 0 searches everywhere."
	m_flRepeat(integer) : "Repeat Rate ms" : 0
	m_fMoveTo(Choices) : "Move to Position" : 1 = [
		0 : "No"
		1 : "Walk"
		2 : "Run"
		3 : "Custom movement"
		4 : "Instantaneous"
		5 : "No - Turn to Face"
	] // end m_fMoveTo
	m_iszNextScript(target_destination) : "Next Script" : : "The name of the script to run immediately after this script completes. The NPC will not return to AI between the two scripts."
	m_bIgnoreGravity(choices) : "Ignore Gravity on NPC during script" : 0 : "If this is set to 'Yes', the NPC will not be subject to gravity while playing this script." = [
		0 : "No"
		1 : "Yes"
	] // end m_bIgnoreGravity
	m_bDisableNPCCollisions(choices) : "Disable NPC collisions during script" : 0 : "Useful for when NPCs playing scripts must interpenetrate while riding on trains, elevators, etc. This only disables collisions between the NPCs in the script and must be enabled on BOTH scripted_sequences." = [
		0 : "No"
		1 : "Yes"
	] // end m_bDisableNPCCollisions
	onplayerdeath(choices) : "On player death" : 0 : "What should this entity do if the player dies" = [
		0 : "Do Nothing"
		1 : "Cancel Script and return to AI"
	] // end onplayerdeath

	spawnflags(flags) = [
		4 : "Repeatable" : 0
		8 : "Leave Corpse" : 0
		16 : "Start on Spawn" : 0
		32: "No Interruptions" : 0
		64: "Override AI" : 0
		128: "Don't Teleport NPC On End" : 0
		256: "Loop in Post Idle" : 0
		512: "Priority Script" : 0
		4096: "Allow Actor Death" : 0
	] // end spawnflags

	input BeginSequence(void) : "Summons an NPC to act out the scripted sequence."
	input CancelSequence(void) : "Stops the scripted sequence. If fired after a sequence starts, this input will not take effect until the NPC finishes playing the scripted action animation."
	input MoveToPosition(void) : "Summons an NPC to the script location. They will play their scripted idle (or ACT_IDLE if none is specified) until BeginSequence is triggered."

	output OnBeginSequence(void) : "Fires when the action animation begins playing."
	output OnCancelFailedSequence(void) : "Fires when the sequence is cancelled without ever playing (OnCancelSequence will also fire)."
	output OnCancelSequence(void) : "Fires when the sequence is cancelled."
	output OnEndSequence(void) : "Fires when the action animation completes."
	output OnScriptEvent01(void) : "Fires when a 'trigger' anim event occurs while playing the script. Use { event 1003 framenum 1 } in the QC."
	output OnScriptEvent02(void) : "Fires when a 'trigger' anim event occurs while playing the script. Use { event 1003 framenum 2 } in the QC."
	output OnScriptEvent03(void) : "Fires when a 'trigger' anim event occurs while playing the script. Use { event 1003 framenum 3 } in the QC."
	output OnScriptEvent04(void) : "Fires when a 'trigger' anim event occurs while playing the script. Use { event 1003 framenum 4 } in the QC."
	output OnScriptEvent05(void) : "Fires when a 'trigger' anim event occurs while playing the script. Use { event 1003 framenum 5 } in the QC."
	output OnScriptEvent06(void) : "Fires when a 'trigger' anim event occurs while playing the script. Use { event 1003 framenum 6 } in the QC."
	output OnScriptEvent07(void) : "Fires when a 'trigger' anim event occurs while playing the script. Use { event 1003 framenum 7 } in the QC."
	output OnScriptEvent08(void) : "Fires when a 'trigger' anim event occurs while playing the script. Use { event 1003 framenum 8 } in the QC."
] // end scripted_sequence

@PointClass base(SBaseEntity, SBaseDiv) color(150 0 200) iconsprite("editor-ficool2/scripted_sentence") sphereradius() = scripted_sentence : "Creates a scripted sentence, usually spoken by an NPC." [
	sentence(string) : "Sentence Name" :  : "The sentence group name, as found in sentences.txt."
	entity(target_destination) : "Speaker Type" :  : "The entity who will speak the sentence."
	delay(integer) : "Additional Sentence Time" : 0 : ""
	radius(integer) : "Search Radius" : 512 : "Radius to search within for an NPC to use. A value of 0 searches everywhere in the map."
	refire(string) : "Delay Before Refire" : "3" : "Timed delay (in seconds) before refiring."
	listener(string) : "Listener Type" :  : ""
	volume(integer) : "Volume (0 - 10)" : 10 : "Volume of sounds. 0 is totally silent, 10 is maximum loudness."
	attenuation(Choices) : "Sound Radius" : 0 = [
		0 : "Small Radius"
		1 : "Medium Radius"
		2 : "Large  Radius"
		3 : "Play Everywhere"
	] // end attenuation

	spawnflags(flags) = [
		1 : "Fire Once"  : 1
		2 : "Followers Only" : 0
		4 : "Interrupt Speech" : 1
		8 : "Concurrent" : 0
		16 : "Speak to Activator" : 1
	] // end spawnflags

	input BeginSentence(void) : "Starts the scripted sentence."

	output OnBeginSentence(void) : "Fires when the sentence begins"
	output OnEndSentence(void) : "Fires when the sentence ends"
] // end scripted_sentence

@PointClass base(SBaseEntity, SBaseDiv, SEnableDisable) color(150 0 200) iconsprite("editor-ficool2/scripted_target")  = scripted_target : "A point entity that targets an NPC for use in scripted sequences." [
	m_iszEntity(npcclass) : "Target NPC" :  : "The NPC to target."
	m_flRadius(integer) : "Search Radius (0 = everywhere)" : 0 : "Radius to search within for an NPC to use. 0 searches everywhere."
	MoveSpeed(integer) : "Move Speed" : 5 : "How quickly should target move between scripted targets."
	PauseDuration(integer) : "Pause Duration" : 0 : "How long should target pause at scripted target."
	EffectDuration(integer) : "Effect Duration" : 2 : "How long should any associated effect last."
	target(target_destination) : "Next Target"	:  : "Next scripted target."

	output AtTarget(void) : "Fires when NPC reaches this target."
	output LeaveTarget(void) : "Fires when NPC leaves this target."
] // end scripted_target



	// SHADOW ENTITIES //

@PointClass base(SPreservedEntity, SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/shadow_control") sphere(distance) = shadow_control : "An entity to control dynamic shadows in the map. This entity's Pitch Yaw Roll determines which direction entities cast their shadows. For some reason, if set to '0 0 0', defaults to casting shadows straight down." [
	//direction(vector) : "Shadow Direction" :  : "Set the shadow direction. Duplicated with Angles for whatever reason, so change both." // Doesn't actually seem to do anything, always overridden by Pitch Yaw Roll. Only way to use this is to not give this entity an Angles keyvalue in the FGD
	angles(angle) : "Shadow Angle (Y Z X)" : "0 0 0" : "The angle at which dynamic shadows are cast from entities. Pitch is rotation around the Y axis, Yaw is rotation around the Z axis, and Roll is rotation around the X axis. Note that the pitch value in this entity functions inversely to the pitch in light entities, including light_environment."
	color(color255) : "Shadow Color" : "128 128 128" : "This is the color of the shadows."
	distance(float) : "Maximum Distance" : 128 : "This is the maximum distance the shadow is allowed to cast, in units. Maximum is 4096."
	disableallshadows(Choices) : "All Shadows Disabled?" : 0 : "Disable shadows entirely." = [
		0 : "No"
		1 : "Yes"
	] // end disableallshadows

	input Color(color255) : "Set the shadow color."
	input Direction(vector) : "Set the shadow direction, but using a vector instead of angles."
	input SetAngles(string) : "Set the shadow direction, using Pitch Yaw Roll."
	input SetDistance(float) : "Set the maximum shadow cast distance."
	input SetShadowsDisabled(bool) : "Set shadows disabled state. 0 = allow casting shadows, 1 = disable casting shadows."
] // end shadow_control



	// SIMPLE ENTITIES //

@PointClass base(SBaseEntity, SBaseDynamicModel) color(150 0 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/humans/group01/female_01.mdl") = simple_bot : "A NextBot entity that displays the bare bones of navigation. It has no animations, its model cannot be changed, and it cannot be killed by normal means. If spawned and the map has a navigation mesh, it just wanders around aimlessly." [
] // end simple_bot



	// SKY ENTITIES //

// NOTE FROM FICOOL: removed iconsprite due to scale keyvalue affecting the sprite and making it massive
@PointClass base(SPreservedEntity, SBaseEntity, SBaseDiv) size(-2 -2 -2, 2 2 2) sphere(fogstart) sphere(fogend) = sky_camera : "An entity used to control the 3D skybox. Its origin is used to determine the 3D skybox's position relative to the map. Place this entity, in the 3D skybox, at the point where the origin of the map should be." [
	scale(integer) : "3D Skybox Scale" : 16 : "This number determines how large objects in your skybox will seem relative to the map. An object 1 HU tall in the skybox will appear this many HU tall to the player. Default is 16. This is the recommended value, as basically all skybox props are scaled around a skybox scale of 16."
	fogenable(choices) : "Fog Enable?" : 0 : "Enable or disable the fog by default." = [
		0 : "No"
		1 : "Yes"
	] // end fogenable
	use_angles(choices) : "Use Angles for Fog Direction?" : 0 : "Use Pitch Yaw Roll for the Fog Blend direction instead of Primary Fog Direction. There isn't much use for this unless you want the direction to rotate." = [
		0 : "No"
		1 : "Yes"
	] // end use_angles
	fogstart(float) : "Fog Start" : 512 : "Distance at which the fog should start."
	fogend(float) : "Fog End" : 2048 : "Distance at which the fog should be fully opaque."
	fogmaxdensity(float) : "Fog Max Density" : 1 : "Maximum density of the fog. [0..1] "
	fogcolor(color255) : "Primary Fog Color" : "255 255 255" : "Primary Fog Color."
	fogcolor2(color255) : "Secondary Fog Color (Optional)" : "255 255 255" : "Secondary Fog Color. If Fog Blend is disabled, this color will never appear."
	fogblend(choices) : "Fog Color Blend?" : 0 : "Enables color blending between Primary Fog Color and Secondary Fog Color. When the viewer looks in the Primary Fog Direction, fog will appear as the Primary color. When looking away from the specified direction, fog appears as the Secondary Color. If the camera is not pointed directly at or away from the direction, a blend of the two colors will result. Sunlight with a Yaw of 45 degrees and a Pitch of -45 degrees could be enhanced using a Primary Fog Direction of '-1 -1 1', a Primary Fog Color of '120 110 100' and a Secondary Fog Color of '80 70 60'." = [
		0 : "No"
		1 : "Yes"
	] // end fogblend
	fogdir(vector) : "Primary Fog Direction" : "1 0 0" : "A vector (given by three space-separated numbers X Y Z) which points from the Secondary Fog Color towards the Primary Fog Color."
] // end sky_camera



	// SPARK ENTITIES //

@PointClass base(SBaseEntity) iconsprite("editor-ficool2/spark_shower") = spark_shower : "Creates a trail of sparks in a random 60 degree spread from its angles. This entity will delete itself after creating the effect upon spawning." [
] // end spark_shower



	// TANK ENTITIES //

@PointClass base(SBaseEntity, SBaseDiv, SBoss, SBaseDynamicModel) color(150 0 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/bots/boss_bot/static_boss_tank.mdl") = tank_boss : "The Tank boss used in Mann vs Machine missions. When spawned in by a popfile, it will start at the path_track entity specified by the popfile and continue until it reaches the end of the path, where it will deploy the bomb. When destroyed, it creates a tank_destruction entity." [
	speed(float) : "Speed" : 75 : "The speed at which this tank moves, in HU/sec. High values can cause the tank to go through geometry!"

	// TODO: How do these work?
	input DestroyIfAtCapturePoint(integer) : "Destroy if at Capture Point."
	input AddCaptureDestroyPostfix(string) : "Set the postfix for the destroy animation when it's at the capture point."
] // end tank_boss

@PointClass base(SBaseEntity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/bots/boss_bot/boss_tank_part1_destruction.mdl") = tank_destruction : "The destruction of a MvM Tank, spawned when a tank_boss is killed." [
] // end tank_destruction



	// TANKTRAIN ENTITIES //

@PointClass base(SDoesNotFunction, SBaseLogical, SBaseDiv) color(150 0 200) iconsprite("editor-ficool2/tanktrain_ai") = tanktrain_ai : "This is the AI to make an associated func_tracktrain or func_tanktrain automatically move along its path to the node closest to a target. Due to poor coding, the train actually just moves as normal, but locked to a speed of 1HU per second." [
	target(target_destination) : "Train Name" :  : "The func_tracktrain or func_tanktrain to control."
	TargetEntity(target_destination) : "Target" :  : "The entity that the train should move towards."
	startsound(sound) : "Start Moving Sound" : "vehicles/diesel_start1.wav" : "The sound to play when the train starts moving."
	enginesound(sound) : "Engine Loop Sound" : "vehicles/diesel_turbo_loop1.wav" : "The engine sound is looped when it plays."
	movementsound(sound) : "Vehicle Movement Sound" : "vehicles/tank_treads_loop1.wav" : "The looping sound to play while the train is moving."

	input TargetEntity(target_destination) : "Set the entity that the train should move towards."
] // end tanktrain_ai

@PointClass base(SBaseLogical, SBaseDiv) color(150 0 200) iconsprite("editor/tanktrain_aitarget") = tanktrain_aitarget : "An entity that changes the target of a tanktrain_ai entity. Legacy support only, use ai_changetarget instead." [
	target(target_destination) : "Tank AI Entity" :  : "The tanktrain_ai entity to change the target of."
	newtarget(target_destination) : "New Target Entity" :  : "The entity to tell the tanktrain_ai to target."
] // end tanktrain_aitarget



	// TARGET ENTITIES //

@PointClass base(SBaseLogical, SBaseDiv) = target_changegravity : "An entity for scaling the gravity of the !activator player. This entity also remembers the previous gravity value of the last player whose gravity was changed, so that it can reset the player's gravity to its former value.\n" +
	"NOTE: Due to an oversight, the gravity keyvalue can only be an integer, so fractional gravity values cannot be used. This also means a player cannot be given reduced gravity with this entity. For more flexible alternatives, use trigger_gravity or directly change the player's 'gravity' keyvalue with AddOutput." [
	gravity(integer) : "Gravity" : 1 : "The multiplier for the player's gravity. Must be an integer (whole number), and cannot be 0."

	input ChangeGrav(void) : "Change the gravity of the activating player to the Gravity keyvalue."
	input ResetGrav(void) : "Change the gravity of the activating player to the amount of gravity that was previously experienced by the most recent !activator of the ChangeGrav input before their gravity was changed."
] // end target_changegravity



	// TEAM ENTITIES //

// Apparently team_control_point inherits a whole lotta dynamic model keyvalues/inputs/outputs that valve has been holding back from us
@BaseClass = team_control_point_keys_1 [
	point_printname(choices) : "Print Name" : "#koth_viaduct_cap" : "Control point name to print on the HUD. This can either be raw text or a localized string. A selection of applicable, generic, localized strings is provided (in English, sorted by usefulness), but any localized or raw string can be typed. When manually typing a localized string, type the name prefixed by a pound sign (#)." = [
		// General-purpose labels on top, specific place labels below
		//TODO-BROKK: Update these and sort them anew
		"#Arena_cap" : "the Control Point (ARENA)"
		"#CP_cap_cp3" : "the Central Control Point (CP)"
		"#CP_cap_red_cp1" : "the RED Base (CP)"
		"#CP_cap_blue_cp1" : "the BLU Base (CP)"
		"#Badwater_cap_1" : "First Capture point (Badwater)"
		"#Badwater_cap_2" : "Second Capture point (Badwater)"
		"#Badwater_cap_3" : "Third Capture point (Badwater)"
		"#Badwater_cap_4" : "Final Capture point (Badwater)"
		"#Dustbowl_cap_1_A" : "First Cap, Stage One (Dustbowl)"
		"#Dustbowl_cap_1_B" : "Second Cap, Stage One (Dustbowl)"
		"#Dustbowl_cap_2_A" : "First Cap, Stage Two (Dustbowl)"
		"#Dustbowl_cap_2_B" : "Second Cap, Stage Two (Dustbowl)"
		"#Dustbowl_cap_3_A" : "First Cap, Stage Three (Dustbowl)"
		"#Dustbowl_cap_3_B" : "the Rocket, Final Cap (Dustbowl)"
		"#Goldrush_cap_1_A" : "First Cap, Stage One (Goldrush)"
		"#Goldrush_cap_1_B" : "Second Cap, Stage One (Goldrush)"
		"#Goldrush_cap_2_A" : "First Cap, Stage Two (Goldrush)"
		"#Goldrush_cap_2_B" : "Second Cap, Stage Two (Goldrush)"
		"#Goldrush_cap_3_A" : "First Cap, Stage Three (Goldrush)"
		"#Goldrush_cap_3_B" : "Second Cap, Stage Three (Goldrush)"
		"#Goldrush_cap_3_C" : "Atomic pit, Final Cap (Goldrush)"
		"#Pipeline_cap_1_red" : "Red's first Capture point (Pipeline)"
		"#Pipeline_cap_1_blue" : "Blue's first Capture point (Pipeline)"
		"#Pipeline_cap_2_red" : "Red's second Capture point (Pipeline)"
		"#Pipeline_cap_2_blue" : "Blue's second Capture point (Pipeline)"
		"#Pipeline_cap_3_red" : "Red's final capture point (Pipeline)"
		"#Pipeline_cap_3_blue" : "Blue's final capture point (Pipeline)"
		"#Gravelpit_cap_A" : "cap A, the Radio Tower (Gravelpit)"
		"#Gravelpit_cap_B" : "cap B, the Radar (Gravelpit)"
		"#Gravelpit_cap_C" : "cap C, the Laser Gun (Gravelpit)"
		"#pl_hoodoo_final_cp_a2" : "Capture Point A 2 (Hoodoo)"
		"#pl_hoodoo_final_cp_b1" : "Capture Point B 1 (Hoodoo)"
		"#pl_hoodoo_final_cp_b2" : "Capture Point B 2 (Hoodoo)"
		"#pl_hoodoo_final_cp_c1" : "Capture Point C 1 (Hoodoo)"
		"#pl_hoodoo_final_cp_c2" : "Capture Point C 2 (Hoodoo)"
		"#pl_hoodoo_final_cp_a1" : "Capture Point A 1 (Hoodoo)"
		"#cp_vanguard_red_forward" : "the RED Forward Point (Vanguard)"
		"#cp_vanguard_blu_forward" : "the BLU Forward Point (Vanguard)"
	] // end point_printname
	point_index(integer) : "Index" : 0 : "The index of this point. This value can be anything, but must be unique to this point."
	point_group(integer) : "Group Index" : 0 : "Used for grouping points together under a team_control_point_master (not using control point rounds)."
	point_default_owner(choices) : "Default Owner" : 0 : "Which team should own the point when the round starts." = [
		0 : "Neither"
		2 : "Red"
		3 : "Blue"
	] // end point_default_owner
	random_owner_on_restart(choices) : "Random Owner?" : 0 : "If Yes, randomly set the owner of this point during a full restart of the map. The ratio of default owners among the points with this flag will be kept when selecting random owners."  = [
		0 : "No"
		1 : "Yes"
	] // end random_owner_on_restart
	point_start_locked(choices) : "Start Locked?" : 0 : "Locked means the point will not be available for capture until it is unlocked via input." = [
		0 : "No"
		1 : "Yes"
	] // end point_start_locked
	team_previouspoint_2_0(target_destination) : "RED Previous Required Point" :  : "The name of a previous capture point that RED must own to be able to capture this point. If empty, the team must own all points preceding this one. Pointing to itself means no previous point required."
	team_previouspoint_2_1(target_destination) : "RED Previous Required Point" :  : "The name of a second previous capture point that RED must own to be able to capture this point."
	team_previouspoint_2_2(target_destination) : "RED Previous Required Point" :  : "The name of a third previous capture point that RED must own to be able to capture this point."
	team_timedpoints_2(integer) : "RED Time-Based Point Value" : 0 : "Time-based point value for RED."
	team_previouspoint_3_0(target_destination) : "BLUE Previous Required Point" :  : "The name of a previous capture point that BLUE must own to be able to capture this point. If empty, the team must own all points preceding this one. Pointing to itself means no previous point required."
	team_previouspoint_3_1(target_destination) : "BLUE Previous Required Point" :  : "The name of a second previous capture point that BLUE must own to be able to capture this point."
	team_previouspoint_3_2(target_destination) : "BLUE Previous Required Point" :  : "The name of a third previous capture point that BLUE must own to be able to capture this point."
	team_timedpoints_3(integer) : "BLUE Time-Based Point Value" : 0 : "Time-based point value for BLUE."
] // end team_control_point_keys_1
@BaseClass = team_control_point_keys_2 [
	team_model_0(studio) : "Neutral Model" : "models/effects/cappoint_hologram.mdl" : "Model displayed when the point is not owned by either team. While neutral, this entity will attempt to use bodygroup 0 and skin 2 on this model. The bodygroup and skin can be overridden with inputs. Automatic bodygroup switching does not work with all models, although this can be fixed by manually sending the SetBodyGroup input."
	//team_bodygroup_0(integer) : "Neutral Model Bodygroup" : 3 : "Bodygroup when point is not owned by either team." // Uhh, on the default CP model, neutral bodygroup is 0. 3 is blu, 2 is red, 1 is nothing. These values have been (seemingly) incorrect in every CP map ever made... And yet they all work!?!? WHAT THE FUCK VALVE WHO GAVE THE CRACKHEAD PERMISSION TO CODE THIS GAME
	// Changing the bodygroup keyvalues doesn't seem to affect anything...
	// Also when I use a soldier model, THE BODYGROUP DOESN'T CHANGE AT ALL? WHAT IS THIS INSANITY AAAAA
	// Entity also changes skin based on team ownership: Neutral = 2, Red = 0, Blue = 1. Is this configurable?
	// After looking at code, it appears these keyvalues aren't actually used to set the bodygroup? Bodygroup is equivalent to owning team number
	// Skin is set using this line of code: m_nSkin = ( m_iTeam == TEAM_UNASSIGNED ) ? 2 : (m_iTeam - 2);
	// (Why isn't it just the team number like Bodygroup? :shrug:)
	// This lines up with the previous note about skin changes, doesn't seem configurable sadly
	team_icon_0(material) : "Neutral HUD Icon" : "sprites/obj_icons/icon_obj_neutral" : "HUD icon material when no one owns the point."
	team_overlay_0(material) : "Neutral HUD Overlay" :  : "HUD material that will overlay the icon when no one owns the point."
	team_model_2(studio) : "RED Model" : "models/effects/cappoint_hologram.mdl" : "Model displayed when the RED owns the point. While owned by RED, this entity will attempt to use bodygroup 2 and skin 0 on this model. The bodygroup and skin can be overridden with inputs. Automatic bodygroup switching does not work with all models, although this can be fixed by manually sending the SetBodyGroup input."
	//team_bodygroup_2(integer) : "RED Model Bodygroup" : 1 : "Bodygroup used when RED owns the point."
	team_icon_2(material) : "RED HUD Icon" : "sprites/obj_icons/icon_obj_red" : "HUD icon material when RED owns the point."
	team_overlay_2(material) : "RED HUD Overlay" :  : "HUD material that will overlay the icon when RED owns the point."
	team_model_3(studio) : "BLUE Model" : "models/effects/cappoint_hologram.mdl" : "Model displayed when the BLUE owns the point. While owned by BLU, this entity will attempt to use bodygroup 3 and skin 1 on this model. The bodygroup and skin can be overridden with inputs. Automatic bodygroup switching does not work with all models, although this can be fixed by manually sending the SetBodyGroup input."
	//team_bodygroup_3(integer) : "BLUE Model Bodygroup" : 1 : "Bodygroup used when BLUE owns the point."
	team_icon_3(material) : "BLUE HUD Icon" : "sprites/obj_icons/icon_obj_blu" : "HUD icon material when BLUE owns the point."
	team_overlay_3(material) : "BLUE HUD Overlay" :  : "HUD material that will overlay the icon when BLUE owns the point."
] // end team_control_point_keys_2
@BaseClass = team_control_point_keys_3 [
	point_warn_on_cap(choices) : "Warning Type" : 0 : "Type of warning to issue to the team that owns the control point when the opposing team starts to capture it." = [
		0 : "Normal Announcements"
		1 : "Final Capture Point Warning"
		2 : "No Announcements"
	] // end point_warn_on_cap
	point_warn_sound(sound) : "Warning Sound" : "ControlPoint.CaptureWarn" : "Sound to be played when this point is being captured (if warn on capture is set)."
	// TODO: What are the default sounds for these events?
	point_capture_start_sound(sound) : "Start Capture Sound" :  : "The sound to play when the point starts being captured."
	point_capture_end_sound(sound) : "End Capture Sound" :  : "The sound to play when the point ends being captured."
	point_capture_progress_sound(sound) : "Capture Progress Sound" :  : "The sound to play when the point is progressing towards capture."
	point_capture_interrupted_sound(sound) : "Capture Interrupted Sound" :  : "The sound to play when the point's capture is interrupted."
	team_capsound_0(sound) : "Reset Sound" :  : "Sound made when point resets."
	team_capsound_2(sound) : "Red Capture Sound" :  : "Sound made when RED captures."
	team_capsound_3(sound) : "Blue Capture Sound" :  : "Sound made when BLUE captures."
] // end team_control_point_keys_3
@PointClass base(SBaseEntity, SBaseDiv, team_control_point_keys_1, SClassDiv1, team_control_point_keys_2, SCollisions, SClassDiv2, team_control_point_keys_3, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/effects/cappoint_hologram.mdl") = team_control_point : "Designates the location of a capture point; use in conjunction with trigger_capture_area. There is a maximum of 8 control points per map." [
	solid(choices) : "Collisions" : 0 : "Method of collision for this entity. Players can sometimes get stuck on Oriented Bounding Box." = [
		0 : "Non-solid" // prop_static, prop_dynamic: Nonsolid (expected)
		//1 : "BSP (QPhysics)" // prop_static, prop_dynamic: Nonsolid
		6 : "VPhysics (collision mesh)" // prop_static, prop_dynamic: Collide with collision mesh
		2 : "Bounding Box (grid-aligned)" // prop_static: Collide with grid-aligned bounding box (expected); prop_dynamic: Collide with unrotated bounding box
		3 : "Oriented Bounding Box" // prop_static: Nonsolid; prop_dynamic: Collide with oriented bounding box, sometimes gets stuck
		//4 : "Oriented Bounding Box, constrained to Yaw only"// prop_static, prop_dynamic: Nonsolid
		//5 : "Custom (defined per-entity, if not defined the entity will have bizarre collision behavior)" // prop_static, prop_dynamic: Nonsolid
	] // end solid
	disableshadows(choices) : "Disable Shadows?" : 0 : "Prevent the entity from casting cheap render-to-texture shadows. Functions identically to the spawnflag of the same name." = [
		0 : "No"
		1 : "Yes"
	] // end disableshadows

	spawnflags(flags) = [
		1 : "Hide Control Point on HUD" : 0
		2 : "Start with Model Hidden" : 0
		4 : "Disable Shadows" : 1
		8 : "Disable Sounds" : 0
		//16 : "Bots Ignore This Point" : 0 // TODO: Previously unknown point? Test it. Defined in team_control_point.h as #define SF_CAP_POINT_BOTS_IGNORE	(1<<4)
	] // end spawnflags

	input HideModel(void) : "Hide the control point model."
	//input RoundActivate(void) : "Forces this entity to activate. Fired automatically at the start of a round."
	input SetLocked(bool) : "Lock the control point. 0 = unlocked, 1 = locked"
	input SetOwner(integer) : "Set the owner of the point. 0 = Neutral (no owner), 2 = RED, 3 = BLU. If the !caller is a player, capture-related sounds and voicelines will play and the player will be credited for the capture. If the !caller does not exist at all, or the map is currently in setup or humiliation period, this input is ignored."
	input SetUnlockTime(integer) : "This will automatically unlock the control point in the specified amound of time (seconds)."
	input ShowModel(void) : "Show the control point model."

	output OnCapReset(void) : "Sent when owner is changed to neutral."
	output OnCapTeam1(void) : "Sent when the owner is changed to Red team."
	output OnCapTeam2(void) : "Sent when the owner is changed to Blu team."
	output OnOwnerChangedToTeam1(void) : "Sent when a player on the Red team captures the point."
	output OnOwnerChangedToTeam2(void) : "Sent when a player on the Blu team captures the point."
	output OnRoundStartOwnedByTeam1(void) : "Sent when a round is starting and the point is owned by RED."
	output OnRoundStartOwnedByTeam2(void) : "Sent when a round is starting and the point is owned by BLUE."
	output OnUnlocked(void) : "Sent when point unlocks."
] // end team_control_point

@BaseClass = team_control_point_master_keys_1 [
	cpm_restrict_team_cap_win(choices) : "Restrict team from winning" : 0 : "Prevent this team from winning by capping all the points. This field is ignored if you're using control_point_rounds in your map (set this field inside the rounds)." = [
		0 : "Neither"
		1 : "Both"
		2 : "Red"
		3 : "Blue"
	] // end cpm_restrict_team_cap_win
	switch_teams(choices) : "Switch teams on map win?" : 0 : "Switch the teams when one team has won the map and the game is going to be reset." = [
		0 : "No"
		1 : "Yes"
	] // end switch_teams
	score_style(choices) : "Scoring style" : 0 : "Sets the style of scoring used for capture point maps." = [
		0 : "Add team score for each round won"
		1 : "Add team score for each captured point"
	] // end score_style
	play_all_rounds(choices) : "Play all rounds before changelevel?" : 0 : "Determines whether the server may changelevel when mp_timelimit is up before all mini-rounds have been completed (for maps like Dustbowl)." = [
		0 : "Changelevel normally"
		1 : "Only changelevel after all mini-rounds have been completed"
	] // end play_all_rounds
	partial_cap_points_rate(float) : "Partial cap rate" : 0 : "Rate at which to give partial cap points for area captures."
] // end team_control_point_master_keys_1
@PointClass base(SBaseLogical, SBaseDiv, SEnableDisable, team_control_point_master_keys_1, SClassDiv1) color(100 150 255) iconsprite("editor-abs/team_control_point_master") = team_control_point_master : "This entity controls all the control points in a map. It is responsible for the layout of the HUD icons as well as some round specific settings. team_control_point_round entities will override settings if they are used." [
	caplayout(string) : "Cap Layout" :  : "A string that tells the HUD how to lay out the cap points. It should be a string with indexes of cap points seperated by commas to denote a new line. So <2,0 1> would create a pyramid, with cap point 2 on the top and cap points 0 & 1 on the bottom."
	custom_position_x(float) : "Custom cap position X" : -1 : "Set the cap layout custom X position [0,1]"
	custom_position_y(float) : "Custom cap position Y" : -1 : "Set the cap layout custom Y position [0,1]"
	team_base_icon_2(material) : "Material for the RED Base icon" : "sprites/obj_icons/icon_base_red"
	team_base_icon_3(material) : "Material for the BLUE Base icon" : "sprites/obj_icons/icon_base_blu"

	input SetCapLayout(string) : "Set the cap layout string. BUG: Commas cannot be used here, as commas are used in the VMF file format as a delimiter between various output fields."
	input SetCapLayoutCustomPositionX(float) : "Set the cap layout custom X position [0,1]"
	input SetCapLayoutCustomPositionY(float) : "Set the cap layout custom Y position [0,1]"
	input SetWinner(integer) : "Set the winner of the round to this team (0 for a stalemate)."
	input SetWinnerAndForceCaps(integer) : "Set the winner of the round to this team and give them ownership of all points."
	//input RoundSpawn(void) : "Forces this entity to spawn. Fired automatically at the start of a round."
	//input RoundActivate(void) : "Forces this entity to activate. Fired automatically at the start of a round."

	output OnWonByTeam1(void) : "Sent when RED wins the game."
	output OnWonByTeam2(void) : "Sent when BLUE wins the game."
] // end team_control_point_master

@PointClass base(SBaseLogical, SBaseDiv, SEnableDisable) color(100 150 255) iconsprite("editor-abs/team_control_point_round") = team_control_point_round : "Control Point Round (you may have as many of these in the map as you would like)." [
	cpr_printname(string) : "Print Name" :  : "LOCALIZED name to print on the RoundInfo panel."
	cpr_priority(integer) : "Priority" : 0 : "The priority value for this round (must be >= 0). Higher priority rounds will be picked first. If multiple rounds have the same priority value, a random selection will be used."
	cpr_cp_names(string) : "Control points in this round" :  : "Names of the control points included in this round (space delimited). Control points may belong to more than one control point round. The names of the control points (and the rounds) should all be unique."
	cpr_restrict_team_cap_win(choices) : "Restrict team from winning" : 0 : "Prevent this team from winning by capping all the points" = [
		0 : "Neither"
		1 : "Both"
		2 : "Red"
		3 : "Blue"
	] // end cpr_restrict_team_cap_win

	//input RoundSpawn(void) : "Forces this entity to spawn. Fired automatically at the start of a round."

	output OnEnd(void) : "Sent when this round is finished."
	output OnStart(void) : "Sent when this round is selected to be played."
	output OnWonByTeam1(void) : "Sent when RED wins this round."
	output OnWonByTeam2(void) : "Sent when BLUE wins this round."
] // end team_control_point_round

// TODO: Does it always start paused or is this just referring to the keyvalue's default value?
// TODO: TeamNum keyvalue and RoundSpawn input?
@PointClass base(SBaseLogical, SBaseDiv, SEnableDisable) color(100 150 255) iconsprite("editor-abs/team_round_timer") = team_round_timer : "Round timer. Timer starts paused by default. The timer does not end the round on its own. You need a separate win condition such as the game_round_win entity." [
	timer_length(integer) : "Timer Length (in seconds)" : 600 : "Initial timer length."
	max_length(integer) : "Max Timer Length (in seconds)" : 0 : "Maximum timer length (0 = no max). This value is used to ensure the timer never goes above this value when SetTime and AddTime are used."
	setup_length(integer) : "Setup Timer Length (in seconds)" : 0 : "Length of setup time before the round begins and the timer starts to countdown the normal time. (0 = no setup time)  Setup time is run at the beginning of every round before the normal time begins."
	show_time_remaining(choices) : "Count Direction" : 1 : "Use this to reverse the timer and have it count from 0 up to the timer length. Sounds and outputs still fire like normal. For example, on a count-up timer with a length of 90 seconds, when it reaches 60 the announcer will say '30 seconds remanining', however, the On30SecRemaining output will fire when the visual timer reaches 61." = [
		0 : "Up"
		1 : "Down"
	] // end show_time_remaining
	start_paused(choices) : "Start Paused?" : 1 : "Should the timer start paused? (will need to send a Resume input to start the timer if this is set)." = [
		0 : "No"
		1 : "Yes"
	] // end start_paused
	reset_time(choices) : "Reset Time on Round Restart?" : 0 : "Reset the timer time after a round restart. This is not the setup time, but the normal round time." = [
		0 : "No"
		1 : "Yes"
	] // end reset_time
	auto_countdown(choices) : "Use Countdown Sounds?" : 1 : "Let the timer automatically count down the end of a round." = [
		0 : "No"
		1 : "Yes"
	] // end auto_countdown
	show_in_hud(choices) : "Show Timer in the HUD?" : 1 : "Note: You can only show one timer in the HUD at a time. To have two timers displayed at once, use a tf_logic_koth and use inputs to override the settings of zz_red_koth_timer and zz_blue_koth_timer." = [
		0 : "No"
		1 : "Yes"
	] // end show_in_hud

	input AddTeamTime(string) : "Input takes a string (space delimited) with the team number and the time to be added (in seconds) because of the team (2 for red, 3 for blue, and 0 for no team...but you could just use AddTime for that). Added time cannot excede the max timer length. Example: 2 600 (adds 10 minutes because of team red)"
	input AddTime(integer) : "Add time to the timer (in seconds). Added time cannot excede the max timer length."
	input AutoCountdown(bool) : "Turn off/on the auto-countdown feature (0 no, 1 yes)." // TODO: What is this?
	input Pause(void) : "Pause the timer."
	input Restart(void) : "Restart the timer."
	input Resume(void) : "Resume the timer."
	//input RoundSpawn(void) : "Forces this entity to spawn. Fired automatically at the start of a round."
	input SetMaxTime(integer) : "Set the max timer length to this value (in seconds). The timer's time will never excede this value."
	input SetSetupTime(integer) : "Set the setup time length to this value (in seconds)."
	input SetTime(integer) : "Set the timer to this value (in seconds)."
	input ShowInHUD(bool) : "Show this timer in the HUD (0 no, 1 yes)."

	output OnFinished(void) : "Sent when the timer is finished, unless overtime is triggered."
	output OnRoundStart(void) : "Sent when the round starts."
	output OnSetupFinished(void) : "Sent when the setup time is finished."
	output OnSetupStart(void) : "Sent when the setup time begins."
	output On5MinRemain(void) : "Sent when 5 minutes remain."
	output On4MinRemain(void) : "Sent when 4 minutes remain."
	output On3MinRemain(void) : "Sent when 3 minutes remain."
	output On2MinRemain(void) : "Sent when 2 minutes remain."
	output On1MinRemain(void) : "Sent when 1 minutes remain."
	output On30SecRemain(void) : "Sent when 30 seconds remain."
	output On10SecRemain(void) : "Sent when 10 seconds remain."
	output On5SecRemain(void) : "Sent when 5 seconds remain."
	output On4SecRemain(void) : "Sent when 4 seconds remain."
	output On3SecRemain(void) : "Sent when 3 seconds remain."
	output On2SecRemain(void) : "Sent when 2 seconds remain."
	output On1SecRemain(void) : "Sent when 1 second remains."
] // end team_round_timer

@BaseClass = team_train_watcher_keys_1 [
	train(target_destination) : "Train to Watch" :  : "Name of the func_tracktrain that this entity will monitor."
	handle_train_movement(choices) : "Handle Train Movement?" : 0 : "If Yes, the watcher will handle three-speed forward movement, receding, and roll forward/back zones. Slow areas (such as for uphill) will need to be done manually by sending the watcher a SetSpeedForwardModifier input." = [
		0 : "No"
		1 : "Yes"
	] // end handle_train_movement
	speed_forward_modifier(float) : "Default Speed Modifier" : 1 : "0 to 1 scaling of the train's movement speed. Can be adjusted with the SetSpeedForwardModifier input. Only functions with Handle Train Movement enabled."
	hud_min_speed_level_1(float) : "Min Speed for Speed Level 1" : 1 : ""
	hud_min_speed_level_2(float) : "Min Speed for Speed Level 2" : 60 : ""
	hud_min_speed_level_3(float) : "Min Speed for Speed Level 3" : 80 : ""
	env_spark_name(target_destination) : "Associated env_spark" : : "Name of the env_spark to turn on when the cart is receding. Only functions with Handle Train Movement enabled."
	train_can_recede(choices) : "Allow the train to recede?" : 1 : "" = [
		0 : "No"
		1 : "Yes"
	] // end train_can_recede
	train_recede_time(integer) : "Train Recede Time" : 0 : "Length of time, in seconds, before the train begins to recede. 0 = use the TF2 default setting of 30 seconds."
] // end team_train_watcher_keys_1
@PointClass base(SBaseLogical, SBaseDiv, SEnableDisable, STFTeam, team_train_watcher_keys_1, SClassDiv1) color(100 150 255) iconsprite("editor-abs/team_train_watcher") = team_train_watcher : "Entity that tracks the train progress through train escort maps. Adding this entity to a map makes Team Fortress 2 classify the map as a payload map." [
	start_node(target_destination) : "Starting Node" :  : "The first path_track node in the train's path."
	linked_cp_1(target_destination) : "Capture Point 1" :  : "The first team_control_point on the train's path."
	linked_pathtrack_1(target_destination) : "CP 1 path_track" :  : "The path_track node on the train's path that is associated with the first capture point."
	linked_cp_2(target_destination) : "Capture Point 2" :  : "The second team_control_point on the train's path."
	linked_pathtrack_2(target_destination) : "CP 2 path_track" :  : "The path_track node on the train's path that is associated with the second capture point."
	linked_cp_3(target_destination) : "Capture Point 3" :  : "The third team_control_point on the train's path."
	linked_pathtrack_3(target_destination) : "CP 3 path_track" :  : "The path_track node on the train's path that is associated with the third capture point."
	linked_cp_4(target_destination) : "Capture Point 4" :  : "The fourth team_control_point on the train's path."
	linked_pathtrack_4(target_destination) : "CP 4 path_track" :  : "The path_track node on the train's path that is associated with the fourth capture point."
	linked_cp_5(target_destination) : "Capture Point 5" :  : "The fifth team_control_point on the train's path."
	linked_pathtrack_5(target_destination) : "CP 5 path_track" :  : "The path_track node on the train's path that is associated with the fifth capture point."
	linked_cp_6(target_destination) : "Capture Point 6" :  : "The sixth team_control_point on the train's path."
	linked_pathtrack_6(target_destination) : "CP 6 path_track" :  : "The path_track node on the train's path that is associated with the sixth capture point."
	linked_cp_7(target_destination) : "Capture Point 7" :  : "The seventh team_control_point on the train's path."
	linked_pathtrack_7(target_destination) : "CP 7 path_track" :  : "The path_track node on the train's path that is associated with the seventh capture point."
	linked_cp_8(target_destination) : "Capture Point 8" :  : "The eighth team_control_point on the train's path."
	linked_pathtrack_8(target_destination) : "CP 8 path_track" :  : "The path_track node on the train's path that is associated with the eighth capture point."
	goal_node(target_destination) : "Ending Node" :  : "The last path_track node in the train's path."

	//input RoundActivate(void) : "Forces this entity to activate. Fired automatically at the start of a round."
	input SetNumTrainCappers(integer) : "Set Number of players capping the train."
	input SetSpeedForwardModifier(float) : ""
	input SetTrainCanRecede(bool) : "Determines whether or not the train can recede."
	input SetTrainRecedeTime(integer) : "Set the number of seconds before the train starts to recede."
	input SetTrainRecedeTimeAndUpdate(integer) : "Set the number of seconds before the train starts to recede and update the current recede time."

	output OnTrainStartRecede(void) : "Sent when the train should start receding."
] // end team_train_watcher



	// TELEPORT ENTITIES //

@PointClass base(SBaseEntity) iconsprite("editor-ficool2/teleport_vortex") = teleport_vortex : "The entity created by MONOCULUS upon teleporting away around the map for 5 seconds. Upon touching, the player will teleport to a random info_target named spawn_purgatory. No particles are created. Also, the vortex will spawn instantly upon map load, therefore a point_template is recommended." [
] // end teleport_vortex



	// TEST ENTITIES //

@PointClass base(SBaseEntity) iconsprite("editor-ficool2/test_effect") = test_effect : "Creates rays inside a small sphere shape for 5 seconds. Requires an 'Use' input. Repeatable." [
] // end test_effect

@PointClass base(SBaseEntity) iconsprite("editor-ficool2/test_traceline") = test_traceline : "An entity used for debugging tracelines. Fires a white line upwards, which rotates 90 degrees down gradually, stops, and then rotates 90 degrees up gradually and so on. Creates a tiny green box at its origin, which becomes red if the entity is unable to fire the trace its line." [
] // end test_traceline



	// TF ENTITIES //

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/tf_base_minigame")  = tf_base_minigame : "An entity which manages a basic minigame." [
	InRandomPool(choices) : "Put in Random Pool?" : 1 : "If Yes, allowed to be chosen when told to go to a random minigame." = [
		0 : "No"
		1 : "Yes"
	] // InRandomPool
	RedSpawn(target_destination) : "Red Spawn Name" :  : "The name of the spawnpoints for RED for this minigame."
	BlueSpawn(target_destination) : "Blue Spawn Name" :  : "The name of the spawnpoints for BLUE for this minigame."
	hud_res_file(string) : "HUD .res File" :  : ".res file to use for this minigame."
	your_team_score_sound(sound) : "Your Team Score Sound" :  : "Sound file to play when your team scores a point."
	enemy_team_score_sound(sound) : "Enemy Team Score Sound" :  : "Sound file to play when the enemy team scores a point."
	ScoreType(choices) : "Scoring Type" : 0 : "What to use for scoring?" = [
		0 : "Points"
		1 : "Players alive"
	] // end ScoreType
	MaxScore(integer) : "Max Score" : 5 : "When a team hits this score, the On<Team>HitMaxScore output will be fired."
	SuddenDeathTime(float) : "Sudden Death Time" : -1 : "Time until sudden death starts."

	input ChangeHudResFile(string) : "Change the HUD resource file."
	input ReturnFromMinigame(void) : "Force players to return from the current minigame."
	input ScoreTeamRed(integer) : "Give points to team RED."
	input ScoreTeamBlue(integer) : "Give points to team BLUE."

	output OnAllRedDead(void) : "Sent when the entire RED team is dead."
	output OnAllBlueDead(void) : "Send when the entire BLUE team is dead."
	output OnBlueHitMaxScore(void) : "Sent BLUE hits the max score for this minigame."
	output OnRedHitMaxScore(void) : "Sent RED hits the max score for this minigame."
	output OnReturnFromMinigame(void) : "Sent when players return from this minigame."
	output OnSuddenDeathStart(void) : "Sent when sudden death starts."
	output OnTeleportToMinigame(void) : "Sent when players arrive in this minigame."
] // end tf_base_minigame

@PointClass base(tf_base_minigame) color(100 150 255) iconsprite("editor-ficool2/tf_halloween_minigame") = tf_halloween_minigame : "Halloween 2014 Minigame."[
	MinigameType(choices) : "Minigame Type" : 1 : "Which minigame is this?" = [
		1 : "Halloween Collection"
		2 : "Halloween Platforms"
		3 : "Halloween Soccer"
	] // end MinigameType

	input KartLoseAnimationBlue(void) : "Play lose animation for all players in kart on team BLUE."
	input KartLoseAnimationRed(void) : "Play lose animation for all players in kart on team RED."
	input KartWinAnimationBlue(void) : "Play win animation for all players in kart on team BLUE."
	input KartWinAnimationRed(void) : "Play win animation for all players in kart on team RED."

	input DisableSpawnBoss(void) : "Stop spawning the Halloween boss."
	input EnableSpawnBoss(string) : "Spawn the Halloween boss HHH at specified target entity."
] // end tf_halloween_minigame

// TODO: Force MinigameType 2 in this entity?
@PointClass base(tf_halloween_minigame) color(100 150 255) iconsprite("editor-ficool2/tf_halloween_minigame_falling_platforms") = tf_halloween_minigame_falling_platforms : "Halloween 2014 Falling Platform Minigame." [
	input ChoosePlatform(void) : "Fire to get the next SAFE platform and the next platform that will not come back."

	output OutputSafePlatform(integer) : "Sends the index of the SAFE platform."
	output OutputRemovePlatform(integer) : "Sends the index of the platform that shouldn't come back."
] // end tf_halloween_minigame_falling_platforms

// TODO: Test
@BaseClass = tf_bonus_duck_pickup_keys [
	pickup_sound(sound) : "Sound Effect" :  : "The sound script entry that is played when the item is picked up."
	pickup_particle(string) : "Particle Effect" :  : "The particle effect that is displayed when the item is picked up."
] // end tf_bonus_duck_pickup_keys
@PointClass base(SBaseEntity, SBaseItem, tf_bonus_duck_pickup_keys, SBaseDynamicModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/workshop/player/items/pyro/eotl_ducky/eotl_bonus_duck.mdl") = tf_bonus_duck_pickup : "EOTL Bonus Ducks." [
	output OnBluePickup(void) : "Sent when BLU picks-up the item."
	output OnRedPickup(void) : "Sent when RED picks-up the item."
] // end tf_bonus_duck_pickup

@PointClass base(tf_bonus_duck_pickup) color(200 200 200) studioprop("models/props_halloween/halloween_gift.mdl") = tf_halloween_pickup : "The Halloween Gift pickup." [
] // end tf_halloween_pickup

@PointClass base(SPreservedEntity, tf_bonus_duck_pickup) color(200 200 200) studioprop("models/props_halloween/halloween_gift.mdl") = tf_halloween_gift_pickup : "The Halloween Gift pickup." [
] // end tf_halloween_gift_pickup

@PointClass base(SPreservedEntity, SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-abs/tf_gamerules") = tf_gamerules : "Proxy entity for Team Fortress 2 game rules." [
	// TODO: What does this do in code?
	hud_type(choices) : "Hud Type" : 0 : "Override the HUD type clients should display." = [
		0 : "Default"
		1 : "CTF HUD"
		2 : "CP HUD"
		3 : "Payload HUD"
	] // end hud_type
	ctf_overtime(choices) : "CTF Overtime?" : 1 : "Allow Overtime for CTF maps?" = [
		0 : "No"
		1 : "Yes"
	] // end ctf_overtime

	// TODO: Missing input SetRoundRespawnFreezeEnabled?
	input SetRedTeamRespawnWaveTime(float) : "Set the RED team's respawn wave time."
	input SetBlueTeamRespawnWaveTime(float) : "Set the BLU team's respawn wave time."
	input AddRedTeamRespawnWaveTime(float) : "Add to the RED team's respawn wave time."
	input AddBlueTeamRespawnWaveTime(float) : "Add to the BLU team's respawn wave time."
	input SetRedTeamGoalString(string) : "Set the RED team's goal string to show in the hud."
	input SetBlueTeamGoalString(string) : "Set the BLU team's goal string to show in the hud."
	input SetRedTeamRole(integer) : "Set RED team role. 0=none, 1=defenders, 2=attackers."
	input SetBlueTeamRole(integer) : "Set BLU team role. 0=none, 1=defenders, 2=attackers."
	input SetRequiredObserverTarget(string) : "Sets the given entity (by name) to be the required observer target for all spectators. Must be cleared to allow spectators to cycle through targets normally again."
	input AddRedTeamScore(integer) : "Add to the RED team score (can be a negative number)."
	input AddBlueTeamScore(integer) : "Add to the BLU team score (can be a negative number)."
	input SetStalemateOnTimelimit(bool) : "Determines whether mp_timelimit can end the match in the middle of a round."
	input SetRedKothClockActive(void) : "Set the RED team clock active for KOTH maps."
	input SetBlueKothClockActive(void) : "Set the BLU team clock active for KOTH maps."
	input SetCTFCaptureBonusTime(float) : "Set the length (in seconds) of team crit time for CTF captures. 0 = none."
	input PlayVORed(string) : "Play the given sound entry via the VO channel."
	input PlayVOBlue(string) : "Play the given sound entry via the VO channel."
	input PlayVO(string) : "Play the given sound entry via the VO channel."
	input HandleMapEvent(string) : "Handles map events. These events are hardcoded to only work on specific maps."
	input SetCustomUpgradesFile(string) : "Specifies the path relative to the game directory to the upgrades file to be used."
	input SetRoundRespawnFreezeEnabled(integer) : "Enable/disable the player movement freeze period after a round begins."
	input SetMapForcedTruceDuringBossFight(bool) : "Enable/disable truce between the teams during a fight with Monoculus or Merasmus."

	output OnWonByTeam1(void) : "Sent when RED wins the round."
	output OnWonByTeam2(void) : "Sent when BLUE wins the round."
	output Team1PlayersChanged(integer) : "Sent when RED team player count changes, due to a player joining or leaving the team."
	output Team2PlayersChanged(integer) : "Sent when BLUE team player count changes, due to a player joining or leaving the team."
	output OnPowerupImbalanceTeam1(void) : "Sent when BLUE team has a powerup kill advantage over the RED team. Initiate RED team assist measures now."
	output OnPowerupImbalanceTeam2(void) : "Sent when RED team has a powerup kill advantage over the BLUE team. Initiate BLUE team assist measures now."
	output OnPowerupImbalanceMeasuresOver(void) : "Sent when powerup imbalance measures should be stopped."
	output OnStateEnterBetweenRounds(void) : "Fired when entering the between-rounds state (MvM and Competitive)."
	output OnStateEnterPreRound(void) : "Fired when entering the pre-round state (just before round running)."
	output OnStateExitPreRound(void) : "Fired when exiting the pre-round state (just before round running)."
	output OnStateEnterRoundRunning(void) : "Fired when entering the round-running state."
	output OnMatchSummaryStart(void) : "Fired when the match summary begins and players are spawned on stage."
	output OnTruceStart(void) : "Sent when a truce starts."
	output OnTruceEnd(void) : "Sent when a truce ends."
] // end tf_gamerules

@BaseClass = tf_generic_bomb_keys [
	damage(float) : "Explosion Damage" : 50 : "Amount of damage to do when exploding."
	radius(float) : "Explosion Radius" : 100 : "Radius of the blast within which damage will be dealt."
	explode_particle(string) : "Explosion Particle" :  : "Name of the particle effect to play when exploding."
	sound(sound) : "Explosion Sound" :  : "Name of the sound effect to play when exploding."
	friendlyfire(choices) : "Friendly Fire?" : 0 : "Set whether this bomb should damage allies of the attacker." = [
		0 : "No (Damage attacker and enemies)"
		1 : "Yes (Damage everyone)"
	] // end friendlyfire
] // end tf_generic_bomb_keys
@PointClass base(SModel, SBaseEntity, SBaseDiv, SModelSkin, SModelBodyGroup, SHealth, tf_generic_bomb_keys, SBaseDynamicModel) sphere(radius) sphere(fademindist) sphere(fademaxdist) studioprop() = tf_generic_bomb : "An explosive hazard. Identical to tf_pumpkin_bomb, but more customizable. Removes itself from the map after exploding." [
	health(integer) : "Bomb Health" : 1 : "How much damage the bomb must take to explode."

	input Detonate(void) : "Force detonation."

	output OnDetonate(void) : "Fired when this bomb detonates."
] // end tf_generic_bomb

@PointClass base(SBaseLogical, SBaseDiv, SEnableDisable) color(100 150 255) iconsprite("editor-ficool2/tf_glow") = tf_glow : "Applies a colored outline around a target entity which is visible through walls, similar to what is seen on intelligence carriers in CTF and on teammates after respawning." [
	target(target_destination) : "Target to Glow" :  : "Entity to outline. Only one can be assigned per tf_glow, and it cannot be changed even with AddOutput. Any children of the target entity will also be outlined (but not children of those children). Brush entities will not be outlined."
	GlowColor(color255) : "Glow Color" : "0 255 0 255" : "Glow color, with alpha. Format: <R> <G> <B> <A> 0-255"
	//Mode(choices) : "Visibility Mode" : 0 : "When the glow should be visible. Does not work at all." = [
		//0 : "Always"
		//1 : "Only when model is occluded"
		//2 : "Only when model is visible"
	//] // end Mode

	input SetGlowColor(color255) : "Set the glow color, with alpha. Format: <R> <G> <B> <A>, 0-255 for each"
] // end tf_glow

@PointClass base(SBaseEntity) color(200 200 200) studioprop("models\props_halloween\gargoyle_ghost.mdl") = tf_halloween_gift_spawn_location : "The Halloween Gift spawn locations." [
] // end tf_halloween_gift_spawn_location

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-abs/tf_logic_arena") = tf_logic_arena : "Handles arena logic and outputs." [
	CapEnableDelay(integer) : "Control Point Enable Time" : 60 : "Time (in seconds) before the control point unlocks."

	output OnArenaRoundStart(void) : "Sent when round begins."
	output OnCapEnabled(void) : "Sent when control point unlocks."
] // end tf_logic_arena

@PointClass base(SPreservedEntity, SBaseLogical, SBaseDiv, SEnableDisable) color(100 150 255) iconsprite("editor-ficool2/tf_logic_competitive") = tf_logic_competitive : "Logic specifically for competitive mode." [
	output OnSpawnRoomDoorsShouldLock(void) : "Game rules is saying that we should now disable (home) spawn door triggers."
	output OnSpawnRoomDoorsShouldUnlock(void) : "Game rules is saying that we should now enable (home) spawn door triggers."
] // end tf_logic_competitive

// Thanks 14bit! -Brokk
@PointClass  base(SPreservedEntity, SBaseLogical, SBaseDiv, SControlPoint) color(100 150 255) iconsprite("editor-abs/tf_logic_cp_timer") = tf_logic_cp_timer : "Runs a timeout timer for a control point. It adds itself to the HUD icon for the control point." [

	controlpoint(target_destination) : "Control Point" : : "The team_control_point associated with this timer."
	timer_length(integer) : "Timer length (in seconds)" : 60 : "Length of the timer that runs when the control point becomes available for capture."
	team_number(choices) : "Team" : 3 : "The team(s) allowed to attack the associated team_control_point. Setting this incorrectly (e.g. Setting this to Blue on a point only Red can capture) will cause unpredictable behavior." =
	[
		0 : "Any"
		2 : "Red"
		3 : "Blue"
	]

	output OnCountdownStart(void) : "Sent when the timer starts."
	output OnCountdown15SecRemain(void) : "Sent when 15 seconds remain."
	output OnCountdown10SecRemain(void) : "Sent when 10 seconds remain."
	output OnCountdown5SecRemain(void) : "Sent when 5 seconds remain."
	output OnCountdownEnd(void) : "Sent when the timer expires and the point is not being captured."
] // end tf_logic_cp_timer

//Would be neat if you could add these together like flags -Brokk
@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/tf_logic_holiday") = tf_logic_holiday : "Holiday Logic Entity. This is used to detect a holiday map." [ // TODO: What precise effects does this have?
    holiday_type(choices) : "Holiday" : 0 : "" = [
        0 : "None"
        1 : "Birthday"
        2 : "Halloween"
        3 : "Christmas"
        4 : "End of the Line"
        5 : "Community Update (Unused?)"
        6 : "Valentines Day"
        7 : "Meet the Pyro"
        8 : "Full Moon"
        9 : "Halloween or Full Moon"
        10 : "Halloween or Full Moon or Valentines Day"
        11 : "April Fools"
    ] // end holiday_type
	tauntInHell(choices) : "Taunt In Hell?" : 0 : "Should players taunt when teleported to Hell?" = [
		0 : "No"
		1 : "Yes"
	] // end tauntInHell
	// TODO: What does this affect?
	allowHaunting(choices) : "Allow Wheel of Doom Haunting?" : 0 : "Allow Wheel of Doom haunting." = [
		0 : "No"
		1 : "Yes"
	] // end allowHaunting

	input HalloweenSetUsingSpells(bool) : "Disable/Enable spells for this map. Only works on Halloween maps. (0 = disable, 1 = enable)"
	input Halloween2013TeleportToHell(string) : "Teleport all players to hell." // TODO: parameter?
] // end tf_logic_holiday

@PointClass base(SBaseLogical) color(100 150 255) iconsprite("editor-abs/tf_logic_hybrid_ctf_cp")  = tf_logic_hybrid_ctf_cp : "This entity is used to set visibility of Control Points in hybrid maps. For example, hybrid ctf_cp maps where a team needs to control one or more Control Points in order to capture the Intelligence needs this entity in the map for the Control Points to render on the HUD." [
] // end tf_logic_hybrid_ctf_cp

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-abs/tf_logic_koth")  = tf_logic_koth : "King of the Hill Entity. This is used to detect a KOTH map. Spawns two team_round_timer entities for each team's timer, 'zz_red_koth_timer' and 'zz_blue_koth_timer'. This is the only way to display multiple team_round_timers on the HUD." [
	timer_length(integer) : "Timer length" : 180 : "Initial timer length (in seconds) for each team."
	unlock_point(integer) : "Unlock Point" : 30 : "Time (in seconds) to wait before unlocking the point."

	input AddBlueTimer(integer)	:	"Add time to the BLUE timer."
	input AddRedTimer(integer)	:	"Add time to the RED timer."
	input SetBlueTimer(integer)	:	"Set the time remaining for the BLUE timer."
	input SetRedTimer(integer)	:	"Set the time remaining for the RED timer."
	//input RoundSpawn(void) : "Forces this entity to spawn. Fired automatically at the start of a round."
	//input RoundActivate(void) : "Forces this entity to activate. Fired automatically at the start of a round."
] // end tf_logic_koth

@PointClass base(SPreservedEntity, SBaseLogical) color(100 150 255) iconsprite("editor-ficool2/tf_logic_mann_vs_machine") = tf_logic_mann_vs_machine : "Mann vs Machine entity. This is used to detect a Mann vs Machine map." [
] // end tf_logic_mann_vs_machine

@PointClass base(SBaseLogical) color(100 150 255) iconsprite("editor-ficool2/tf_logic_mannpower") = tf_logic_mannpower : "Logic specifically for Mannpower Mode." [
] // end tf_logic_mannpower

@PointClass base(SPreservedEntity, SBaseLogical) color(100 150 255) iconsprite("editor-ficool2/tf_logic_medieval") = tf_logic_medieval : "Medieval Mode Entity. This is used to detect a Medieval map." [
] // end tf_logic_medieval

@PointClass base(SBaseLogical) color(100 150 255) iconsprite("editor-ficool2/tf_logic_minigames") = tf_logic_minigames : "Minigame mode logic." [
	input ReturnFromMinigame(void) : "Force players to return from the current minigame."
	input SetAdvantageTeam(string) : "Set which team has the advantage."
	input TeleportToMinigame(integer) : "Teleport to a specific minigame."
	input TeleportToRandomMinigame(void) : "Teleport to a random minigame"
] // end tf_logic_minigames

@PointClass base(SBaseLogical) color(100 150 255) iconsprite("editor-abs/tf_logic_multiple_escort") = tf_logic_multiple_escort : "Multiple Escort Entity. This is used to detect a payload map with trains for both teams." [
] // end tf_logic_multiple_escort

@PointClass base(SBaseLogical) color(100 150 255) iconsprite("editor-ficool2/tf_logic_on_holiday") = tf_logic_on_holiday : "This entity allows you to execute map actions on holidays. Will send all relevant outputs every time the Fire input is called." [
	input Fire(void) : "Cause one or more appropriate outputs to fire."

	output IsAprilFools(void) : "April Fools day."
	output IsFullMoon(void) : "Full Moon day."
	output IsHalloween(void) : "Halloween."
	output IsNothing(void) : "No holiday."
	output IsSmissmas(void) : "Smissmas (Christmas)."
	output IsTFBirthday(void) : "Team Fortress birthday."
	output IsValentines(void) : "Valentines day."
] // end tf_logic_on_holiday

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/tf_logic_robot_destruction") = tf_logic_robot_destruction : "Robot Destruction Entity. This is used to detect a Robot Destruction map." [
	score_interval(float) : "Robot Scoring Interval (in seconds)" : 1 : "How often a robot should score a point while hacking."
	max_points(integer) : "Maximum Points" : 200 : "The number of points a team must get to unlock their win condition."
	finale_length(float) : "Finale Length" : 30 : "The amount of time from after max score is reached a team will win."
	red_respawn_time(float) : "Red Respawn Time (in seconds)" : 10 : "Respawn times for Red"
	blue_respawn_time(float) : "Blue Respawn Time (in seconds)" : 10 : "Respawn times for Blue"
	loser_respawn_bonus_per_bot(float) : "Loser Respawn Bonus/Bot (percentage)" : "0.0" : "How much faster the losing team will respawn per bot difference."
	res_file(string) : "HUD Res File" : "resource/UI/HudObjectiveRobotDestruction.res" : "What res file to use for the HUD"
	//score_interval(float) : "Robot Score Interval" :  : "Unknown function."
	//loser_respawn_bonus_per_bot(float) : "Loser Respawn Bonus per Bot" :  : "Unknown function." // Why the hell are these duplicated with two different descriptions FICOOL

	//input RoundActivate(void) : "Forces this entity to activate. Fired automatically at the start of a round."

	output OnBlueHitMaxPoints(void) : "Sent when Blue hits the max points."
	output OnRedHitMaxPoints(void) : "Sent when Red hits the max points."
	output OnBlueLeaveMaxPoints(void) : "Sent when blue goes from max points to fewer."
	output OnRedLeaveMaxPoints(void) : "Sent when red goes from max points to fewer."
	output OnBlueHitZeroPoints(void) : "Sent when Blue hits 0 points."
	output OnRedHitZeroPoints(void) : "Sent when Red hits 0 points"
	output OnBlueHasPoints(void) : "Sent when Blue goes from 0 to any points"
	output OnRedHasPoints(void) : "Sent when Red goes from 0 to any points"
	output OnRedFinalePeriodEnd(void) : "Sent when the red finale period ends."
	output OnBlueFinalePeriodEnd(void) : "Sent when the blue finale period ends."
	output OnRedFirstFlagStolen(void) : "Sent when red's first flag gets stolen."
	output OnRedFlagStolen(void) : "Sent when a flag gets stolen from red."
	output OnRedLastFlagReturned(void) : "Sent when red's last stolen flag gets returned."
	output OnBlueFirstFlagStolen(void) : "Sent when blue's first flag gets stolen."
	output OnBlueFlagStolen(void) : "Sent when a flag gets stolen from blue."
	output OnBlueLastFlagReturned(void) : "Sent when blue's last stolen flag gets returned."
] // end tf_logic_robot_destruction

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/tf_logic_player_destruction") = tf_logic_player_destruction : "Player Destruction Entity. This is used to detect a Player Destruction map." [
	prop_model_name(studio) : "Flag Model Name" : "models/flag/flag.mdl" : "Model of the points that drops from a player on death."
	prop_drop_sound(sound) : "Flag Drop Sound" :  : "Sound when player drops points."
	prop_pickup_sound(sound) : "Flag Pickup Sound" :  : "Sound when player picks up dropped points."
	flag_reset_delay(integer) : "Flag Reset Delay" : 60 : "Length of time (in seconds) before dropped points reset."
	min_points(integer) : "Minimum Points" : 10 : "The minimum possible points required to win."
	max_points(integer) : "Maximum Points" :  : "The maximum possible points required to win."
	points_per_player(integer) : "Max Points/Player" : 5 : "For every player in the server, the points required to win is increased by this much."
	finale_length(float) : "Finale Length" : 30 : "The amount of time, in seconds, from after max score is reached that a team will win."
	res_file(string) : "HUD .res File" : "resource/UI/HudObjectivePlayerDestruction.res" : "What .res file to use for the HUD. Custom .res files will not work until packed into the map; simply having them in your game files will not work."
	heal_distance(integer) : "Heal Distance" : 450 : "The distance for the team leader's ability to heal teammates."
	red_respawn_time(float) : "RED Respawn Time (in seconds)" : 8 : "Respawn times for RED. Doesn't seem to do anything."
	blue_respawn_time(float) : "BLU Respawn Time (in seconds)" : 8 : "Respawn times for BLU. Doesn't seem to do anything."
	score_interval(float) : "Robot Score Interval" :  : "Unknown function."
	loser_respawn_bonus_per_bot(float) : "Loser Respawn Bonus/Bot" :  : "Unknown function."

	input DisableMaxScoreUpdating(void) : "Disallow the max score to update based on player count."
	input EnableMaxScoreUpdating(void) : "Allow the max score to update based on player count."
	input ScoreBluePoints(void) : "Score 1 point for BLU."
	input ScoreRedPoints(void) : "Score 1 point for RED."
	input SetCountdownImage(string) : "Set the countdown image."
	input SetCountdownTimer(integer) : "Set the countdown time and start the timer."
	input SetFlagResetDelay(integer) : "Set the length of time (in seconds) before a dropped flag resets."
	input SetPointsOnPlayerDeath(integer) : "Set number of points per flag dropped upon player death."
	//input RoundActivate(void) : "Forces this entity to activate. Fired automatically at the start of a round."

	output OnBlueHitMaxPoints(void) : "Sent when BLU hits the max points."
	output OnRedHitMaxPoints(void) : "Sent when RED hits the max points."
	output OnBlueLeaveMaxPoints(void) : "Sent when BLU goes from max points to fewer."
	output OnRedLeaveMaxPoints(void) : "Sent when RED goes from max points to fewer."
	output OnBlueHitZeroPoints(void) : "Sent when BLU hits 0 points."
	output OnRedHitZeroPoints(void) : "Sent when RED hits 0 points."
	output OnBlueHasPoints(void) : "Sent when BLU goes from 0 to any points."
	output OnRedHasPoints(void) : "Sent when RED goes from 0 to any points."
	output OnRedFinalePeriodEnd(void) : "Sent when the RED finale period ends."
	output OnBlueFinalePeriodEnd(void) : "Sent when the BLU finale period ends."
	output OnRedFirstFlagStolen(void) : "Sent when RED's first flag gets stolen."
	output OnRedFlagStolen(void) : "Sent when a flag gets stolen from RED."
	output OnRedLastFlagReturned(void) : "Sent when RED's last stolen flag gets returned."
	output OnBlueFirstFlagStolen(void) : "Sent when BLU's first flag gets stolen."
	output OnBlueFlagStolen(void) : "Sent when a flag gets stolen from BLU."
	output OnBlueLastFlagReturned(void) : "Sent when BLU's last stolen flag gets returned."
	output OnRedScoreChanged(float) : "Send when score changes, and is a value representing total progress from [0..1]."
	output OnBlueScoreChanged(float) : "Send when score changes, and is a value representing total progress from [0..1]."
	output OnCountdownTimerExpired(void) : "Sent when the countdown timer expires."
] // end tf_logic_player_destruction

@PointClass base(SPreservedEntity, SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor-ficool2/tf_logic_training_mode") = tf_logic_training_mode : "Training logic entity. This is used to detect a training map. None of the entity functions in multiplayer except for the KickBots input." [
	nextMap(string): "Next Map" :  : "Next map to load when the current one is finished, without the .bsp extension."

	input EndTraining(string) : "Ends training mode."
	input ForcePlayerSpawnAsClassOutput(void) : "Force the appropriate output to fire for the player spawning as a class. You can use this to essentially ask what class the player is."
	input ForcePlayerSwapToWeapon(string) : "Forces the player to switch to the weapon."
	input HideTrainingHUD(void) : "Makes the training objective HUD hidden."
	input KickBots(void) : "Kicks all the bots from the server."
	input PlaySoundOnPlayer(string) : "Play a sound on the player."
	input SetNextMap(string) : "Set the next map for training."
	input ShowTrainingHUD(void) : "Makes the training objective HUD visible."
	input ShowTrainingMsg(string) : "Show a training message, for training mode. The parameter should be the string entry in tf_english.txt"
	input ShowTrainingObjective(string) : "Sets a training objective to show to the player."
	input WaitForTimerOrKeypress(target_destination) : "Wait for the logic_timer entity to fire on its interval or for a keypress from the player."

	output OnBotDied(void) : "Sent when a bot player dies."
	output OnBuildOutsideArea(void) : "Sent when the player builds an object outside a suggested area."
	output OnPlayerDetonateBuilding(void) : "Sent when the player manually detonates one of their buildings."
	output OnPlayerDied(void) : "Sent when the player dies."
	output OnPlayerSpawnAsDemoman(void) : "Sent when the player spawns as a Demoman."
	output OnPlayerSpawnAsEngineer(void) : "Sent when the player spawns as an Engineer."
	output OnPlayerSpawnAsHeavy(void) : "Sent when the player spawns as a Heavy."
	output OnPlayerSpawnAsMedic(void) : "Sent when the player spawns as a Medic."
	output OnPlayerSpawnAsPyro(void) : "Sent when the player spawns as a Pyro."
	output OnPlayerSpawnAsScout(void) : "Sent when the player spawns as a Scout."
	output OnPlayerSpawnAsSniper(void) : "Sent when the player spawns as a Sniper."
	output OnPlayerSpawnAsSoldier(void) : "Sent when the player spawns as a Soldier."
	output OnPlayerSpawnAsSpy(void) : "Sent when the player spawns as a Spy."
	output OnPlayerSwappedToBuilding(void) : "Sent when the player swaps to the item in his building weapon slot."
	output OnPlayerSwappedToMelee(void) : "Sent when the player swaps to the item in his melee weapon slot."
	output OnPlayerSwappedToPDA(void) : "Sent when the player swaps to the item in his pda weapon slot."
	output OnPlayerSwappedToPrimary(void) : "Sent when the player swaps to the item in his primary weapon slot."
	output OnPlayerSwappedToSecondary(void) : "Sent when the player swaps to the item in his secondary weapon slot."
] // end tf_logic_training_mode

@PointClass base(SModel, SBaseEntity, SBaseDiv, SModelSkin, SModelBodyGroup, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop() = tf_merasmus_trick_or_treat_prop : "The hide and seek props Merasmus uses when he is hiding. Model must be set or the game will crash!" [
] // end tf_merasmus_trick_or_treat_prop

@PointClass base(SBaseLogical) color(150 0 200) iconsprite("editor-ficool2/tf_point_nav_interface") = tf_point_nav_interface : "Entity interface to the navigation mesh. It's only current use is to recompute blocks in the navigation mesh, with the RecompuleBlockers input." [
	input RecomputeBlockers(void) : "Recompute blocks in the nav mesh. Call this after blockers change state (ie. a door opens or closes)."
] // end tf_point_nav_interface

@PointClass base(SBaseEntity, SBaseDiv) sphere(SplashRadius) studio("models/editor/cone_helper.mdl") = tf_point_weapon_mimic : "An entity used to fire projectiles from its position. Projectiles are visually on the Blu team, but otherwise behave as neutral." [
	WeaponType(choices) : "Projectile Type" : 0 : "What type of projectile this entity should fire. Arrows cannot headshot." = [
		0 : "Rocket"
		1 : "Grenade"
		3 : "Stickybomb"
		2 : "Arrow"
	] // end WeaponType
	Damage(integer) : "Damage" : 90 : "The base damage that each projectile will deal to players that it hits. Non-critical rockets and stickybombs are subject to damage ramp-up and falloff; for rockets based on travel distance, and stickybombs based on how long they have been planted."
	Crits(choices) : "Critical?" : 0 : "If set to Yes, fired projectiles will be critical. Critical projectiles will deal triple the specified damage and have special visual/auditory effects. Rockets and stickybombs will no longer be affected by damage ramp-up or falloff." = [
		0 : "No"
		1 : "Yes"
	] // end Crits
	SplashRadius(float) : "Splash Radius" : 146 : "Only affects grenades and stickybombs. Radius of the explosion generated when each projectile explodes, in HU. For rockets, grenades, and stickybombs, the typical blast radius is 146HU."
	SpeedMin(float) : "Minimum Speed" : 1100 : "The initial speed of each projectile, in HU/s, will be a random value between the minimum and maximum speeds. Rockets are typically fired at 1100HU/s, grenades at 1216HU/s, stickybombs at 805HU/s, and arrows from 1875HU/s (uncharged) to 2344HU/s (charged)."
	SpeedMax(float) : "Maximum Speed" : 1100 : "The initial speed of each projectile, in HU/s, will be a random value between the minimum and maximum speeds. Rockets are typically fired at 1100HU/s, grenades at 1216HU/s, stickybombs at 805HU/s, and arrows from 1875HU/s (uncharged) to 2344HU/s (charged)."
	SpreadAngle(float) : "Max Angular Spread" : 0 : "By default, projectiles are fired straight along this entity's angles. If this is nonzero, a random amount of angular spread is added to each projectile's path, with the maximum deviation possible being half of this value in degrees."
	ModelOverride(studio) : "Projectile Model Override" :  : "If specified, override each projectile's default model with a custom one. Rockets and arrows will use this model's bounding box for collisions, but grenades and stickybombs will still use their original mesh for collisions. Arrows will revert back to their default arrow model after embedding themselves in an object."
	ModelScale(float) : "Projectile Model Scale" : "1.0" : "Only affects grenades and stickybombs. Scales the size of each projectile's model. Does not alter the size or shape of its collisions."
	// These are not used in code
	//FireSound(sound) : "Fire Sound" :  : ""
	//ParticleEffect(string) : "Particle Effect" :  : ""

	input DetonateStickies(void) : "Detonate all stickybombs fired by this entity (even bombs which have not passed their arm time)."
	input FireOnce(void) : "Fire a single projectile."
	input FireMultiple(integer) : "Instantly fire the specified number of projectiles."
] // end tf_point_weapon_mimic

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/weapons/w_models/w_arrow.mdl") = tf_projectile_arrow : "The Huntsman arrow projectile." [
] // end tf_projectile_arrow

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/weapons/c_models/c_xms_festive_ornament.mdl") = tf_projectile_ball_ornament : "The Wrap Assassin ball projectile." [
] // end tf_projectile_ball_ornament

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) iconsprite("editor-ficool2/tf_projectile_balloffire") sphere(fademindist) sphere(fademaxdist) = tf_projectile_balloffire : "The Dragon's Fury ball of fire projectile." [
] // end tf_projectile_balloffire

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/weapons/c_models/c_sd_cleaver/c_sd_cleaver.mdl") = tf_projectile_cleaver : "The Flying Guillotine projectile." [
] // end tf_projectile_cleaver

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) iconsprite("editor-ficool2/tf_projectile_energy_ball") sphere(fademindist) sphere(fademaxdist) = tf_projectile_energy_ball : "Cow Mangler alt-fire energy ball projectile." [
] // end tf_projectile_energy_ball

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) iconsprite("editor-ficool2/tf_projectile_energy_ring") sphere(fademindist) sphere(fademaxdist) = tf_projectile_energy_ring : "Cow Mangler alt-fire energy ring (from energy ball)." [
] // end tf_projectile_energy_ring

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/weapons/w_models/w_flaregun_shell.mdl") = tf_projectile_flare :"Flare Gun fired shell projectile."[
] // end tf_projectile_flare

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/weapons/c_models/c_grapple_proj/c_grapple_proj.mdl") = tf_projectile_grapplinghook : "Grappling Hook fired projectile." [
] // end tf_projectile_grapplinghook

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/weapons/w_models/w_repair_claw.mdl") = tf_projectile_healing_bolt : "Rescue Ranger bolt projectile." [
] // end tf_projectile_healing_bolt

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/weapons/c_models/urinejar.mdl") = tf_projectile_jar : "Jarate jar thrown projectile." [
] // end tf_projectile_jar

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/weapons/c_models/c_gascan/c_gascan.mdl") = tf_projectile_jar_gas : "Gas Passer projectile."[
] // end tf_projectile_jar_gas

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/weapons/c_models/c_madmilk/c_madmilk.mdl") = tf_projectile_jar_milk : "Mad Milk jar thrown projectile." [
] // end tf_projectile_jar_milk

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) iconsprite("editor-ficool2/tf_projectile_lightningorb") sphere(fademindist) sphere(fademaxdist) = tf_projectile_lightningorb : "Ball O' Lightning spell projectile." [
] // end tf_projectile_lightningorb

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) iconsprite("editor-ficool2/tf_projectile_mechanicalarmorb") sphere(fademindist) sphere(fademaxdist) = tf_projectile_mechanicalarmorb : "Short Circuit alt-fire orb projectile." [
] // end tf_projectile_mechanicalarmorb

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/weapons/w_models/w_grenade_grenadelauncher.mdl") = tf_projectile_pipe : "Grenade Launcher pill/grenade projectile." [
] // end tf_projectile_pipe

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/weapons/w_models/w_stickybomb.mdl") = tf_projectile_pipe_remote : "Stickybomb Launcher stickybomb projectile." [
] // end tf_projectile_pipe_remote

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/weapons/w_models/w_rocket.mdl") = tf_projectile_rocket : "Rocket Launcher rocket projectile." [
] // end tf_projectile_rocket

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/buildables/sentry3_rockets.mdl") = tf_projectile_sentryrocket : "Level 3 Sentry Gun rocket projectile." [
] // end tf_projectile_sentryrocket

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) iconsprite("editor-ficool2/tf_projectile_spellbats") sphere(fademindist) sphere(fademaxdist) = tf_projectile_spellbats : "Ball O' Bats spell projectile." [
] // end tf_projectile_spellbats

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) iconsprite("editor-ficool2/tf_projectile_spellfireball") sphere(fademindist) sphere(fademaxdist) = tf_projectile_spellfireball : "Fireball spell projectile." [
] // end tf_projectile_spellfireball

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) iconsprite("editor-ficool2/tf_projectile_spellkartbats") sphere(fademindist) sphere(fademaxdist) = tf_projectile_spellkartbats : "Kart - Ball O' Bats spell projectile." [
] // end tf_projectile_spellkartbats

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) iconsprite("editor-ficool2/tf_projectile_spellkartorb") sphere(fademindist) sphere(fademaxdist) = tf_projectile_spellkartorb : "Kart - Ball O' Lightning spell projectile." [
] // end tf_projectile_spellkartorb

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) iconsprite("editor-ficool2/tf_projectile_spellmeteorshower") sphere(fademindist) sphere(fademaxdist) = tf_projectile_spellmeteorshower : "Meteor Storm spell projectile." [
] // end tf_projectile_spellmeteorshower

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) iconsprite("editor-ficool2/tf_projectile_spellmirv") sphere(fademindist) sphere(fademaxdist) = tf_projectile_spellmirv : "Pumpkin MIRV spell projectile." [
] // end tf_projectile_spellmirv

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) iconsprite("editor-ficool2/tf_projectile_spellpumpkin") sphere(fademindist) sphere(fademaxdist) = tf_projectile_spellpumpkin : "The pumpkins created by the Pumpkin MIRV spell." [
] // end tf_projectile_spellpumpkin

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) iconsprite("editor-ficool2/tf_projectile_spellspawnboss") sphere(fademindist) sphere(fademaxdist) = tf_projectile_spellspawnboss : "Summon MONOCULUS spell projectile." [
] // end tf_projectile_spellspawnboss

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) iconsprite("editor-ficool2/tf_projectile_spellspawnhorde") sphere(fademindist) sphere(fademaxdist) = tf_projectile_spellspawnhorde : "Summon Skeletons spell projectile." [
] // end tf_projectile_spellspawnhorde

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) iconsprite("editor-ficool2/tf_projectile_spellspawnzombie") sphere(fademindist) sphere(fademaxdist) = tf_projectile_spellspawnzombie : "The green-skull that spawns when a normal-sized skeleton is killed, which in turn spawns a baby-sized skeleton." [
] // end tf_projectile_spellspawnzombie

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) iconsprite("editor-ficool2/tf_projectile_spelltransposeteleport") sphere(fademindist) sphere(fademaxdist) = tf_projectile_spelltransposeteleport : "Teleport spell projectile." [
] // end tf_projectile_spelltransposeteleport

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/weapons/w_models/w_baseball.mdl") = tf_projectile_stun_ball : "Sandman ball projectile." [
] // end tf_projectile_stun_ball

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/weapons/w_models/w_syringe_proj.mdl") = tf_projectile_syringe : "SyringeGun syringe projectile." [
] // end tf_projectile_syringe

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) = tf_projectile_throwable : "Unused projectile, presumably used to throw bread. Attempts to use a model named models/props_gameplay/small_loaf.mdl, which does not exist. Also attempts to attach a particle named breadtrail_basic_red or breadtrail_basic_blue, neither which exist." [ // studioprop("models/props_gameplay/small_loaf.mdl")
] // end tf_projectile_throwable

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) = tf_projectile_throwable_breadmonster : "Unknown, needs to be tested." [
] // end tf_projectile_throwable_breadmonster

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) = tf_projectile_throwable_brick : "Unknown, needs to be tested." [
] // end tf_projectile_throwable_brick

@PointClass base(SBaseEntity, SBaseDiv, STFTeam, SVelocity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) = tf_projectile_throwable_repel : "Unknown, needs to be tested." [
] // end tf_projectile_throwable_repel

@PointClass base(SBaseEntity, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/props_halloween/pumpkin_explode.mdl") = tf_pumpkin_bomb : "tf_pumpkin_bomb is a explosive hazard generally used in Halloween maps. Removes itself after exploding. In the official maps, they are spawned by a entity_spawn_manager. For a more customizable version, see tf_generic_bomb." [
]

@PointClass base(SBaseEntity, SBaseDiv, SHealth, SBaseDynamicModel) sphere(fademindist) sphere(fademaxdist) studioprop("models/bots/bot_worker/bot_worker_a.mdl") = tf_robot_destruction_robot : "Robot Destruction Robot." [
	health(integer) : "Health" : 500 : "The health of the robot."

	input StopAndUseComputer(void)	:	"Unknown function." // TODO wat dis -Brokk
] // end tf_robot_destruction_robot

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/tf_robot_destruction_robot_spawn") = tf_robot_destruction_robot_spawn : "Robot Destruction Robot spawn point." [
	health(integer) : "Health" : 500 : "The health for the robot."
	type(choices) : "Robot Style" : 0 = [
		0 : "Frustum"
		1 : "Sphere"
		2 : "King"
		3 : "Finale"
	] // end type
	gibs(integer) : "Gibs" : 0 : "The number of point-giving gibs to spawn on death."
	//points(integer) : "Gibs" :  : "The number of points to give on death." // Ficool, why do you have two different gibs keyvalues!? This one isn't listed in tf.fgd and doesn't seem to be used by rd_asteroid, so I'm commenting it out
	spawngroup(target_destination) : "Spawn Group" :  : "Which group this spawn belongs to."
	startpath(target_destination) : "Start Path" :  : "Which path_track to head towards first."

	input SpawnRobot(void) : "Spawn a robot on this spawnpoint.  Does nothing if there's already a robot."

	output OnRobotKilled(void) : "Sent when this spawn point's robot dies."
] // end tf_robot_destruction_robot_spawn

@PointClass base(SBaseLogical, SBaseDiv) iconsprite("editor-ficool2/tf_robot_destruction_spawn_group") = tf_robot_destruction_spawn_group : "Robot Destruction spawn group. This groups the Robot Destruction spawn points." [
	team_number(choices) : "Team" : 0 : "" = [
	    0 : "Any"
	    1 : "Spectator"
		2 : "RED"
		3 : "BLU"
		// 4 does not exist
		5 : "Boss"
	] // end team_number
	group_number(integer) : "Group Number" : 0 : "This group's number. Affects UI position and spawn priority."
	respawn_time(float) : "Respawn Time" : 0 : "Respawn time for this group."
	respawn_reduction_scale(float) : "Team Respawn Reduction Scale" : 0 : "Scale the owning team's respawn time by this amount when this group is dead."
	hud_icon(string) : "HUD Icon Name" : "../HUD/hud_bot_worker_outline_blue" : "HUD icon to use for this group."

	output OnAllRobotsDead(void ) : "Sent when the last robot alive in this group dies."
	output OnRobotsRespawn(void) : "Sent when this group's robots respawn."
] // end tf_robot_destruction_spawn_group

@PointClass base(SDoesNotFunction, SBaseEntity, SBaseDiv) iconsprite("editor/obsolete") = tf_spawner : "An entity that spawns entities created from special templates. This is designed to only work with special template entity classes, however no such entity classes actually exist in-game, making this entity useless. See env_entity_maker or entity_spawn_manager instead." [
	template(target_destination) : "Template" :  : "Template to spawn entities from. This is NOT a point_template; this is designed to work with specific entity classes, none of which exist in-game."
	count(integer) : "Count" : 1 : "Total number of entities to spawn over the lifetime of this spawner."
	maxActive(integer) : "Max Active" : 1 : "Maximum number of simultaneous active entities created by this spawner."
	interval(float) : "Interval" : 0 : "Time (in seconds) between spawns."

	input Disable(void) : "Stop spawning entities."
	input Enable(void) : "Begin spawning entities."
	input Reset(void) : "Reset spawner to initial state."

	output OnExpended(void) : "Sent when the spawner has reached its allowed total of entities spawned."
	output OnKilled(void) : "Sent when an entity spawned by this spawner has died/been destroyed."
	output OnSpawned(void) : "Sent when an entity has spawned into the environment."
] // end tf_spawner

@PointClass base(SBaseEntity) iconsprite("editor-ficool2/tf_spell_meteorshowerspawner") = tf_spell_meteorshowerspawner : "A spawner for the meteor shower spell." [
] // end tf_spell_meteorshower

@BaseClass = tf_spell_pickup_keys [
	tier(choices) : "Spell Tier" : 0 : "Tier of spells that would be randomly assigned to the player." = [
		0 : "Common"
		1 : "Rare"
	] // end tier
] // end tf_spell_pickup_keys
@PointClass base(SBaseEntity, SBaseItem, tf_spell_pickup_keys, SBaseDynamicModel) color(200 200 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/props_halloween/hwn_spellbook_flying.mdl") = tf_spell_pickup : "A spellbook pickup used in Helltower and dynamically dropped by killed players in any Halloween map that has spells enabled." [
] // end tf_spell_pickup

@PointClass base(SBaseEntity, SBaseDiv, SModelSkin, STFTeam, SBaseDynamicModel) color(255 100 0) sphere(fademindist) sphere(fademaxdist) studioprop("models/props_training/target_demoman.mdl") = tf_target_dummy : "A breakable red engineer or red demoman target (chosen randomly). If a team is specified, it can only be broken by the enemy team. Has extreme damage resistance to all non-melee sources for reasons unknown." [
] // end tf_target_dummy

// TODO: Test stuff
// Seems to be defined in tf_gamerules.cpp. Comments & code indicate that the entity's position and angles are stored and the entity itself is deleted on map spawn. Test?
// Code indicates valid names are "hell_ghost_spawn" or defined by tf_base_minigame in tf_logic_halloween_2014.cpp. tf_base_minigame does not seem to require this entity, however. Can this entity be used in other contexts?
@PointClass base(SPlayerHelper, SBaseEntity) studio() = tf_teleport_location : "Location where players will teleport to when triggered by map events, such as for Halloween maps. When it spawns, the entity itself is deleted and its position and angles are stored for later use." [
] // end tf_teleport_location

// NOTES FROM FICOOL2: tf_weapon_* and weapoon_* entities are not being documentated, as they all do not spawn. Instead, they will be listed here.
// tf_weapon_base
// tf_weapon_bat
// tf_weapon_bat_fish
// tf_weapon_bat_giftwrap
// tf_weapon_bat_wood
// tf_weapon_bonesaw
// tf_weapon_bottle
// tf_weapon_breakable_sign
// tf_weapon_buff_item
// tf_weapon_builder
// tf_weapon_cannon
// tf_weapon_charged_smg
// tf_weapon_cleaver
// tf_weapon_club
// tf_weapon_compound_bow
// tf_weapon_crossbow
// tf_weapon_drg_pomson
// tf_weapon_fireaxe
// tf_weapon_fists
// tf_weapon_flamethrower
// tf_weapon_flaregun
// tf_weapon_flaregun_revenge
// tf_weapon_grapplinghook
// tf_weapon_grenadelauncher
// tf_weapon_handgun_scout_primary
// tf_weapon_handgun_scout_secondary
// tf_weapon_invis
// tf_weapon_jar
// tf_weapon_jar_gas
// tf_weapon_jar_milk
// tf_weapon_katana
// tf_weapon_knife
// tf_weapon_laser_pointer
// tf_weapon_lunchbox
// tf_weapon_lunchbox_drink
// tf_weapon_mechanical_arm
// tf_weapon_medigun
// tf_weapon_minigun
// tf_weapon_parachute
// tf_weapon_parachute_primary
// tf_weapon_parachute_secondary
// tf_weapon_particle_cannon
// tf_weapon_passtime_gun
// tf_weapon_pda_engineer_build
// tf_weapon_pda_engineer_destroy
// tf_weapon_pda_spy
// tf_weapon_pep_brawler_blaster
// tf_weapon_pipebomblauncher
// tf_weapon_pistol
// tf_weapon_pistol_scout
// tf_weapon_raygun
// tf_weapon_revolver
// tf_weapon_robot_arm
// tf_weapon_rocketlauncher
// tf_weapon_rocketlauncher_airstrike
// tf_weapon_rocketlauncher_directhit
// tf_weapon_rocketlauncher_fireball
// tf_weapon_rocketpack
// tf_weapon_sapper
// tf_weapon_scattergun
// tf_weapon_sentry_revenge
// tf_weapon_shotgun_building_rescue
// tf_weapon_shotgun_hwg
// tf_weapon_shotgun_primary
// tf_weapon_shotgun_pyro
// tf_weapon_shotgun_soldier
// tf_weapon_shovel
// tf_weapon_slap
// tf_weapon_smg
// tf_weapon_sniperrifle
// tf_weapon_sniperrifle_classic
// tf_weapon_sniperrifle_decap
// tf_weapon_soda_popper
// tf_weapon_spellbook
// tf_weapon_stickbomb
// tf_weapon_sword
// tf_weapon_syringegun_medic
// tf_weapon_wrench
// These also have not been documentated, as they do nothing
// weapon_ifm_base
// weapon_ifm_base_camera
// weapon_ifm_steadycam

@PointClass base(SBaseEntity) iconsprite("editor-ficool2/tf_weaponbase_grenade_proj") = tf_weaponbase_grenade_proj : "Manager entity for TF2 grenade projectiles. Creates an explosion upon spawning, no other functionality." [
] // end tf_weaponbase_grenade_proj

@PointClass base(SBaseEntity) iconsprite("editor-ficool2/tf_weaponbase_merasmus_grenade") = tf_weaponbase_merasmus_grenade : "Manager entity for TF2 grenade projectiles. Creates a green explosion upon spawning, no other functionality." [
] // end tf_weaponbase_merasmus_grenade

@PointClass base(SBaseEntity, SBaseDiv, SHealth, SHealthMax, STFTeam, SBaseDynamicModel) color(150 0 200) sphere(fademindist) sphere(fademaxdist) studioprop("models/bots/skeleton_sniper/skeleton_sniper.mdl") = tf_zombie : "An AI-controlled skeleton that attacks players. Despite the name, the entity is a skeleton and not a 'zombie'. These should be spawned via a tf_zombie_spawner optimally." [
] // end tf_zombie

@PointClass base(SBaseEntity, SBaseDiv) color(150 0 200) studioprop("models/bots/skeleton_sniper/skeleton_sniper.mdl") = tf_zombie_spawner : "Entity that spawns skeletons." [
	zombie_lifetime(float) : "Skeleton Lifetime" : 0 : "Skeleton lifetime in seconds. 0 means skeletons will stay alive until they're killed."
	max_zombies(integer) : "Skeleton Count" : 1 : "Number of skeletons this point can have active in the world."
	infinite_zombies(choices) : "Infinite Spawn?" : 0 : "If Yes, keep spawning skeletons to have skeleton count in the world. If no, only spawn skeletons up to skeleton count." = [
		0 : "No"
		1 : "Yes"
	] // end infinite_zombies
	zombie_type(choices) : "Skeleton Type" : 0 : "Type of skeleton." = [
		0 : "Normal"
		1 : "King"
	] // end zombie_type

	input Disable(void) : "Disable zombie spawn point."
	input Enable(void) : "Enable zombie spawn point."
	input SetMaxActiveZombies(integer) : "Set the maximum number of skeletons."
] // end tf_zombie_spawner



	// TRAINING ENTITIES //

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/training_annotation") = training_annotation : "An in-world location-specific information bubble." [
	display_text(string) : "Displayed Text" :  : "The text to be displayed in the annotation popup."
	lifetime(float) : "Lifetime" : -1 : "How long you want the annotation popup to stick around.  If set to 0, it will default to the value in code (1 sec).  If it set to -1, it will last until manually hidden with the Hide input."
	offset(float) : "Vertical Offset" : 0 : "The vertical offset." // TODO test

	input Hide(void) : "Hide the annotation."
	input Show(void) : "Show the annotation."
] // end training_annotation



	// VGUI ENTITIES //

@PointClass base(SBaseEntity, SBaseDiv) studio("models/editor/axis_helper_thick.mdl") = vgui_screen : "A VGUI screen. Useful for in-world monitors. This is used by the Engineer's dispenser for the metal counter." [
	panelname(string) : "Panel Name" :  : "Name of the panel to use. This is not a filename." // TODO: Then what is it?
	overlaymaterial(material) : "Overlay Material" :  : "Name of a material to overlay over the top of the VGUI screen. This material must write Z for the VGUI screen to work."
	width(integer) : "Panel Width" : 32 : "Width of the panel in units."
	height(integer) : "Panel Height" : 32 : "Height of the panel in units."

	input SetActive(void) : "Make the screen visible."
	input SetInactive(void) : "Make the screen invisible."
] // end vgui_screen

// TODO: what's dis do
@PointClass base(vgui_screen, STFTeam) studio("models/editor/axis_helper_thick.mdl") = vgui_screen_team : "Identical to vgui_screen, but supports teams. Regardless, this entity appears to be unused." [
] // end vgui_screen_team

@PointClass base(SBaseEntity, SBaseDiv) studio("models/editor/axis_helper_thick.mdl") = vgui_slideshow_display : "A VGUI screen the displays images in a slideshow. See developer.valvesoftware.com/wiki/Vgui_slideshow_display for a full explanation on the usage of this." [
	width(integer) : "Panel width" : 256 : "Width of the panel in units."
	height(integer) : "Panel height" : 128 : "Height of the panel in units."
	displaytext(string) : "Display Text" :  : "Text to display on top of the image."
	directory(string) : "Image Directory (materials/vgui/...)" : "slideshow" : "Directory where images are located (materials/vgui/[directory])."
	maxslidetime(float) : "Max Slide Time" : "0.5" : "Maximum amount of random time that a slide is displayed."
	minslidetime(float) : "Min Slide Time" : "0.5" : "Minimum amount of random time that a slide is displayed."
	cycletype(choices) : "Cycle Type" : 0 : "Order that images are displayed." = [
		0 : "Random"
		1 : "Forward"
		2 : "Backward"
	] // end cycletype
	nolistrepeat(choices) : "List Repeats?" : 0 = [
		0 : "Allow List Repeats"
		1 : "No List Repeats"
	] // end nolistrepeat

	input AddSlides(string) : "Adds slides by keyword."
	input Enable(void) : "Make slideshow visible."
	input Disable(void) : "Make slideshow invisible."
	input RemoveAllSlides(void) : "Removes all slides from slideshow."
	input SetCycleType(integer) : "0 - random, 1 - forward, 2 - backward"
	input SetDisplayText(string) : "Sets the display text."
	input SetMaxSlideTime(float) : "Sets max random time between slides."
	input SetMinSlideTime(float) : "Sets min random time between slides."
	input SetNoListRepeat(bool) : "Sets if lists can be randomly picked twice in a row."
] // end vgui_slideshow_display



	// WATER ENTITIES //

@PointClass base(SBaseLogical, SBaseDiv) color(100 150 255) iconsprite("editor/waterlodcontrol") sphere(cheapwaterstartdistance) sphere(cheapwaterenddistance) = water_lod_control : "An entity used to control the LOD behavior of any water in the map. If your map has water, this entity is required. If you don't have one in your map, one is automatically created when you compile." [
	cheapwaterstartdistance(float) : "Start Transition to Cheap Water" : 1024 : "This is the distance from the camera that water will start transitioning to cheap water, in units."
	cheapwaterenddistance(float) : "End Transition to Cheap Water" : 2048 : "This is the distance from the camera that water will finish transitioning to cheap water, in units."

	input SetCheapWaterStartDistance(float) : "Set the distance that water starts transitioning to cheap water."
	input SetCheapWaterEndDistance(float) : "Set the distance that water finishes transitioning to cheap water."
] // end water_lod_control



	// WHEEL ENTITIES //

@PointClass base(SBaseEntity, SBaseDiv) iconsprite("editor-ficool2/wheel_of_doom") = wheel_of_doom : "The Wheel of Doom for Halloween mode. Picks a random effect when spun. The following effects requires special setup outside of the wheel_of_doom entity:\n" +
	"-Thriller taunt: Requires 32 info_target entities named along the pattern dance_teleport_[team][number up to 15 starting with 0]\n" +
	"-Jarate is dropped from the sky: Requires a func_brush above the map named spawn_cloud; " +
	"-Ghosts appear: Requires 'Allow Wheel of Doom Haunting' to be enabled in a tf_logic_holiday entity." [
	effect_duration(float) : "Effect Duration" : 30 : "How long effects should last before they are automatically removed."
	has_spiral(choices) : "Has Spiral?" : 0 : "Show the spiral effect? If yes, an entity named wheel_of_doom_spiral will be created." = [
		0 : "No"
		1 : "Yes"
	] // end has_spiral

	input ClearAllEffects(void) : "Remove all active effects."
	input Spin(void) : "Spin the wheel."

	output OnEffectApplied(void) : "Effect just applied."
	output OnEffectExpired(void) : "Effect just expired."
] // end wheel_of_doom

@PointClass base(SBaseEntity) iconsprite("editor-ficool2/wheel_of_doom_spiral") = wheel_of_doom_spiral : "The spiral effect created by the wheel_of_doom entity." [
] // end wheel_of_doom_spiral

@PointClass base(Targetname, Parentname, Angles) worldtext() = point_worldtext : 
    "An entity that displays a text message oriented in the world, at its origin."
[
    message(string) : "Entity Message" : "" : "Text Message. Newline characters are accepted"
    textsize(float) : "Text Size" : 10 : "Text Size."
    textspacingx(float) : "Text Spacing X" : 0 : "Spacing between each letter along X axis"
    textspacingY(float) : "Text Spacing Y" : 0 : "Spacing between each letter along Y axis"
    color(color255) : "Color" : "255 255 255 255"
    font(choices) : "Font" : "0" =
    [
        0: "TF2 Build"
        1: "TF2 Build (no outline/shadow)"
        2: "TF2"
        3: "TF2 (no outline/shadow)"
        4: "Liberation Sans"
        5: "Liberation Sans (no outline/shadow)"
        6: "TF2 Professor"
        7: "TF2 Professor (no outline/shadow)"
        8: "Roboto Mono"
        9: "Roboto Mono (no outline/shadow)"
        10: "Roboto Mono (shadow only)"
        11: "Roboto Mono (green glow, soft edges)"
        12: "TF2 Build (soft edges)"
    ]
    orientation(choices) : "Orientation" : "0" =
    [
        0: "Stationary"
        1: "Face player"
        2: "Ignore pitch"
    ]
    rainbow(choices) : "Rainbow" : 0 =
    [
        0 : "No"
        1 : "Yes"
    ]

    // Inputs
    input SetText(string) : "Set the message text."
    input SetTextSize(float) : "Set the message text size."
    input SetTextSpacingX(float) : "Set the spacing between letters along the X axis."
    input SetTextSpacingY(float) : "Set the spacing between letters along the Y axis."
    input SetColor(string) : "Set the message color."
    input SetFont(integer) : "Set the font."
    input SetOrientation(integer) : "Set the orientation."
    input SetRainbow(integer) : "Enable rainbow text."
]

@PointClass base(SParentname, SAngles) studioprop("models/editor/camera.mdl") = point_camera : "Camera"
[
	spawnflags(Flags) =
	[
		1 : "Start Off" : 0 
	]

	targetname(target_source) : "Name" : : "The name that other entities refer to this entity by."
	FOV(float) : "FOV" : 90 : "Field of view in degrees"
//	resolution(float) : "resolution" : 256 : "width/height of the render target for the camera"
	UseScreenAspectRatio(choices) : "Screen Aspect Ratio" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]	
	fogEnable(choices) : "Fog Enable" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]	
	fogColor(color255) : "Fog Color" : "0 0 0"
	fogStart(float) : "Fog Start" : 2048 : "The near fog plane."
	fogEnd(float) : "Fog End" : 4096 : "The far fog/clipping plane."
	fogMaxDensity(float) : "Fog Max Density [0..1]" : 1 : "The maximum fog density. 0=no fog, 1=full fog."

	// Inputs
	input ChangeFOV(string) : "Changes camera's FOV over time"
	input SetOnAndTurnOthersOff(void) : "Turn the camera on, and turn all other cameras off."
	input SetOn(void) : "Turn the camera on."
	input SetOff(void) : "Turn the camera off."
]

@SolidClass base(func_brush) = func_monitor : "A monitor that renders the view from a given point_camera entity."
[
	target(target_destination) : "Camera name"
	
	// Inputs
	input Toggle(void) : "Toggle - If on, turn off, if off, turn on."
	input Enable(void) : "Enable."
	input Disable(void) : "Disable."
	input SetCamera(string) : "Sets the camera to use for this monitor. Takes the name of a point_camera entity in the map."
]

@PointClass base(STargetname) iconsprite("editor/waterlodcontrol") = skybox_swapper : "Precaches and replaces the current 2D skybox material with another. Functionally equivalent to sv_skyname, even using the command in its functionality." 
[
	SkyboxName(choices) : "2D Skybox Material" : "sky_tf2_04" : "Skybox material. A list of official skyboxes is provided, see developer.valvesoftware.com/wiki/Team_Fortress_2_Sky_List for pictures of each. Custom skyboxes can also be typed. This can be changed at runtime with AddOutput, although the player must re-connect to see the change." = [
	//"sky_day01_01"
	"sky_alpinestorm_01" : "sky_alpinestorm_01"
	"sky_badlands_01" : "sky_badlands_01"
	"sky_badlands_pyroland_01" : "sky_badlands_pyroland_01"
	"sky_dustbowl_01" : "sky_dustbowl_01"
	"sky_goldrush_01" : "sky_goldrush_01"
	"sky_granary_01" : "sky_granary_01"
	"sky_gravel_01" : "sky_gravel_01"
	"sky_halloween" : "sky_halloween"
	"sky_halloween_night_01" : "sky_halloween_night_01"
	"sky_halloween_night2014_01" : "sky_halloween_night2014_01"
	"sky_harvest_01" : "sky_harvest_01"
	"sky_harvest_night_01" : "sky_harvest_night_01"
	"sky_hydro_01" : "sky_hydro_01"
	"sky_island_01" : "sky_island_01"
	"sky_morningsnow_01" : "sky_morningsnow_01"
	"sky_night_01" : "sky_night_01"
	"sky_nightfall_01" : "sky_nightfall_01"
	"sky_pyroland_01" : "sky_pyroland_01"
	"sky_pyroland_02" : "sky_pyroland_02"
	"sky_pyroland_03" : "sky_pyroland_03"
	"sky_rainbow_01" : "sky_rainbow_01"
	"sky_stormfront_01" : "sky_stormfront_01"
	"sky_tf2_04" : "sky_tf2_04"
	"sky_trainyard_01" : "sky_trainyard_01"
	"sky_upward" : "sky_upward"
	"sky_well_01" : "sky_well_01"
	] // end skyname
    
    // Inputs
    input Trigger(void) : "Triggers the skybox change."
]

@PointClass base(STargetname) iconsprite("editor/logic_script.vmt") = logic_script :
	"An entity that acts as a container for scripts"
[
	Group00(target_destination) : "EntityGroup[0]" : : "Entity group 0"
	Group01(target_destination) : "EntityGroup[1]" : : "Entity group 1"
	Group02(target_destination) : "EntityGroup[2]" : : "Entity group 2"
	Group03(target_destination) : "EntityGroup[3]" : : "Entity group 3"
	Group04(target_destination) : "EntityGroup[4]" : : "Entity group 4"
	Group05(target_destination) : "EntityGroup[5]" : : "Entity group 5"
	Group06(target_destination) : "EntityGroup[6]" : : "Entity group 6"
	Group07(target_destination) : "EntityGroup[7]" : : "Entity group 7"
	Group08(target_destination) : "EntityGroup[8]" : : "Entity group 8"
	Group09(target_destination) : "EntityGroup[9]" : : "Entity group 9"
	Group10(target_destination) : "EntityGroup[10]" : : "Entity group 10"
	Group11(target_destination) : "EntityGroup[11]" : : "Entity group 11"
	Group12(target_destination) : "EntityGroup[12]" : : "Entity group 12"
	Group13(target_destination) : "EntityGroup[13]" : : "Entity group 13"
	Group14(target_destination) : "EntityGroup[14]" : : "Entity group 14"
	Group15(target_destination) : "EntityGroup[15]" : : "Entity group 15"
]

@PointClass base(SPreservedEntity, SBaseLogical) color(100 150 255) iconsprite("editor-ficool2/commentary_auto") = commentary_auto : "Fires outputs based on how commentary mode has been activated." [
	input MultiplayerSpawned(void) : "Fires the OnCommentaryMultiplayerSpawn output." // TODO: Automatically fired when a player spawns in multiplayer?

	output OnCommentaryNewGame(void) : "Fires when a new game is started with commentary enabled."
	output OnCommentaryMidGame(void) : "Fires when commentary is enabled midgame."
	output OnCommentaryMultiplayerSpawn(void) : "Fires when the MultiplayerSpawned input is used." // TODO: Automatically fired when a player spawns in multiplayer?
] // end commentary_auto

// TODOP: Doesn't seem to work completely in-game, even if we load in commentary mode. Is there something else we need to do? VDC indicates that this doesn't work unless a commentary txt also exists (even if blank)?
@BaseClass = point_commentary_node_keys [
	commentaryfile(sound) : "Commentary Audio" :  : "The sound file to play when this node is activated. Valve typically prefixes this with a # to bypass DSP."
	commentaryfile_nohdr(sound) : "Non-HDR Commentary Audio" :  : "The sound file to play when this node is activated and the player has HDR disabled. If unspecified, defaults to the Commentary Audio."
	speakers(string) : "Speaker Name" :  : "The name of the speaker to be displayed on the HUD when the sound file plays."
	//synopsis(string) : "Synopsis" :  : "" // Does not exist in code
	start_disabled(choices) : "Start Disabled?" : 0 : "Stay dormant until activated with the Enable input." = [
		0 : "No"
		1 : "Yes"
	] // end start_disabled
	precommands(string) : "Pre-Commands" :  : "Console command(s) to execute when this node starts playing."
	postcommands(string) : "Post-Commands" :  : "Console command(s) to execute when this node stops playing."
	prevent_movement(choices) : "Prevent Movement?" : 0 : "If Yes, the player will not be able to move while the commentary is playing." = [
		0 : "No"
		1 : "Yes"
	] // end prevent_movement
	viewposition(target_destination) : "View Position" :  : "The targetname of an entity to which the player's view should move while the commentary is playing. When the commentary file finishes, the player's view will move back to the place it was when the commentary started."
	viewtarget(target_destination) : "View Target" :  : "The targetname of an entity that the player's view should track while the commentary is playing. The player will not be able to control their view while the commentary file plays if this is specified."
	teleport_origin(string) : "Teleport Origin" :  : "" // TODO: What does this do? src-ents claims its an entity targetname, but code indicates its a vector...
] // end point_commentary_node_keys

@PointClass base(SPreservedEntity, SBaseEntity, SBaseDiv, point_commentary_node_keys, SBaseDynamicModel) studio("models/extras/info_speech.mdl") = point_commentary_node : "Node used by the commentary system. When the map is loaded in commentary mode, this entity will appear and play developer-curated dialogue when activated. These are usually defined in a commentary file named <mapname>_commentary.txt rather than manually placed in Hammer. See developer.valvesoftware.com/wiki/Commentary_System fore more info." [
	input Disable(void) : "Disable this entity."
	input Enable(void) : "Enable this entity."
	input StartCommentary(void) : "Start playing the commentary."
	input StartUnstoppableCommentary(void) : "Start playing the commentary, and don't allow the player to stop it in any way."

	output OnCommentaryStarted(void) : "Fired when the node starts playing its commentary."
	output OnCommentaryStopped(void) : "Fired when the node stops playing."
] // end point_commentary_node


@PointClass base(STargetname, SEnableDisable, SToggle, SAngles, Studiomodel, SBaseDynamicModel) studio("models/items/ammopack_medium.mdl") sphere(fademindist) sphere(fademaxdist) = tf_ammo_pack : "Used for the medium ammopacks, crit pumpkins, or smissmas presents that can be dropped by players. Not usually placed manually." []

//congrats you've scrolled all the way down to the end of this document, here's your reward. -Brokk
@PointClass iconsprite("editor/obsolete") = func_gameplay : "Yeah you wish this was real didn't you" [
	makemapgood(choices) : "Make map good" : 0 : "Should map be good or not good" = [
		0 : "map bad"
		1 : "map good"
	] // end makemapgood
	addsightlines(choices) : "Sightline strength" : 1 : "!fb sightline" = [
		0 : "!gf pls add more sightlines"
		1 : "map balanced"
		2 : "!fb sightlines op"
	] // end sniperyes
	classoverpowered(choices) : "Which class should be OP" : 8 : "there is always one" = [
		0 : "somehow all classes are fair and balanced haha just kidding"
		1 : "scout tryhard"
		2 : "roamer tryhard"
		3 : "tails"
		4 : "demon"
		5 : "heavy - WARNING: only works on payload maps"
		6 : "wrangler"
		7 : "medick"
		8 : "!fb sightline"
		9 : "nah spy is never OP"
		10 : "saxophone hell"
	] // end classoverpowered
] // end func_gameplay

// TODO:
// -waterbullet (http://src-ents.shoutwiki.com/wiki/Waterbullet), env_particlefire, env_physimpact, env_physwire, env_quadraticbeam, env_screeneffect, env_sniperdot, , info_cameralink, target_cdaudio, test_sidelist, trigger_cdaudio, trigger_changelevel
// -Re-add dxlevel keyvalues?
// -idk a bunch of stuff, ctrl-f for TODO to find it

// You can't spell documentation without cum hahaHAAAHAHAhahahah i am suffering

// +-+-+ +-+-+-+-+ +-+-+-+-+
// |D|A| |S|P|U|D| |L|O|R|D|
// +-+-+ +-+-+-+-+ +-+-+-+-+

// xxxxxxxxxxxxxxxxxxxxxxxxx
// xx B R O K K H O U S E xx
// xxxxxxxxxxxxxxxxxxxxxxxxx